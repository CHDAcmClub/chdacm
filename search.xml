<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2024/08/16/test/"/>
      <url>/2024/08/16/test/</url>
      
        <content type="html"><![CDATA[<p><img src="/.com//2.jpg" style="zoom:30%;"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图的连通性</title>
      <link href="/2024/08/04/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
      <url>/2024/08/04/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/.com//2.jpg" alt title="fufu">.<br><img src="/.com//2.jpg" style="zoom:50%;"></p><h2 id="Tarjan算法："><a href="#Tarjan算法：" class="headerlink" title="Tarjan算法："></a>Tarjan算法：</h2><p>dfn[ ]: 该点dfs的时间戳 </p><p>low[ ]: 该点可以通过非当前dfs路径到达的最小的时间戳</p><p>tarjan核心思想：一个父节点u，一个子节点v， 若low[v] &gt;= dfn[u]，则说明当前这个父节点对子节点具有绝对的控制，换言之，这个父节点与子节点之间的边要是断了，那么子节点没有其他路径可以到达一个时间戳更小的点去，那么这个连通分量就断开了，所以这条边就是割边，这个父节点（多半）是割点（如果是根节点的话还要判断一下）。</p><p>边双连通分量（EDCC）：一个无向图中，没有割边。一般图中，去掉割边，剩下的就是各个边双。</p><p>点双连通分量（VDCC）：一个无向图中，没有割点。求点双不是直接去掉割点。</p><p>强连通分量（SCC）：一个有向图中，任意点之间相互连通的极大连通分量</p><p>除了求边双可以用去掉割边再求联通分量的，其他过程中涉及到用stack保存dfs的顺序，从而得到各个连通块的方法，求边双也可以用stack。</p><h2 id="1、求割边及边双联通分量（EDCC）："><a href="#1、求割边及边双联通分量（EDCC）：" class="headerlink" title="1、求割边及边双联通分量（EDCC）："></a>1、求割边及边双联通分量（EDCC）：</h2><p>​    注意：两个点间可能有多条边，所以要记录各个边。</p><p>​    小技巧：从2开始记录边，2+1则是反边， 这样的话对每个边i，它的反边就是(i ^ 1)</p><p>题目：P8436</p><h3 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h3><p>​    先求出割边，再去掉割边，再求出连通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(<span class="number">2</span> * m + <span class="number">10</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(&#123;v,i &lt;&lt; <span class="number">1</span>&#125;);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(&#123;u,i &lt;&lt; <span class="number">1</span> ^ <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> tim = <span class="number">0</span>;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa)&#123;</span><br><span class="line">        dfn[u] = low[u] = ++tim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, vis] : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis == (fa ^ <span class="number">1</span>))&#123;<span class="comment">//不能从来的陆回去</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v,vis);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] &gt;= dfn[u])&#123; <span class="comment">//u对v有支配关系</span></span><br><span class="line">                    st[(vis)] = <span class="literal">true</span>; <span class="comment">// 记录割边</span></span><br><span class="line">                    st[(vis ^ <span class="number">1</span>)] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">EDCC</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w] : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[w] || st[w ^ <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                EDCC[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n + <span class="number">1</span>);</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u)&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        ans[cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : EDCC[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i].<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ans[i])&#123;</span><br><span class="line">            cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h3><p>​    直接stack模拟，速度快</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;PII&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(<span class="number">2</span> * m + <span class="number">10</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(&#123;v,i &lt;&lt; <span class="number">1</span>&#125;);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(&#123;u,i &lt;&lt; <span class="number">1</span> ^ <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> tim = <span class="number">0</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa)&#123;</span><br><span class="line">        dfn[u] = low[u] = ++tim;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, vis] : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis == (fa ^ <span class="number">1</span>))&#123;<span class="comment">//不能从来的陆回去</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v,vis);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] &gt;= dfn[u])&#123; <span class="comment">//u对v有支配关系</span></span><br><span class="line">                    st[(vis)] = <span class="literal">true</span>; <span class="comment">// 记录割边</span></span><br><span class="line">                    st[(vis ^ <span class="number">1</span>)] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low[u] == dfn[u])&#123; <span class="comment">//此时求得了极大的联通分量。</span></span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                v = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                ans[cnt].<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;<span class="keyword">while</span>(v != u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i].<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ans[i])&#123;</span><br><span class="line">            cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、求割点及点双连通分量（VDCC）："><a href="#2、求割点及点双连通分量（VDCC）：" class="headerlink" title="2、求割点及点双连通分量（VDCC）："></a>2、求割点及点双连通分量（VDCC）：</h2><h3 id="1、求割点"><a href="#1、求割点" class="headerlink" title="1、求割点"></a>1、求割点</h3><p>​    如果一个点不是根节点，且有可以支配的子节点，那么他就是一个割点；如果这个点是根节点，那么需要两个可支配的子节点。</p><p>题目：P3388</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cut</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> tim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u,<span class="type">int</span> fa)&#123;</span><br><span class="line">        dfn[u] = low[u] = ++tim;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v,u);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] &gt;= dfn[u])&#123;</span><br><span class="line">                    cnt ++;</span><br><span class="line">                    <span class="keyword">if</span>(fa != <span class="number">-1</span> || cnt &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                        cut[u] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i])&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : ans)&#123;</span><br><span class="line">        cout&lt;&lt;it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、求点双连通分量："><a href="#2、求点双连通分量：" class="headerlink" title="2、求点双连通分量："></a>2、求点双连通分量：</h3><p>​    每找到一个割点，就在就把栈中到这个割点的孩子的所有点添加进点双，并加入割点。（注意此时不能把割点从栈中删去，因为割点可能在多个点双中。）</p><p>​    注意：求解的时候记得把自环去掉，否则对于一些孤立的点来说，他们就无法被添加进点双中。</p><p>题目：P8435</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(u == v)&#123;<span class="comment">//去掉自环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cut</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> tim = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n + <span class="number">1</span>);</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u,<span class="type">int</span> fa)&#123;</span><br><span class="line">        dfn[u] = low[u] = ++tim;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(adj[u].<span class="built_in">size</span>() == <span class="number">0</span>)&#123; <span class="comment">//孤立的点特判一下</span></span><br><span class="line">            sum ++;</span><br><span class="line">            ans[sum].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v,u);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span>(low[v] &gt;= dfn[u])&#123;</span><br><span class="line">                    cnt ++;</span><br><span class="line">                    <span class="keyword">if</span>(u != <span class="number">-1</span> || cnt &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> to = <span class="number">0</span>;</span><br><span class="line">                        sum ++;</span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            to = stk.<span class="built_in">top</span>();</span><br><span class="line">                            stk.<span class="built_in">pop</span>();</span><br><span class="line">                            ans[sum].<span class="built_in">push_back</span>(to);</span><br><span class="line">                        &#125;<span class="keyword">while</span>(to != v);</span><br><span class="line">                        ans[sum].<span class="built_in">push_back</span>(u);</span><br><span class="line">                        cut[u] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sum; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i].<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : ans[i])&#123;</span><br><span class="line">            cout&lt;&lt;it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、求强连通分量（SCC）："><a href="#3、求强连通分量（SCC）：" class="headerlink" title="3、求强连通分量（SCC）："></a>3、求强连通分量（SCC）：</h2><p>​    1、每访问到一个点x，将他压入栈中，遍历所有邻接点y。</p><p>​    2、如果邻接点y已经在栈中了，说明邻接点的dfn[]更小，更新low[x] = min(low[x], dfn[y]);</p><p>​    3、如果没在栈中，就递归访问y，返回时更新low[x] = min(low[x], low[y]);</p><p>​    4、当前节点遍历完，如果dfn[x] == low[x]，则说明当前点是一个强连通分量的起点，此时一直弹栈，直到弹出当前点x，这些点构成一个强连通分量。</p><p>​    每一个dfn等于low的点，后面的点都是有其他方式可以访问到更早点的，但是当前点没法访问到更早的点，所以它可以作为一个强连通分量的起点。</p><p>​    5、入栈或出栈用一个st数组记录。</p><p>题目 ：P3387 </p><p>代码中的SCC即是缩点之后的新图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">low</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">st</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bel</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tim = <span class="number">0</span>;</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u)&#123;</span><br><span class="line">        dfn[u] = low[u] = ++tim;</span><br><span class="line">        st[u] = <span class="literal">true</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[v])&#123;</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                v = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                bel[v] = cnt;</span><br><span class="line">                st[v] = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">while</span>(u != v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> x = bel[i];</span><br><span class="line">        b[x] += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">SCC</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(bel[u] == bel[v])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> x = bel[u];</span><br><span class="line">                <span class="type">int</span> y = bel[v];</span><br><span class="line">                SCC[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line">        SCC[<span class="number">0</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    qu.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>() &amp;&amp; f)&#123;</span><br><span class="line">        <span class="keyword">auto</span> x = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y : SCC[x])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &gt; dis[x] + (-b[y]))&#123;</span><br><span class="line">                dis[y] = dis[x] - b[y];</span><br><span class="line">                <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(++sum[y] &gt;= n)&#123;</span><br><span class="line">                        f = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                    qu.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)&#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = -ans;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂（6）</title>
      <link href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%826/"/>
      <url>/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%826/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1651738873201_2022春季算法讲堂（六）.pdf">点击下载课件</a></p><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h3><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h3><h3 id="二分图其他常见问题"><a href="#二分图其他常见问题" class="headerlink" title="二分图其他常见问题"></a>二分图其他常见问题</h3><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="Edmonds-karps增广路算法"><a href="#Edmonds-karps增广路算法" class="headerlink" title="Edmonds-karps增广路算法"></a>Edmonds-karps增广路算法</h3><h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><p>主讲人：夏强</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂（5）</title>
      <link href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%825/"/>
      <url>/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%825/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1651739127459_2022春季算法讲堂（五）.pdf">点击下载课件</a></p><h1 id="最短途径"><a href="#最短途径" class="headerlink" title="最短途径"></a>最短途径</h1><h2 id="Dijksra算法"><a href="#Dijksra算法" class="headerlink" title="Dijksra算法"></a>Dijksra算法</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><h3 id="2-基本思想"><a href="#2-基本思想" class="headerlink" title="2.基本思想"></a>2.基本思想</h3><h3 id="3-Dijksra-算法伪代码"><a href="#3-Dijksra-算法伪代码" class="headerlink" title="3.Dijksra 算法伪代码"></a>3.Dijksra 算法伪代码</h3><h3 id="4-Dijksra算法图示"><a href="#4-Dijksra算法图示" class="headerlink" title="4.Dijksra算法图示"></a>4.Dijksra算法图示</h3><h3 id="5-算法的代码实现"><a href="#5-算法的代码实现" class="headerlink" title="5.算法的代码实现"></a>5.算法的代码实现</h3><h3 id="6-例题CHDOJ-2244"><a href="#6-例题CHDOJ-2244" class="headerlink" title="6.例题CHDOJ 2244"></a>6.例题CHDOJ 2244</h3><h2 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman-ford算法"></a>Bellman-ford算法</h2><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><h3 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2.算法流程"></a>2.算法流程</h3><h3 id="3-算法的代码实现"><a href="#3-算法的代码实现" class="headerlink" title="3.算法的代码实现"></a>3.算法的代码实现</h3><h3 id="4-例题Acwing-853-有边数限制的最短路"><a href="#4-例题Acwing-853-有边数限制的最短路" class="headerlink" title="4.例题Acwing 853.有边数限制的最短路"></a>4.例题Acwing 853.有边数限制的最短路</h3><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><h3 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h3><h3 id="2-算法的代码实现"><a href="#2-算法的代码实现" class="headerlink" title="2.算法的代码实现"></a>2.算法的代码实现</h3><h3 id="3-例题Acwing-854-Floyd求最短路"><a href="#3-例题Acwing-854-Floyd求最短路" class="headerlink" title="3.例题Acwing 854.Floyd求最短路"></a>3.例题Acwing 854.Floyd求最短路</h3><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="一、Prim算法"><a href="#一、Prim算法" class="headerlink" title="一、Prim算法"></a>一、Prim算法</h2><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><h3 id="2-Prim算法伪代码"><a href="#2-Prim算法伪代码" class="headerlink" title="2.Prim算法伪代码"></a>2.Prim算法伪代码</h3><h3 id="3-Prim算法图示"><a href="#3-Prim算法图示" class="headerlink" title="3.Prim算法图示"></a>3.Prim算法图示</h3><h3 id="4-算法的代码实现"><a href="#4-算法的代码实现" class="headerlink" title="4.算法的代码实现"></a>4.算法的代码实现</h3><h3 id="5-例题ACwing-858-Prim算法求最小生成树"><a href="#5-例题ACwing-858-Prim算法求最小生成树" class="headerlink" title="5.例题ACwing 858.Prim算法求最小生成树"></a>5.例题ACwing 858.Prim算法求最小生成树</h3><h2 id="二、Kruskal算法（破圈发，并查集的应用）"><a href="#二、Kruskal算法（破圈发，并查集的应用）" class="headerlink" title="二、Kruskal算法（破圈发，并查集的应用）"></a>二、Kruskal算法（破圈发，并查集的应用）</h2><h3 id="1-基本思想-1"><a href="#1-基本思想-1" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><h3 id="2-Kruskal算法伪代码"><a href="#2-Kruskal算法伪代码" class="headerlink" title="2.Kruskal算法伪代码"></a>2.Kruskal算法伪代码</h3><h3 id="3-Kruskal算法图示"><a href="#3-Kruskal算法图示" class="headerlink" title="3.Kruskal算法图示"></a>3.Kruskal算法图示</h3><h3 id="4-算法的代码实现-1"><a href="#4-算法的代码实现-1" class="headerlink" title="4.算法的代码实现"></a>4.算法的代码实现</h3><h3 id="5-例题Acwing-859-Kruskal算法求最小生成树"><a href="#5-例题Acwing-859-Kruskal算法求最小生成树" class="headerlink" title="5.例题Acwing 859.Kruskal算法求最小生成树"></a>5.例题Acwing 859.Kruskal算法求最小生成树</h3><h1 id="最近公共祖先（LCA）"><a href="#最近公共祖先（LCA）" class="headerlink" title="最近公共祖先（LCA）"></a>最近公共祖先（LCA）</h1><h2 id="一、倍增"><a href="#一、倍增" class="headerlink" title="一、倍增"></a>一、倍增</h2><h3 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1.算法思路"></a>1.算法思路</h3><h3 id="2-例题P3379最近公共祖先（LCA）"><a href="#2-例题P3379最近公共祖先（LCA）" class="headerlink" title="2.例题P3379最近公共祖先（LCA）"></a>2.例题P3379最近公共祖先（LCA）</h3><h2 id="二、Tarjan算法（离线）"><a href="#二、Tarjan算法（离线）" class="headerlink" title="二、Tarjan算法（离线）"></a>二、Tarjan算法（离线）</h2><h3 id="1-基本思想（DFS遍历）"><a href="#1-基本思想（DFS遍历）" class="headerlink" title="1.基本思想（DFS遍历）"></a>1.基本思想（DFS遍历）</h3><h3 id="2-算法的伪代码"><a href="#2-算法的伪代码" class="headerlink" title="2.算法的伪代码"></a>2.算法的伪代码</h3><h3 id="3-算法图示"><a href="#3-算法图示" class="headerlink" title="3.算法图示"></a>3.算法图示</h3><p>主讲人：田宇</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂（4）</title>
      <link href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%824/"/>
      <url>/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%824/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1651738090001_2022春季算法讲堂（四）.pdf">点击下载课件</a></p><h1 id="图的基础知识"><a href="#图的基础知识" class="headerlink" title="图的基础知识"></a>图的基础知识</h1><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><h2 id="有向图与无向图"><a href="#有向图与无向图" class="headerlink" title="有向图与无向图"></a>有向图与无向图</h2><h2 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h2><h2 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h2><h2 id="稀疏图和稠密图"><a href="#稀疏图和稠密图" class="headerlink" title="稀疏图和稠密图"></a>稀疏图和稠密图</h2><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><h2 id="邻接、依附"><a href="#邻接、依附" class="headerlink" title="邻接、依附"></a>邻接、依附</h2><h2 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h2><h2 id="路径、路径长度、回路"><a href="#路径、路径长度、回路" class="headerlink" title="路径、路径长度、回路"></a>路径、路径长度、回路</h2><h2 id="简单路径、简单回路"><a href="#简单路径、简单回路" class="headerlink" title="简单路径、简单回路"></a>简单路径、简单回路</h2><h2 id="连通图、连通分量"><a href="#连通图、连通分量" class="headerlink" title="连通图、连通分量"></a>连通图、连通分量</h2><h2 id="强连通图、强连通分量"><a href="#强连通图、强连通分量" class="headerlink" title="强连通图、强连通分量"></a>强连通图、强连通分量</h2><h2 id="生成树和生成森林"><a href="#生成树和生成森林" class="headerlink" title="生成树和生成森林"></a>生成树和生成森林</h2><h2 id="边的权和网图"><a href="#边的权和网图" class="headerlink" title="边的权和网图"></a>边的权和网图</h2><h2 id="图是存储结构"><a href="#图是存储结构" class="headerlink" title="图是存储结构"></a>图是存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h3 id="邻接矩阵和邻接表的比较"><a href="#邻接矩阵和邻接表的比较" class="headerlink" title="邻接矩阵和邻接表的比较"></a>邻接矩阵和邻接表的比较</h3><h2 id="图的遍历方式"><a href="#图的遍历方式" class="headerlink" title="图的遍历方式"></a>图的遍历方式</h2><h3 id="图的DFS遍历"><a href="#图的DFS遍历" class="headerlink" title="图的DFS遍历"></a>图的DFS遍历</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>主讲人：田宇</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂（3）</title>
      <link href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%823/"/>
      <url>/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%823/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1651738018977_2022春季算法讲堂（三）.pdf">点击下载课件</a></p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h2 id="并查集的实现"><a href="#并查集的实现" class="headerlink" title="并查集的实现"></a>并查集的实现</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><h3 id="初始化（按秩合并）"><a href="#初始化（按秩合并）" class="headerlink" title="初始化（按秩合并）"></a>初始化（按秩合并）</h3><h3 id="合并（按秩合并）"><a href="#合并（按秩合并）" class="headerlink" title="合并（按秩合并）"></a>合并（按秩合并）</h3><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h2 id="冲突与处理"><a href="#冲突与处理" class="headerlink" title="冲突与处理"></a>冲突与处理</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><h3 id="哈希函数-1"><a href="#哈希函数-1" class="headerlink" title="哈希函数"></a>哈希函数</h3><h3 id="前缀子串"><a href="#前缀子串" class="headerlink" title="前缀子串"></a>前缀子串</h3><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h3 id="博弈论题目特点"><a href="#博弈论题目特点" class="headerlink" title="博弈论题目特点"></a>博弈论题目特点</h3><h2 id="经典博弈"><a href="#经典博弈" class="headerlink" title="经典博弈"></a>经典博弈</h2><h3 id="巴什博奕（Bash-Game）"><a href="#巴什博奕（Bash-Game）" class="headerlink" title="巴什博奕（Bash Game）"></a>巴什博奕（Bash Game）</h3><h3 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h3><h4 id="满足上述公式的性质"><a href="#满足上述公式的性质" class="headerlink" title="满足上述公式的性质"></a>满足上述公式的性质</h4><h3 id="尼姆博弈（Nim-Game）"><a href="#尼姆博弈（Nim-Game）" class="headerlink" title="尼姆博弈（Nim Game）"></a>尼姆博弈（Nim Game）</h3><h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><h4 id="ICG-公平组合-游戏"><a href="#ICG-公平组合-游戏" class="headerlink" title="ICG(公平组合)游戏"></a>ICG(公平组合)游戏</h4><h4 id="必胜态与必败态"><a href="#必胜态与必败态" class="headerlink" title="必胜态与必败态"></a>必胜态与必败态</h4><h4 id="DAG-有向无环图-中的博弈"><a href="#DAG-有向无环图-中的博弈" class="headerlink" title="DAG(有向无环图)中的博弈"></a>DAG(有向无环图)中的博弈</h4><h4 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h4><h4 id="SG定理的应用"><a href="#SG定理的应用" class="headerlink" title="SG定理的应用"></a>SG定理的应用</h4><p>主讲人：孙如祥</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂（2）</title>
      <link href="/2022/03/30/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%822/"/>
      <url>/2022/03/30/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%822/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1648619647449_单调栈队列.pdf">点击下载课件</a></p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>主讲人：王瑄</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂（1）</title>
      <link href="/2022/03/30/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%821/"/>
      <url>/2022/03/30/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%821/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1648619302723_数据结构：链表、栈、队列.pptx">点击下载课件</a></p><h1 id="数据结构是什么"><a href="#数据结构是什么" class="headerlink" title="数据结构是什么"></a>数据结构是什么</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>主讲人：张家欢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022春季算法讲堂安排</title>
      <link href="/2022/03/30/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%82%E5%AE%89%E6%8E%92/"/>
      <url>/2022/03/30/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%82%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h2 id="2022-ACM社团算法讲堂"><a href="#2022-ACM社团算法讲堂" class="headerlink" title="2022 ACM社团算法讲堂"></a><strong>2022 ACM社团算法讲堂</strong></h2><h3 id="时间：每周六晚-18-00-21-00"><a href="#时间：每周六晚-18-00-21-00" class="headerlink" title="时间：每周六晚$18:00-21:00$"></a>时间：每周六晚$18:00-21:00$</h3><div class="table-container"><table><thead><tr><th style="text-align:left">内容</th><th>主讲人</th><th>时间</th></tr></thead><tbody><tr><td style="text-align:left">链表、栈、队列</td><td>张家欢</td><td>3.19</td></tr><tr><td style="text-align:left">单调栈、单调队列</td><td>王瑄</td><td>3.26</td></tr><tr><td style="text-align:left">并查集、哈希表、博弈论</td><td>孙如祥</td><td>4.2</td></tr><tr><td style="text-align:left">树、堆、图基础知识、拓扑排序</td><td>田宇</td><td>4.9</td></tr><tr><td style="text-align:left">最短路、最小生成树</td><td>田宇</td><td>4.16</td></tr><tr><td style="text-align:left">二分图、网络流</td><td>夏强</td><td>4.23</td></tr><tr><td style="text-align:left">线段树、树状数组</td><td>周赛</td><td>4.30</td></tr><tr><td style="text-align:left">字符串：$KMP$,$Trie$,$AC$自动机</td><td>余锦鹏</td><td>5.7</td></tr><tr><td style="text-align:left">数论</td><td>陈申奥</td><td>5.14</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Good Bye 2021:2022 is NEAR 部分题解</title>
      <link href="/2022/01/01/cf%E9%A2%98%E8%A7%A3by-yjp/"/>
      <url>/2022/01/01/cf%E9%A2%98%E8%A7%A3by-yjp/</url>
      
        <content type="html"><![CDATA[<p>author：余锦鹏</p><p><a href="https://cos.chdacm.cn/file/1641036690140_Good Bye 2021 2022 is NEAR题解与总结.pdf">点击下载题解文件</a></p><h2 id="A-Integer-Diversity"><a href="#A-Integer-Diversity" class="headerlink" title="A. Integer Diversity"></a>A. Integer Diversity</h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给你一个数字序列，你可以对序列里面的任意元素进行正负号变换，求最多存在多少个不同的序列。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>将所有的正负数变成正数存到flag数组里面，然后每存一次flag[i]++，对于除去0外的数flag[i]==1使sum++,flag[i]&gt;=2使sum+=2,对于flag[0]&gt;0就sum++,最后输出sum。</p><p>刚开始的时候我觉得这种简单题可以争取下三分钟秒了，但是WA一发后才认真看了下题目发现看错了，后面看对题目后我又急于求成，没考虑到序列中存在负数，结果又WA了，最后清醒过来改了下才AC。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e2</span><span class="number">+10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -n;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">a[i]=<span class="built_in">fun</span>(a[i]);</span><br><span class="line">flag[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag[i]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">sum+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag[i]==<span class="number">1</span>)</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Mirror-in-the-String（1100）"><a href="#B-Mirror-in-the-String（1100）" class="headerlink" title="B. Mirror in the String（1100）"></a>B. Mirror in the String（1100）</h2><h3 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h3><p>给你一个字符串，你可以在字符串任意一处放一面镜子得到一个镜像的字符串，即类似于s1s2…sksksk−1…s1这样子，求字典数最小的字符串。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>刚开始写的时候，我觉得只要是字典数递减就行了，后面直接WA了。但是自己脑子一根筋，一直陷在这个思路中。后面找到了cbba这样的特殊样例，我又以为是在递减的基础上找对称，即当相等的时候看下以相等的字符为对称轴对称的字符比大小，然后陷进去无法自拔了。最终都没有做出来，掉大分了！后面和别人交流了一下，发现bba这样的样例能够否决掉我的想法。参考了别人的思路，实际上非递增就可以实现功能，但是有一个特例需要注意，就是bba这种，这是非递增的字符串，但是答案是bb,不是bbaabb，这个需要特判一下。</p><p>不难的题目，但是第一发容易WA，确实挺多人是WA了，但是后面又找到规律就AC了。因此这道题对于我来说是一种思维壁垒，得积累下。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n&gt;<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==s[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;s[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i<span class="number">-1</span>]&lt;s[i])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Representative-Edges（1500）"><a href="#C-Representative-Edges（1500）" class="headerlink" title="C. Representative Edges（1500）"></a>C. Representative Edges（1500）</h2><h3 id="题意：-2"><a href="#题意：-2" class="headerlink" title="题意："></a>题意：</h3><p>给你一个序列，你可以将其中的数变成任意一个数，可以是double型的。让你进行最少的次数将其变成一个等差数列。</p><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>数据量非常小，可以使用O（$N^3$）算法。怎么切入呢？我们可以从等差数列是怎么确定的切入。</p><p>我们知道什么？假设存在等差数列，那我们知道任意两个数，与其中相隔的多少个数。这个就可以来确定一个等差数列，既然数据量不大，那我们就可以进行遍历，用i,j表示这选中的数，得到d=(a[j]-a[i])/(j-i),注意，可以是小数，所以记得用double类型。后面就进行得出这个等差数列，比较下需要改变多少个数，遍历O($N^2$)次就得到答案了。</p><p>做到这里我都是没什么问题的，但是我却WA了。为什么捏？对于double来说，它是有精度限制的，比如就算是5.0/3.0*3.0与5.0是不相等的。怎么解决呢？用<code>fabs(a[k] - b[k]) &gt;= 1e-9</code>这样的语句来处理(精度视题目而定)，fabs()返回的是绝对值。这样就能解决精度问题了。这在计算几何里面用的多。</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> a[maxn],b[maxn];</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">min</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="type">double</span> d=(a[j]-a[i])/<span class="built_in">double</span>(j-i);</span><br><span class="line">b[<span class="number">0</span>]=a[i]-d*i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">b[k]=b[k<span class="number">-1</span>]+d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a[k] - b[k]) &gt;= <span class="number">1e-9</span>)  <span class="comment">//不能用a[k]!=b[k]</span></span><br><span class="line">       sum++;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,sum);</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年新生赛</title>
      <link href="/2021/12/05/2021%E5%B9%B4%E6%96%B0%E7%94%9F%E8%B5%9B/"/>
      <url>/2021/12/05/2021%E5%B9%B4%E6%96%B0%E7%94%9F%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="新生赛报名"><a href="#新生赛报名" class="headerlink" title="新生赛报名"></a>新生赛报名</h2><p><a href="https://www.wjx.cn/vj/rlDCSPb.aspx">报名链接</a><br>进入链接填写信息即可报名成功<br>目前暂时只接纳长安大学的学生报名，外校同学可以在chdoj同步参加</p><h2 id="新生赛通知"><a href="#新生赛通知" class="headerlink" title="新生赛通知"></a>新生赛通知</h2><p>时间安排：12月11日（周六）</p><div class="table-container"><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">地点</th><th style="text-align:left">事宜</th></tr></thead><tbody><tr><td style="text-align:left">9:00—10:00</td><td style="text-align:left">WM2201</td><td style="text-align:left">告诉大家比赛环境和注意事项</td></tr><tr><td style="text-align:left">10:00—11:00</td><td style="text-align:left">比赛机房</td><td style="text-align:left">热身赛</td></tr><tr><td style="text-align:left">12:30—17:30</td><td style="text-align:left">比赛机房</td><td style="text-align:left">正式赛</td></tr><tr><td style="text-align:left">19:00—21:00</td><td style="text-align:left">WM2201</td><td style="text-align:left">颁奖&amp;讲题</td></tr></tbody></table></div><p>题目讲解及颁奖比赛题目为10~13道中文题，比赛可以带任何的纸质资料，但不得使用电子设备。</p><p>奖品设置：一血（最快解题奖）、最佳女生、一等奖三项、二等奖四项、三等奖五项、顽强拼搏奖。</p><p><a href="https://oj.chdacm.cn/problemset.php?page=29">chdoj官网</a>有历年新生赛题目，给大家参考练习。</p><p>最后祝大家体验愉快，取得理想的成绩!</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 长安大学新生赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021算法讲堂第九讲-基础动态规划</title>
      <link href="/2021/12/05/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%829/"/>
      <url>/2021/12/05/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%829/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1638707733359_算法讲堂第九讲-动态规划.pdf">点击下载课件</a></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划初阶"><a href="#动态规划初阶" class="headerlink" title="动态规划初阶"></a>动态规划初阶</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="简单背包问题"><a href="#简单背包问题" class="headerlink" title="简单背包问题"></a>简单背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021算法讲堂第八讲-DFS BFS</title>
      <link href="/2021/12/05/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%828/"/>
      <url>/2021/12/05/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%828/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1638707433500_算法讲堂第八讲-DFS BFS.pdf">点击下载课件</a></p><h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h1><h2 id="搜索的定义"><a href="#搜索的定义" class="headerlink" title="搜索的定义"></a>搜索的定义</h2><h2 id="DFS（深度优先搜索）"><a href="#DFS（深度优先搜索）" class="headerlink" title="DFS（深度优先搜索）"></a>DFS（深度优先搜索）</h2><h2 id="向下递归"><a href="#向下递归" class="headerlink" title="向下递归"></a>向下递归</h2><h2 id="向上递归"><a href="#向上递归" class="headerlink" title="向上递归"></a>向上递归</h2><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><h3 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h3><h2 id="DFS非递归"><a href="#DFS非递归" class="headerlink" title="DFS非递归"></a>DFS非递归</h2><h2 id="BFS（广度优先搜索）"><a href="#BFS（广度优先搜索）" class="headerlink" title="BFS（广度优先搜索）"></a>BFS（广度优先搜索）</h2><h2 id="回顾队列"><a href="#回顾队列" class="headerlink" title="回顾队列"></a>回顾队列</h2><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="马的遍历"><a href="#马的遍历" class="headerlink" title="马的遍历"></a>马的遍历</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021算法讲堂第七讲-STL</title>
      <link href="/2021/12/05/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%827/"/>
      <url>/2021/12/05/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%827/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1638707038018_算法讲堂第七讲-STL.pdf">点击下载课件</a></p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="STL是什么"><a href="#STL是什么" class="headerlink" title="STL是什么"></a>STL是什么</h2><h2 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h2><h2 id="动态数组（vector）"><a href="#动态数组（vector）" class="headerlink" title="动态数组（vector）"></a>动态数组（vector）</h2><h2 id="关于迭代器（iterator）"><a href="#关于迭代器（iterator）" class="headerlink" title="*关于迭代器（iterator）"></a>*关于迭代器（iterator）</h2><h2 id="栈和队列（queue-and-stack）"><a href="#栈和队列（queue-and-stack）" class="headerlink" title="栈和队列（queue and stack）"></a>栈和队列（queue and stack）</h2><h2 id="优先队列（priority-queue）"><a href="#优先队列（priority-queue）" class="headerlink" title="优先队列（priority_queue）"></a>优先队列（priority_queue）</h2><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><h2 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h2><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><h3 id="去重函数"><a href="#去重函数" class="headerlink" title="去重函数"></a>去重函数</h3><h3 id="二分函数"><a href="#二分函数" class="headerlink" title="二分函数"></a>二分函数</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题网站介绍</title>
      <link href="/2021/11/07/%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/11/07/%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="常用刷题网站"><a href="#常用刷题网站" class="headerlink" title="常用刷题网站"></a>常用刷题网站</h1><h2 id="关于CHDOJ-https-oj-chdacm-cn"><a href="#关于CHDOJ-https-oj-chdacm-cn" class="headerlink" title="关于CHDOJ(https://oj.chdacm.cn/)"></a>关于CHDOJ<a href="https://oj.chdacm.cn/">(https://oj.chdacm.cn/)</a></h2><p>由CHD集训队维护的oj，如果遇到问题可以直接在迎新群中找管理员询问。</p><h2 id="关于CodeForces-https-codeforces-com"><a href="#关于CodeForces-https-codeforces-com" class="headerlink" title="关于CodeForces(https://codeforces.com)"></a>关于CodeForces<a href="https://codeforces.com">(https://codeforces.com)</a></h2><h5 id="镜像网站-https-codeforc-es"><a href="#镜像网站-https-codeforc-es" class="headerlink" title="镜像网站(https://codeforc.es)"></a>镜像网站<a href="https://codeforc.es">(https://codeforc.es)</a></h5><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>codeforces（以下简称cf）是俄罗斯的一个网站，在这里面你可以找到各种难度等级的题目，这些题目往往偏向于思维。cf最具特点的是它自己的上分系统，基本上每周会举办一到两次在线的算法比赛，比赛通过div分了不同的难度等级。</p><p>什么？晚上在寝室寂寞无聊？那就和好朋友一起来一把激情刺激的cf吧</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>点击右上角的Register注册用户</p><p><img src="https://cos.chdacm.cn/imgs/1636251580441_cf1.png" alt="截屏2021-08-31 下午9.58.36.png"></p><h3 id="几个比较重要的页面"><a href="#几个比较重要的页面" class="headerlink" title="几个比较重要的页面"></a>几个比较重要的页面</h3><h4 id="home首页"><a href="#home首页" class="headerlink" title="home首页"></a>home首页</h4><p><img src="https://cos.chdacm.cn/imgs/1636251606694_cf2.png" alt="截屏2021-08-31 下午10.08.21.png"></p><h4 id="TOP"><a href="#TOP" class="headerlink" title="TOP"></a>TOP</h4><p><img src="https://cos.chdacm.cn/imgs/1636251627678_cf3.png" alt="截屏2021-08-31 下午11.36.29.png"></p><p>top里基本上是大佬放出来的一些资料、博客和题解什么的。这里面干货还是很多的，但是由于是国外的网站，所以显然肯定是全英文的。不过描述一个问题或者是算法的时候也不会使用太晦涩的单词，所以还是蛮好懂的。</p><h4 id="contests比赛"><a href="#contests比赛" class="headerlink" title="contests比赛"></a>contests比赛</h4><p><img src="https://cos.chdacm.cn/imgs/1636251651544_cf4.png" alt="截屏2021-08-31 下午10.11.25.png"></p><p>这里有即将开始和过去曾经举办过的线上比赛。</p><p>即将开始的比赛会有一个register按钮，让大家参加比赛。（因为cf是国外网站，线上比赛举办的时间一般是晚上10：30到12：30）</p><p>比赛名称后面括号里div表示的是难度等级，div1是最高难度。需要有1900以上的rating才可以报名。div2难度会简单很多，基本上学过算法和数据结构都可以进去做一两道题。div2的比赛前两题基本上都不涉及什么算法，主要是考验思维。一般到了C题之后才会考察一些算法和数据结构。div3的比赛最简单，一般比过题的手速。</p><p>codeforces有一个专门的rating分数，每场比赛结束之后，会根据你在这场比赛的表现以及你现在的rating，来增加或者减少你的rating分数，系统会根据你现在的rating对你的表现有一个期望，你最终的涨跌就是你实际表现和这个期望的差值，你的实际表现比这个期望高，你的rating分数就会增加，否则就会降低。</p><p>codeforces在比赛的时候只会测试一小部分数据，真正的测试集会放到赛后进行测试。所以在比赛中测试通过的代码，只是通过了小数据验证，很有可能有隐藏的问题没被发现。当你通过了这道题之后，你就可以去查看其他通过人的代码，去分析它们有没有问题，如果发现了bug，可以构造一份数据hack掉他的提交（使他的代码wa）。hack成功之后，你会获得分数的奖励。（当然新手建议老老实实做题目）</p><h4 id="gym"><a href="#gym" class="headerlink" title="gym"></a>gym</h4><p>练习题（一般是之前举办的一些线下比赛）</p><p><img src="https://cos.chdacm.cn/imgs/1636251672314_cf5.png" alt="截屏2021-08-31 下午10.51.24.png"></p><h4 id="problemset题目"><a href="#problemset题目" class="headerlink" title="problemset题目"></a>problemset题目</h4><p><img src="https://cos.chdacm.cn/imgs/1636251689158_cf6.png" alt="截屏2021-08-31 下午10.14.42.png"></p><p>这里收纳了cf所有的题目，可以按照难度来找题目刷题，也可以在赛后进行补题。（PS：题目是全英文题面）</p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p><img src="https://cos.chdacm.cn/imgs/1636251705507_cf7.png" alt="截屏2021-08-31 下午11.44.08.png"></p><p><img src="https://cos.chdacm.cn/imgs/1636251717815_cf8.png" alt="截屏2021-08-31 下午11.45.39.png"></p><p><img src="https://cos.chdacm.cn/imgs/1636251738797_cf9.png" alt="截屏2021-08-31 下午11.48.56.png"></p><p>cf上提交可以看见题目测试的数据，可以根据这些数据来找出代码中的bug</p><p><img src="https://cos.chdacm.cn/imgs/1636251755058_cf10.png" alt="截屏2021-08-31 下午11.55.35.png"></p><h2 id="关于VJ-https-vjudge-net"><a href="#关于VJ-https-vjudge-net" class="headerlink" title="关于VJ(https://vjudge.net)"></a>关于VJ<a href="https://vjudge.net">(https://vjudge.net)</a></h2><p>全称是Virtual Judge，顾名思义，虚拟评测姬并不是一个真正的在线评测姬。它可以从其他常规的在线评测姬那里获取问题，并模拟提交给其他在线评测姬。它可以挂其他网站的题目，是我们日常挂题训练的网站。</p><h3 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h3><p>点击右上角的Register注册</p><p><img src="https://cos.chdacm.cn/imgs/1636251768863_vj1.png" alt="快去"></p><p>填写个人信息</p><p><img src="https://cos.chdacm.cn/imgs/1636251786802_vj2.png" alt="学习"></p><p>注册成功后点击右上角的Login登录</p><h3 id="进入CHD新生组"><a href="#进入CHD新生组" class="headerlink" title="进入CHD新生组"></a>进入CHD新生组</h3><p>跳转网页<a href="https://vjudge.net/group/chdacm2021">https://vjudge.net/group/chdacm2021</a>或者在group的Explore中搜索CHD-ACM 2021 新生训练</p><p>（2021年的CHD新生组是CHD-ACM 2021 新生训练）</p><p><img src="https://cos.chdacm.cn/imgs/1636251809603_vj3.png" alt="算法"></p><p><img src="https://cos.chdacm.cn/imgs/1636251826940_vj4.png" alt="争金拿银"></p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><img src="https://cos.chdacm.cn/imgs/1636251846118_vj5.png" alt="不要"></p><p><img src="https://cos.chdacm.cn/imgs/1636251858808_vj6.png" alt="划水"></p><p>要严格按照题目要求的输入输出格式进行输入输出</p><p>提交代码</p><p><img src="https://cos.chdacm.cn/imgs/1636251878690_vj7.png" alt="摸鱼"></p><p>提交结果</p><h2 id="关于其他网站"><a href="#关于其他网站" class="headerlink" title="关于其他网站"></a>关于其他网站</h2><p><a href="https://ac.nowcoder.com/acm/home">牛客竞赛</a></p><p><a href="https://www.acwing.com/">ACWing</a></p><p><a href="https://pintia.cn/">PTA</a></p><p><a href="https://leetcode-cn.com/">力扣</a></p><p><a href="https://acm.hdu.edu.cn/">HDUOJ(杭电OJ)</a></p><p><a href="http://poj.org/">POJ(北大OJ)</a></p><p>快开始你的刷题之路吧~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2021算法讲堂第六讲-基础数论</title>
      <link href="/2021/11/07/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%826/"/>
      <url>/2021/11/07/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%826/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1636248219410_算法讲堂第六讲-基础数论.pdf">点击下载课件</a></p><h1 id="基础数论"><a href="#基础数论" class="headerlink" title="基础数论"></a>基础数论</h1><h2 id="GCD、LCD"><a href="#GCD、LCD" class="headerlink" title="GCD、LCD"></a>GCD、LCD</h2><h3 id="最大公约数（GCD）"><a href="#最大公约数（GCD）" class="headerlink" title="最大公约数（GCD）"></a>最大公约数（GCD）</h3><h3 id="最小公倍数（LCM）"><a href="#最小公倍数（LCM）" class="headerlink" title="最小公倍数（LCM）"></a>最小公倍数（LCM）</h3><h2 id="质数与质数筛"><a href="#质数与质数筛" class="headerlink" title="质数与质数筛"></a>质数与质数筛</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><h3 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h3><h4 id="埃氏塞"><a href="#埃氏塞" class="headerlink" title="埃氏塞"></a>埃氏塞</h4><h4 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h4><h2 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h2><h3 id="高精度算法定义"><a href="#高精度算法定义" class="headerlink" title="高精度算法定义"></a>高精度算法定义</h3><h3 id="高精度算法思想"><a href="#高精度算法思想" class="headerlink" title="高精度算法思想"></a>高精度算法思想</h3><h3 id="高精度数读入与存储"><a href="#高精度数读入与存储" class="headerlink" title="高精度数读入与存储"></a>高精度数读入与存储</h3><h3 id="前导0删除"><a href="#前导0删除" class="headerlink" title="前导0删除"></a>前导0删除</h3><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><h3 id="高精乘低精"><a href="#高精乘低精" class="headerlink" title="高精乘低精"></a>高精乘低精</h3><h3 id="高精乘高精"><a href="#高精乘高精" class="headerlink" title="高精乘高精"></a>高精乘高精</h3><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><h3 id="一个完整高精度题目的代码"><a href="#一个完整高精度题目的代码" class="headerlink" title="一个完整高精度题目的代码"></a>一个完整高精度题目的代码</h3><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="朴素快速幂"><a href="#朴素快速幂" class="headerlink" title="朴素快速幂"></a>朴素快速幂</h3><h3 id="位运算优化快速幂"><a href="#位运算优化快速幂" class="headerlink" title="位运算优化快速幂"></a>位运算优化快速幂</h3><h3 id="快速幂取模"><a href="#快速幂取模" class="headerlink" title="快速幂取模"></a>快速幂取模</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 基础数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021算法讲堂第五讲-双指针、前缀和、差分、离散化</title>
      <link href="/2021/10/30/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%825/"/>
      <url>/2021/10/30/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%825/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1635588183982_双指针、前缀和、差分、离散化.pdf">点击下载课件</a></p><h1 id="双指针、前缀和、差分、离散化"><a href="#双指针、前缀和、差分、离散化" class="headerlink" title="双指针、前缀和、差分、离散化"></a>双指针、前缀和、差分、离散化</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="双指针介绍"><a href="#双指针介绍" class="headerlink" title="双指针介绍"></a>双指针介绍</h3><h3 id="对向指针"><a href="#对向指针" class="headerlink" title="对向指针"></a>对向指针</h3><h3 id="同向指针"><a href="#同向指针" class="headerlink" title="同向指针"></a>同向指针</h3><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="前缀和的优势"><a href="#前缀和的优势" class="headerlink" title="前缀和的优势"></a>前缀和的优势</h3><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><h2 id="重复元素离散化"><a href="#重复元素离散化" class="headerlink" title="重复元素离散化"></a>重复元素离散化</h2><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021算法讲堂第四讲-枚举、递归、二分、贪心</title>
      <link href="/2021/10/30/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%824/"/>
      <url>/2021/10/30/2021%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%824/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1635590333904_算法讲堂第四讲-枚举、递归、二分、贪心.pdf">点击下载课件</a></p><h1 id="枚举、递归、二分、贪心"><a href="#枚举、递归、二分、贪心" class="headerlink" title="枚举、递归、二分、贪心"></a>枚举、递归、二分、贪心</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><h3 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h3><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><h3 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h3><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年算法讲堂第三讲-C语言入门3</title>
      <link href="/2021/10/30/C-third/"/>
      <url>/2021/10/30/C-third/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1635588177493_函数与结构体.pdf">点击下载课件</a></p><h1 id="C语言入门3"><a href="#C语言入门3" class="headerlink" title="C语言入门3"></a>C语言入门3</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义及调用"><a href="#函数的定义及调用" class="headerlink" title="函数的定义及调用"></a>函数的定义及调用</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><h4 id="数值传递"><a href="#数值传递" class="headerlink" title="数值传递"></a>数值传递</h4><h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><h3 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h3><h4 id="默认参数值的函数"><a href="#默认参数值的函数" class="headerlink" title="默认参数值的函数"></a>默认参数值的函数</h4><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h3><h3 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h3><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年算法讲堂第一讲-C语言入门1</title>
      <link href="/2021/10/15/C-first/"/>
      <url>/2021/10/15/C-first/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1634299581801_数组与字符串.pdf">点击下载课件</a><br>课程大纲如下</p><h1 id="C语言入门1"><a href="#C语言入门1" class="headerlink" title="C语言入门1"></a>C语言入门1</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h2 id="二、the-“hello-world”-vision-of-C"><a href="#二、the-“hello-world”-vision-of-C" class="headerlink" title="二、the “hello world” vision of C++"></a>二、the “hello world” vision of C++</h2><h2 id="三、简单介绍一下C-程序结构"><a href="#三、简单介绍一下C-程序结构" class="headerlink" title="三、简单介绍一下C++程序结构"></a>三、简单介绍一下C++程序结构</h2><h2 id="四、变量类型"><a href="#四、变量类型" class="headerlink" title="四、变量类型"></a>四、变量类型</h2><h2 id="五、输出输出"><a href="#五、输出输出" class="headerlink" title="五、输出输出"></a>五、输出输出</h2><h2 id="六、运算符"><a href="#六、运算符" class="headerlink" title="六、运算符"></a>六、运算符</h2><h2 id="七、条件控制语句"><a href="#七、条件控制语句" class="headerlink" title="七、条件控制语句"></a>七、条件控制语句</h2><h2 id="八、循环控制语句"><a href="#八、循环控制语句" class="headerlink" title="八、循环控制语句"></a>八、循环控制语句</h2><h2 id="九、输入输出问题"><a href="#九、输入输出问题" class="headerlink" title="九、输入输出问题"></a>九、输入输出问题</h2><p>主讲人：张国辉</p><p>时间：9月25日</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年算法讲堂第二讲-C语言入门2</title>
      <link href="/2021/10/15/C-second/"/>
      <url>/2021/10/15/C-second/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cos.chdacm.cn/file/1634299581801_数组与字符串.pdf">点击下载课件</a><br>课程大纲如下</p><h1 id="C语言入门2"><a href="#C语言入门2" class="headerlink" title="C语言入门2"></a>C语言入门2</h1><h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><h2 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h2><h3 id="基本的字符串"><a href="#基本的字符串" class="headerlink" title="基本的字符串"></a>基本的字符串</h3><h3 id="巨好用的字符串string类"><a href="#巨好用的字符串string类" class="headerlink" title="巨好用的字符串string类"></a>巨好用的字符串string类</h3><p>主讲人：余锦鹏</p><p>时间：10月11日</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年趣味迎新题题解</title>
      <link href="/2021/09/15/2021%E5%B9%B4%E8%B6%A3%E5%91%B3%E8%BF%8E%E6%96%B0%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/09/15/2021%E5%B9%B4%E8%B6%A3%E5%91%B3%E8%BF%8E%E6%96%B0%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="1-幸运值"><a href="#1-幸运值" class="headerlink" title="1.幸运值"></a>1.幸运值</h4><p>对于$2^n$，最后一位数的规律是$2,4,8,6,2,4,8,6…$</p><p>答案是 $20*(n/4)+2^{n \%4+1 }-2$。</p><h4 id="2-彩虹岛的大操场"><a href="#2-彩虹岛的大操场" class="headerlink" title="2.彩虹岛的大操场"></a>2.彩虹岛的大操场</h4><p>从$(1,1)$跑到$(n, m)$总共需要跑$n+m-2$步，其中有$n-1$步向右跑，$m-1$步向上跑，那么只要从$n+m-2$步中选择$n-1$步就是全部的方法数了。</p><p>答案是$C^{n-1}_{n+m-2}$</p><h4 id="3-彩虹岛的神秘数字"><a href="#3-彩虹岛的神秘数字" class="headerlink" title="3.彩虹岛的神秘数字"></a>3.彩虹岛的神秘数字</h4><p>一、设神秘数字是$x$，$x$是$4$的整数倍，要把x分解成$2$个连续偶数的乘积，就是把$x/4$分解为$2$个连续自然数。</p><p>题目就变成了$11…1122…22$分解成两连续自然数的和，这个数字可以看成$2n$个$1$和$n$个$1$。</p><p>$11…11$，$n$个$1$乘9之后就可以看成$10^n-1$，那么原式就是$10^{2n}+10^{n}-2$，因式分解得到$(10^{n}+2) \ast (10^n-1)/9=\frac{10^n-1}{3}\ast \frac{10^n+2}{3}=(33…33)\ast(33…34)$再把得到的两个自然数都乘2得到答案。</p><p>答案的两个偶数分别是$n$个$6$、$n-1$个$6$和$1$个$8$</p><p>二、</p><p>$6*8=48$</p><p>$66*68=4488$</p><p>$666*668=444888$</p><p>$…$</p><p>$66…66*66…68=44…4488…88$</p><h4 id="4-写数字游戏"><a href="#4-写数字游戏" class="headerlink" title="4.写数字游戏"></a>4.写数字游戏</h4><p>n偶数先手必胜。n为偶数时，先手选择k=1，写下奇数，奇数的因子只能为奇数，所以后手只能选择一个奇数k，并写下偶数，最后后手能写的最大的数是m-2，此时先手写m-1获胜。</p><p>n为奇数先手必败。n为奇数，先手只能写下偶数，同上，后手必胜。</p><h4 id="5-彩虹岛的工资"><a href="#5-彩虹岛的工资" class="headerlink" title="5.彩虹岛的工资"></a>5.彩虹岛的工资</h4><p>一个$5$和一个偶数可以产生一个$0$，偶数比$5$的个数多，那么末尾$0$的个数只要计算$5$的个数即可</p><p>$5$的倍数可以提供一个$5$</p><p>$25$的倍数可以提供两个$5$，但$25$的倍数同样是$5$的倍数，所以$25$只能贡献一次答案</p><p>$125$的倍数可以提供三个$5$，但$125$的倍数同样是$5$和$25$的倍数，所以$125$只能贡献一次答案</p><p>所以答案是$\lfloor\frac{n}{5}\rfloor+\lfloor\frac{n}{25}\rfloor+\lfloor\frac{n}{125}\rfloor+….$（$\lfloor x\rfloor$是对x向下取整）</p><h4 id="6-寻找快乐数字"><a href="#6-寻找快乐数字" class="headerlink" title="6.寻找快乐数字"></a>6.寻找快乐数字</h4><p>可以先确定第n大的快乐数字有多少位。$1$位、$2$位$…k$位的快乐数字分别有$2$个、$2^2$个$…2^k$个</p><p>那么第$n$大的快乐数字就是在$k$位长度的第$n’$大的快乐数字，$n’$是$n-2-2^{2}-…-2^{k-1}$</p><p>然后把$1$看作$0$，把$4$看作$1$，就把问题变成了二进制装换的问题，把$n’$装换成二进制，在把二进制中的$01$进行替换就是答案。</p><h4 id="7-彩虹岛的”埃菲尔“铁塔"><a href="#7-彩虹岛的”埃菲尔“铁塔" class="headerlink" title="7.彩虹岛的”埃菲尔“铁塔"></a>7.彩虹岛的”埃菲尔“铁塔</h4><p>考虑计算面积</p><p>先计算第一层和第二层的节点构成三角形，面积是$\frac{d*h}{2}$</p><p>考虑之后每两层之间构成的面积，是一个梯形，面积就是上底加下底的和乘高除2。每两层之间的高度确定是h，只需要知道上底和下底。第二层的宽度<script type="math/tex">w_{2}=d</script>从第二层开始，第x层增加的宽度是<script type="math/tex">\frac{d}{2^{x-2}}</script>，那么第x层的宽度为<script type="math/tex">w_{x}=\sum_{i=2}^{x}{\frac{d}{2^{i-2}}} = d*(2-2^{2-x})</script>，第层x和第x+1层之间的面积就是<script type="math/tex">S_{x}=\frac{(w_{x}+w_{x+1})*h}{2}</script></p><p>答案是<script type="math/tex">S=\sum_{i=1}^{k-1}S_{i}=\frac{h*d}{2}*\sum_{i=1}^{k-1}(4-3*2^{1-i})=\frac{h*d}{2}*(4*k+\frac{3}{2^{k-2}}-10)</script></p><h4 id="8-排排队"><a href="#8-排排队" class="headerlink" title="8.排排队"></a>8.排排队</h4><p>$a[n]$表示n个小球排队的方法数，易得$a[1]=1,a[2]=2,a[3]=4$</p><p>当n大于3时，考虑最后一个小球是蓝球或者红球的情况，由于红球不能单个出现，因此小球出现的情况有：</p><ul><li>最后1个小球是蓝球</li><li>最后2个小球是红球</li><li>最后3个以上的小球是红球</li></ul><p><strong>最后1个小球是蓝球</strong>的情况，对前$n-1$个小球没有要求，只要排前$n-1$个小球，这时有$a[n-1]$种排法。</p><p><strong>最后2个小球是红球</strong>的情况，那么最后$3$个小球只能是”蓝 红 红“，对于前$n-$3个小球没有任何要求，只要排前$n-3$个小球，这时有$a[n-3]$种排法。</p><p><strong>最后3个以上的小球是红球</strong>的情况，考虑最后1个小球是红球，只要考虑前$n-1$个小球的排列情况。前$n-1$个小球的排列情况有：最后1个小球是蓝球；最后2个以上的小球是红球。两种情况，最后1个小球是蓝球的情况明显不符合答案；最后有2个以上的小球是红球的情况符合，n个球排列后最后是3个以上小球是红球的情况。所以<strong>最后3个以上的小球是红球</strong>情况的方法数就是$n-1$的小球排列的方法数，再排除掉$n-1$个小球排列最后1个小球是蓝球的方法数，即$a[n-1]-a[n-2]$。（$n-1$个小球排列最后1个小球是蓝球的方法数可以参考上面讨论的第一种情况）</p><p>综合上面三种情况，可以得到递推公式$a[n]=2*a[n-1]-a[n-2]+a[n-3]$</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 迎新 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年趣味迎新题</title>
      <link href="/2021/09/15/2021%E5%B9%B4%E8%B6%A3%E5%91%B3%E8%BF%8E%E6%96%B0%E9%A2%98/"/>
      <url>/2021/09/15/2021%E5%B9%B4%E8%B6%A3%E5%91%B3%E8%BF%8E%E6%96%B0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>趣味萌新题不用做任何选拔，仅用做带领大家了解一下算法竞赛中的一些思维。</p><p>很多题目可以手算，有些题目甚至可以口算。</p><p>题目在阅读过程中如果遇到理解障碍，可以来帐篷点或在qq群（1149886530）中问询。</p><h3 id="1-幸运值"><a href="#1-幸运值" class="headerlink" title="[1]幸运值"></a>[1]幸运值</h3><p>彩虹岛的糊糊非常喜欢每一个数字的最后一位，他认为这一位就是这个数字的幸运值，比如 1234 的幸运值是4，现在zgh给了糊糊 n 个数，分别是$2^{1}、2^{2}、2^{3}…2^{n}$，糊糊想要知道这 n 个数的幸运值之和是多少，但是他有点笨，你能帮帮他吗？</p><h4 id="example"><a href="#example" class="headerlink" title="[example]"></a>[example]</h4><p>当n=3时，3个数分别是2、4、8，他们的幸运值的和是14。</p><h3 id="2-彩虹岛的大操场"><a href="#2-彩虹岛的大操场" class="headerlink" title="[2]彩虹岛的大操场"></a>[2]彩虹岛的大操场</h3><p>彩虹岛上有一个n*m的矩形大操场，这个操场很奇怪，这里面跑步的人只能向右或者向上跑，ty热衷跑步，天天在这个操场里面跑步，有一天wx问ty，你天天跑步，知道从这个操场左下角（1，1）跑到这个操场右上角（n，m）有多少种跑法吗？ty想了很久没有想出答案，他决定亲自去跑，wx觉得ty的方法太慢了，决定问你，你可以帮他计算一下这个问题吗？</p><h4 id="example-1"><a href="#example-1" class="headerlink" title="[example]"></a>[example]</h4><p>当n=2，m=2时，可以先向右再向上，或者先向上再向右，一共有两条这样的路线。</p><h3 id="3-彩虹岛的神秘数字"><a href="#3-彩虹岛的神秘数字" class="headerlink" title="[3]彩虹岛的神秘数字"></a>[3]彩虹岛的神秘数字</h3><p>有一天lxh在彩虹岛的发现了一个神秘的数字44…4488…88,其中4和8各有n个。lxh研究了很久没有发现这个数字的秘密，zgh看了一眼，说这个数字没什么特别的秘密，只是可以表示成两个连续偶数的乘积，然后zgh就离开了，lxh找了半天也没有找到是哪两个偶数，你可以帮帮他吗？</p><h4 id="example-2"><a href="#example-2" class="headerlink" title="[example]"></a>[example]</h4><p>当n为1时，神秘数字是48，可以分解成两个连续的偶数6*8。</p><h3 id="4-写数字游戏"><a href="#4-写数字游戏" class="headerlink" title="[4]写数字游戏"></a>[4]写数字游戏</h3><p>xq和ljd在玩写数字的游戏，刚开始纸上有一个数字n，并且定下了另外一个数字m（其中m&gt;n，且m为偶数），他们两个人轮流选择纸上数字的一个因子k，将n+k替换掉n写在纸上，谁写的数先大于等于m谁就输，xq先手，他们两个人都非常聪明。他们两个谁会赢呢？（本题只能提交一次答案）</p><h4 id="example-3"><a href="#example-3" class="headerlink" title="[example]"></a>[example]</h4><p>当n=2，m=4时，xq先选择1，在纸上写下了3，ljd再写的数一定会大于等于4，xq赢。</p><h3 id="5-彩虹岛的工资"><a href="#5-彩虹岛的工资" class="headerlink" title="[5]彩虹岛的工资"></a>[5]彩虹岛的工资</h3><p>众所周知，yjp的工资非常高，他的工资是他工作天数的阶乘，最后退休时一起结算，比如工作一天他可以拿到1的摩拉，工作两天他可以拿到2的摩拉，工作了n天他可以拿到n！的摩拉。现在yjp已经工作了n天并打算养老退休了，yjp知道他将拿到非常多的摩拉，但是他只想知道末尾有几个0，你能帮帮他吗？</p><h4 id="example-4"><a href="#example-4" class="headerlink" title="[example]"></a>[example]</h4><p>当n=5时，n!是120，末尾有1个0。</p><h3 id="6-寻找快乐数字"><a href="#6-寻找快乐数字" class="headerlink" title="[6]寻找快乐数字"></a>[6]寻找快乐数字</h3><p>彩虹岛上数字1，4是快乐数字，其他的数字都不是。一个数如果只包含快乐数字，那么它是快乐的。xh最近不知道为什么很难过，hyd告诉xh只要找到第n的快乐数，就可以快乐起来，所以xh去寻找快乐数。你可以帮帮xh找到第n个快乐数吗？</p><h4 id="example-5"><a href="#example-5" class="headerlink" title="[example]"></a>[example]</h4><p>比如1，4，11，14都是快乐数。第2个快乐数字就是4。</p><h3 id="7-彩虹岛的“埃菲尔”宝塔"><a href="#7-彩虹岛的“埃菲尔”宝塔" class="headerlink" title="[7]彩虹岛的“埃菲尔”宝塔"></a>[7]彩虹岛的“埃菲尔”宝塔</h3><p>彩虹岛有一个非常著名的建筑——“埃菲尔”宝塔，这个宝塔它由若干个玄铁石连接而成，总共有k层，每一层之间的高度都是h。最高层有一颗玄铁石，第二层有两颗玄铁石，这三颗玄铁石构成一个三角形，这个三角形的底为d。每一层的玄铁石都会吸引另外两颗下一层的玄铁石，每一层的相邻两颗玄铁石之间的距离相等，并且每颗玄铁石吸引的下一层两颗玄铁石严格在这颗玄铁石的左右两侧（如图中B和C在A的左右两侧）。请你求出该“宝塔”的总面积。（如果带小数，保留三位小数即可）</p><h4 id="example-6"><a href="#example-6" class="headerlink" title="[example]"></a>[example]</h4><p>当k=3，h=2，d=4时，宝塔的面积就是ABDGCA的面积，总面积是14。</p><h3 id="8-排排队"><a href="#8-排排队" class="headerlink" title="[8]排排队"></a>[8]排排队</h3><p>zzy特别喜欢给小球排队，现在一堆小球，其中有红色和蓝色两种小球，每种颜色的小球都是相同的，且每种颜色的小球都足够多。zzy想把n个小球排成一行，使任意一个红色小球都至少与另一个红色小球相邻。zzy想知道有多少种排列方法，但是他正在给小球排队，没有时间计算，所以他想请你计算一下。答案非常大，所以你需要让答案对1000000007取模。</p><h4 id="example-7"><a href="#example-7" class="headerlink" title="[example]"></a>[example]</h4><p>当n=3时，有“红红红”、“红红蓝”、“蓝红红”、“蓝蓝蓝”这四种排列方法，所以答案为“4”。</p><p>注意：由于“蓝蓝蓝”中没有红球，所以“蓝蓝蓝”也是一种正确的排列方法。</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 迎新 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>直播讲课安排</title>
      <link href="/2021/08/20/%E7%9B%B4%E6%92%AD%E8%AE%B2%E8%AF%BE%E5%AE%89%E6%8E%92/"/>
      <url>/2021/08/20/%E7%9B%B4%E6%92%AD%E8%AE%B2%E8%AF%BE%E5%AE%89%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h1 id="长安大学ACM集训队"><a href="#长安大学ACM集训队" class="headerlink" title="长安大学ACM集训队"></a>长安大学ACM集训队</h1><p>为了让大家更快更早接触算法竞赛学习，集训队组织在 8.21-8.27 一周时间通过直播课形式带大家一起学习<a href="oj.chdacm.cn">C语言</a>的基础语法以及简单应用，欢迎大家积极参与！</p><p>直播形式 :直播采取b站直播（<strong><a href="https://space.bilibili.com/1674174622?from=search&amp;seid=2114815788533174224">CHD-ACM</a></strong>   UID：1674174622）的形式，课程安排和通知会在ACM新生群通知，课后问题也可以在群里交流（群号：<strong>1149886530</strong>），学姐二十四小时在线答疑。</p><p>直播时间 :19：00 - 21：00 </p><p>直播内容 :采取算法和程序配套讲法，每个小节选取一道例题精解（学姐现场敲代码实现程序，逐语句讲解），然后选取1至3道例题，现场完成，提交至 <a href="oj.chdacm.cn">CHDOJ</a> 在线测评，直播对例题代码讲解，直播结束后，会提供相应的配套习题，供大家练习使用。</p><p>预期效果:全部直播课程讲授结束，训练认真完成，轻松应对开学C语言课内内容，为开学打好基础~</p><div class="table-container"><table><thead><tr><th style="text-align:left">直播内容</th><th style="text-align:left">直播时间</th><th>主讲人</th></tr></thead><tbody><tr><td style="text-align:left">【C语言】环境配置、学习干货传授、数据类型，输入输出，运算符、<strong>彩蛋隐藏环节</strong></td><td style="text-align:left"><code>8.21 19：00-21：00</code></td><td>糊糊</td></tr><tr><td style="text-align:left">【C语言】顺序和分支结构</td><td style="text-align:left"><code>8.22 19：00-21：00</code></td><td>陈申奥</td></tr><tr><td style="text-align:left">【C语言】循环和嵌套</td><td style="text-align:left"><code>8.23 19：00-21：00</code></td><td>夏强</td></tr><tr><td style="text-align:left">【C语言】数组</td><td style="text-align:left"><code>8.24 19：00-21：00</code></td><td>余锦鹏</td></tr><tr><td style="text-align:left">【C语言】函数</td><td style="text-align:left"><code>8.25 19：00-21：00</code></td><td>孙如祥</td></tr><tr><td style="text-align:left">【C语言】结构体，指针</td><td style="text-align:left"><code>8.26 19：00-21：00</code></td><td>周赛</td></tr><tr><td style="text-align:left">【算  法】算法思想导引（常见入门算法、时间复杂度分析）</td><td style="text-align:left"><code>8.27 19：00-21：00</code></td><td>凡尔赛-雨</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组&amp;线段树入门</title>
      <link href="/2021/08/04/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2021/08/04/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组-amp-线段树入门"><a href="#树状数组-amp-线段树入门" class="headerlink" title="树状数组&amp;线段树入门"></a>树状数组&amp;线段树入门</h1><h2 id="预置知识"><a href="#预置知识" class="headerlink" title="预置知识"></a><a href="https://blog.51cto.com/u_9291927/2083190">预置知识</a></h2><p>引入:</p><blockquote><p>现给你一个长度为 $n$ 的数列 $A$，再输入 $q$ 个询问，每个询问都给出两个整数l，r。对于每个询问都要求给出对于数列 $A$ 在区间 $[l,r]$上的和（假设下标从0开始）</p><p>很容易想到能够使用前缀和 $pre[i]$ 来维护，每次询问直接输出 $pre[r]-pre[l-1]$ 即可，这个问题就愉快地解决了。 </p><p>但是问题又来了，如果是 $q$ 个操作，这些操作中既有查询又有修改 (每次修改指定位置的值) 呢？这时候单纯用前缀和复杂度就会很高，因为每一次修改都会影响前缀和，对于每次修改都得重新计算一遍前缀和数组，那如何处理这个问题呢？</p></blockquote><h2 id="一、树状数组"><a href="#一、树状数组" class="headerlink" title="一、树状数组"></a>一、树状数组</h2><p style="font-family:arial;color:green;font-size:16px;">树状数组是一种利用二进制特征进行检索的树状结构。</p><ul><li><p><strong>初识树状数组</strong></p><p>  就【引入】中的问题来初始树状数组，我们把它形式化一下</p><p>  长度为 $n$ 的数组 $a_i(i=1 \dots n)$ ，进行以下操作：</p><ol><li>修改元素 $add(k,x):$ 把 $a_k$ 加上 $x$。</li><li><p>询问区间 $[l,r]$ 的和。我们可以用树状数组求和 $sum(x)： ~sum=a_1+a_2+ \dots +a_x$。那么所求即是 $sum(r)-sum(l-1)$</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">        tree[x]+=d;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=tree[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="color:blue;">注: add() 和 sum() 的复杂度都是 O(logn)</p><p><strong>使用方法：（重点）</strong></p></li><li><p>初始化。先清空 $tree$​ 数组，然后读取 $a_1,a_2, \dots ,a_n$​ ，用 $add(i,a_i)$ 逐一处理，得到一开始的 $tree$ 数组；实际上并不需要 $a$ 数组，因为它隐含在了 $tree$​ 数组中。</p></li><li>求区间和，输出 $sum(r)-sum(l-1)$</li><li>修改，执行 $add(i,d)$​。</li></ol></li><li><p>原理（简单介绍一下）</p><p>  问：为什么任何一个正整数（10进制）都可以唯一表示成用2的整数次幂相加？</p><p>  答：世界上只有 $10$ 种人，一种人懂二进制，一种人不懂二进制。</p>  <p class="p blue">树状数组采用的就是这个原理</p><p>  因为任意一个十进制数都可以转换成 $2$ 进制，那么二进制转换成 $10$ 进制的过程就是任何一个正整数表示成2的整数次幂和的过程。</p><p>  <img src="https://cos.chdacm.cn/imgs/1628051213813%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="img"></p>  <p style="color:blue;size=" 12"> lowbit(x) 原理</p><blockquote><p>$lowbit(x)$​ 返回 $x$​ 二进制形式的最后一个 $1$​ 的位置对应的幂级数。假设 $x=12=00001100_2$​​, $lowbit(x)=4=2^2$​</p><p>$x=00001100, -x=x_补=11110100$​</p><p>最后一个 $1$​ 前面进行 &amp; 操作后，全是 $0$​ ，最后一个 $1$​ 后面进行 &amp; 操作后也全是 $0$​ 只剩下那一个 $1$ 。 </p></blockquote>  <p style="color:blue;size=" 12"> 主要原理</p><p>  假如要求  $sum(12):$​ $sum(12)=sum(8)+sum(4)$ ；就相当于 $sum(12)-lowbit(12)=8, sum(8)-lowbit(8)=0$</p><p>  假如要更新 $12$​​ 这个点 ：$12+lowbit(12)=16, 16+lowbit(16)=32, 64, 128…$​​直到大于 $n$​​​，我的理解就是找到离他最近的那个 $2^k$​​，就是上图中的 ①，②，④，⑧ $\dots$​​​ 结点中，这样查询的过程中就可以把加到这个点的值累积到答案中了；不会重复，你自己模拟一下（查询过程中不会重复）。</p><p>  蓝书上说的更专业一点：$tree[x]$ 数组保存的是序列 $a$ 的区间 $[x-lowbit(x)+1,x]$ 这个区间中所有数的和，即 $\sum_{i=lowbit(x)+1}^{x}a[i]$</p><p>  该结构满足以下性质：(结合上图来看)</p><ol><li>每个内部结点 $c[x]$ 保存以它为根的子树中所有叶子节点的和。</li><li>每个内部结点 $c[x]$ 的子节点个数等于 $lowbit(x)$ 的位数。</li><li>除树根外，每个内部节点 $c[x]$ 的父节点是 $c[x+lowbit(x)]$。</li></ol></li></ul><h2 id="二、线段树"><a href="#二、线段树" class="headerlink" title="二、线段树"></a>二、线段树</h2><p>线段树是建立在区间基础上的树，树的每个结点代表一条线段 <code>[l,r]</code></p><p><img src="https://cos.chdacm.cn/imgs/1628051373262%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="img"></p><p>考查每个线段 $[l,r]$ ，$l$ 是左结点 ；$r$ 是右结点；</p><ol><li>$L=R$​ 说明这个结点代表的区间只有一个点，它就是一个子结点。</li><li>$L&lt;R$ 说明这个结点代表的不止一个点，他有两个儿子，左儿子代表的区间是 $[L,M]$，右儿子代表的区间是 $[M+1,R]$，其中 $M=(L+R)/2$。</li></ol><p>线段树是二叉树，一个区间每次被折一半往下分，最多分 $log_2n$​​ 次到达最底层；当需要查找一个点或者区间的时候，顺着结点往下找，最多 $log_2n$​​​ 次就能找到。</p><ul><li>乘 $4$​​​ 原理  （下图不理解，周六给你们讲一下晖-辉定理🐕）</li></ul><p><img src="https://cos.chdacm.cn/imgs/1628051431699%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A9%BA%E9%97%B4%E4%B9%984.jpg" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> sum[MAXN*<span class="number">4</span>],L[MAXN*<span class="number">4</span>],R[MAXN*<span class="number">4</span>],MIN[MAXN*<span class="number">4</span>],MAX[MAXN*<span class="number">4</span>];<span class="comment">//sum数组保存和，L区间左结点，R区间右结点，MIN区间最小值，MAX区间最大值。</span></span><br><span class="line"><span class="comment">//或者开一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,max,m</span><br><span class="line">        in,lr;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXM];</span><br></pre></td></tr></table></figure><h3 id="利用满二叉树建树"><a href="#利用满二叉树建树" class="headerlink" title="利用满二叉树建树"></a>利用满二叉树建树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L[rt]=l,R[rt]=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum[rt]=a[l];MIN[rt]=a[l];MAX[rt]=a[l];<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    MIN[rt]=<span class="built_in">min</span>(MIN[rt&lt;&lt;<span class="number">1</span>],MIN[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    MAX[rt]=<span class="built_in">max</span>(MAX[rt&lt;&lt;<span class="number">1</span>],MAX[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L[rt]==R[rt])&#123;</span><br><span class="line">        sum[rt]=v;MIN[rt]=v;MAX[rt]=v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(L[rt]+R[rt])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(x,v,rt&lt;&lt;<span class="number">1</span>);<span class="comment">//x属于左半区间</span></span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(x,v,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);<span class="comment">//x属于右半区间</span></span><br><span class="line">    <span class="comment">//先递归儿子，再更新自己的东西。</span></span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    MIN[rt]=<span class="built_in">min</span>(MIN[rt&lt;&lt;<span class="number">1</span>],MIN[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    MAX[rt]=<span class="built_in">max</span>(MAX[rt&lt;&lt;<span class="number">1</span>],MAX[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//【l，r】是要查询的区间。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//rt这个结点区间全部包含在要查询的区间中。</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=L[rt]&amp;&amp;r&gt;=R[rt])&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(L[rt]+R[rt])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(l,r,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(l,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=L[rt]&amp;&amp;r&gt;=R[rt])&#123;</span><br><span class="line">        <span class="keyword">return</span> MIN[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> mid=(L[rt]+R[rt])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) minn=<span class="built_in">min</span>(minn,<span class="built_in">ask</span>(l,r,rt&lt;&lt;<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">if</span>(r&gt;mid) minn=<span class="built_in">min</span>(minn,<span class="built_in">ask</span>(l,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=L[rt]&amp;&amp;r&gt;=R[rt])&#123;</span><br><span class="line">        <span class="keyword">return</span> MAX[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxx=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> mid=(L[rt]+R[rt])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) maxx=<span class="built_in">max</span>(maxx,<span class="built_in">ask</span>(l,r,rt&lt;&lt;<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">if</span>(r&gt;mid) maxx=<span class="built_in">max</span>(maxx,<span class="built_in">ask</span>(l,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里其实已经实现和树状数组完全一样的功能了，虽然常数比树状数组大，而且代码复杂度也 <s>还可以</s>。<br>那线段树存在的意义在那里呢？没错，它可以区间修改，还可以各种神奇操作</p></blockquote><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>如果只是采用单点修改的话，时间复杂度非但没有减小，然而还会增加 $log_2n$ 的复杂度，变成 $nlog_2n$ 。</p><p>线段树牛逼就牛逼到这个地方——它采用一种 $lazy-tag$ 方法。</p><h4 id="lazy-tag"><a href="#lazy-tag" class="headerlink" title="lazy-tag"></a>lazy-tag</h4><p>这个方法叫做 “ 懒标记 ” 。当修改的是一个整块区间的时候，只对这个线段区间进行整体上的修改，其内部每个元素的内容先不做修改，只有当这部分线段的一致性被破坏的时候才把变化值传递给子区间。那么，每次区间修改的复杂度是 $log_2n$​ 。做 $lazy$​ 操作的子区间需要记录状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> add[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(add[rt])&#123;</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>]+=add[rt];<span class="comment">//把懒惰标记传给左儿子</span></span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=add[rt];<span class="comment">//传给右儿子</span></span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]+=(m-(m&gt;&gt;<span class="number">1</span>))*add[rt];<span class="comment">//更新左儿子和右儿子的东西</span></span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=(m&gt;&gt;<span class="number">1</span>)*add[rt];</span><br><span class="line">        add[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//给 [a,b] 区间加上 c ,[l,r]是rt结点代表的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=l&amp;&amp;b&gt;=r)&#123;</span><br><span class="line">    sum[rt]+=(r-l<span class="number">+1</span>)*c;</span><br><span class="line">        add[rt]+=c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(rt,r-l<span class="number">+1</span>);<span class="comment">//下传懒惰标记</span></span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//把[a,b]区间分开计算。</span></span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid) <span class="built_in">update</span>(a,b,c,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;mid) <span class="built_in">update</span>(a,b,c,mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=l&amp;&amp;b&gt;=r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="built_in">push_down</span>(rt,r-l<span class="number">+1</span>);<span class="comment">//这里需要往下传懒惰标记</span></span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid) ans+=<span class="built_in">query</span>(a,b,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;mid) ans+=<span class="built_in">query</span>(a,b,mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">好了，我们来看一道例题吧</p><blockquote><p>POJ 3468 “A Simple Problem with Integers”</p><p>给出 $N$ 个数，进行 $Q$ 个操作，$1 \leq N,Q \leq1e5 $.</p><p>有如下两种操作：</p><p>“C a b c”，对区间 $[a,b]$ 的每个数字加 c。</p><p>”Q a b”，查询区间 $[a,b]$ 数字和。</p><p>对每个查询操作，输出结果。</p></blockquote><p><del>蒟蒻的代码</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll sum[MAXN&lt;&lt;<span class="number">2</span>],add[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(add[rt])&#123;</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>]+=add[rt];</span><br><span class="line">        add[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=add[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>]+=(m-(m&gt;&gt;<span class="number">1</span>))*add[rt];</span><br><span class="line">        sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=(m&gt;&gt;<span class="number">1</span>)*add[rt];</span><br><span class="line">        add[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,ll c,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=l&amp;&amp;b&gt;=r)&#123;</span><br><span class="line">        sum[rt]+=(r-l<span class="number">+1</span>)*c;</span><br><span class="line">        add[rt]+=c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_down</span>(rt,r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid) <span class="built_in">update</span>(a,b,c,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;mid) <span class="built_in">update</span>(a,b,c,mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=l&amp;&amp;b&gt;=r) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="built_in">push_down</span>(rt,r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;=mid) ans+=<span class="built_in">query</span>(a,b,l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b&gt;mid) ans+=<span class="built_in">query</span>(a,b,mid<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;<span class="type">long</span> <span class="type">long</span> c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="built_in">update</span>(a,b,c,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(a,b,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">到这里，你已经入门了，快去刷题和继续学习各种和线段树相关的高级数据结构吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown扩展应用Mathjax</title>
      <link href="/2021/07/31/markdown_Mathjax/"/>
      <url>/2021/07/31/markdown_Mathjax/</url>
      
        <content type="html"><![CDATA[<div class="note primary simple"><p>Markdown 系列有三部分构成：</p><ol><li><a href="/2021/07/31/markdown/">Markdown的基本语法</a></li><li><a href="/2021/07/31/markdown_extension/">Mardkwon的扩展语法</a></li><li><a href="/2021/07/31/markdown_Mathjax/">Markdown的扩展应用-Mathjax</a></li></ol></div><h3 id="Mathjax-数学公式"><a href="#Mathjax-数学公式" class="headerlink" title="Mathjax 数学公式"></a>Mathjax 数学公式</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>displayed 公式： 分隔符<code>$$ ... $$</code>  或者 <code>\[...\]</code> </li><li>inline 公式 <script type="math/tex">...</script> 或者 <code>(...)</code> </li></ul><h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大写</th><th style="text-align:center">Tex</th><th style="text-align:center">小写</th><th style="text-align:center">Tex</th></tr></thead><tbody><tr><td style="text-align:center">alpha</td><td style="text-align:center">$A$</td><td style="text-align:center">A</td><td style="text-align:center">$\alpha$</td><td style="text-align:center">\alpha</td></tr><tr><td style="text-align:center">beta</td><td style="text-align:center">$B$</td><td style="text-align:center">B</td><td style="text-align:center">$\beta$</td><td style="text-align:center">\beta</td></tr><tr><td style="text-align:center">gamma</td><td style="text-align:center">$\Gamma$</td><td style="text-align:center">\Gamma</td><td style="text-align:center">$\gamma$</td><td style="text-align:center">\gammma</td></tr><tr><td style="text-align:center">delta</td><td style="text-align:center">$\Delta$</td><td style="text-align:center">\Delta</td><td style="text-align:center">$\delta$</td><td style="text-align:center">\delta</td></tr><tr><td style="text-align:center">epslion</td><td style="text-align:center">$E$</td><td style="text-align:center">E</td><td style="text-align:center">$\epsilon$</td><td style="text-align:center">\epsilon</td></tr><tr><td style="text-align:center">zeta</td><td style="text-align:center">$Z$</td><td style="text-align:center">Z</td><td style="text-align:center">$\zeta$</td><td style="text-align:center">zeta</td></tr><tr><td style="text-align:center">eta</td><td style="text-align:center">$H$</td><td style="text-align:center">H</td><td style="text-align:center">$\eta$</td><td style="text-align:center">\eta</td></tr><tr><td style="text-align:center">theta</td><td style="text-align:center">$\Theta$</td><td style="text-align:center">\Theta</td><td style="text-align:center">$\theta$</td><td style="text-align:center">\theta</td></tr><tr><td style="text-align:center">iota</td><td style="text-align:center">$I$</td><td style="text-align:center">I</td><td style="text-align:center">$\iota$</td><td style="text-align:center">\itoa</td></tr><tr><td style="text-align:center">kappa</td><td style="text-align:center">$K$</td><td style="text-align:center">K</td><td style="text-align:center">$\kappa$</td><td style="text-align:center">\kappa</td></tr><tr><td style="text-align:center">lambda</td><td style="text-align:center">$\Lambda$</td><td style="text-align:center">\Lambda</td><td style="text-align:center">$\lambda$</td><td style="text-align:center">\lambda</td></tr><tr><td style="text-align:center">mu</td><td style="text-align:center">$M$</td><td style="text-align:center">M</td><td style="text-align:center">$\mu$</td><td style="text-align:center">\mu</td></tr><tr><td style="text-align:center">nu</td><td style="text-align:center">$N$</td><td style="text-align:center">N</td><td style="text-align:center">$\nu$</td><td style="text-align:center">\nu</td></tr><tr><td style="text-align:center">xi</td><td style="text-align:center">$\Xi$</td><td style="text-align:center">\Xi</td><td style="text-align:center">$\xi$</td><td style="text-align:center">\xi</td></tr><tr><td style="text-align:center">omicron</td><td style="text-align:center">$O$</td><td style="text-align:center">O</td><td style="text-align:center">$\omicron$</td><td style="text-align:center">\omicron</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">$\Pi$</td><td style="text-align:center">\Pi</td><td style="text-align:center">$\pi$</td><td style="text-align:center">\pi</td></tr><tr><td style="text-align:center">rho</td><td style="text-align:center">$P$</td><td style="text-align:center">P</td><td style="text-align:center">$\rho$</td><td style="text-align:center">\rho</td></tr><tr><td style="text-align:center">sigma</td><td style="text-align:center">$\Sigma$</td><td style="text-align:center">\Sigma</td><td style="text-align:center">$\sigma$</td><td style="text-align:center">\sigma</td></tr><tr><td style="text-align:center">tau</td><td style="text-align:center">$T$</td><td style="text-align:center">T</td><td style="text-align:center">$\tau$</td><td style="text-align:center">\tau</td></tr><tr><td style="text-align:center">upsilon</td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center">\Upsilon</td><td style="text-align:center">$\upsilon$</td><td style="text-align:center">\upsilon</td></tr><tr><td style="text-align:center">psi</td><td style="text-align:center">$\Psi$</td><td style="text-align:center">\Psi</td><td style="text-align:center">$\psi$</td><td style="text-align:center">\psi</td></tr><tr><td style="text-align:center">omega</td><td style="text-align:center">$\Omega$</td><td style="text-align:center">\Omega</td><td style="text-align:center">$\omega$</td><td style="text-align:center">\omega</td></tr></tbody></table></div><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><ul><li>上标：^ 例如 <code>x_i^2</code> : $x_i^2$ </li><li>下标：_ 例如 <code>x_j</code> $x_j$ </li></ul><p>注意： 一个组即单个字符或者使用{…}包裹起来的内容。他可以消除二义性</p><p>例如：<code>10^10</code>会得到 $10^10$     </p><p>​        <code>10^&#123;10&#125;</code> 会得到 $10^{10}$ </p><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><ul><li>小括号和方括号：() []  $()$  $[]$ </li><li>大括号：<code>\&#125;  \&#123;</code>   或者  <code>\lbrace</code>   <code>\rbrace</code>  <ul><li>例如：<code>\&#123;a*b\&#125;</code> ${a*b}$    </li></ul></li><li>尖括号： <code>\langle</code> 和 <code>\rangle</code>   ：$\langle x\rangle$</li><li>上取整：<code>\lceil</code>和<code>\rceil</code> ：$\lceil x\rceil$</li><li>下取整：<code>\lfloor</code> 和 <code>\rfloor</code> ：$\lfloor x \rfloor$</li><li>不可见括号，用 . 表示</li></ul><p>注意：原始符号不会随着公式大小缩放，可以使用\left(…\right)来自适应地调整括号大小。</p><h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><ul><li>\sum 用来表示求和符号，其下标表示求和下限，上标表示上限。<ul><li><code>\sum_1^n</code>    $\sum_1^n$</li></ul></li><li>\int 用来表示积分符号<ul><li><code>\int_1^\infty</code> :   $\int_1^\infty$ </li></ul></li><li><code>\prod</code> ：$\prod$ </li><li><code>\bigcup</code> : $\bigcup$ </li><li><code>\bigcap</code> ：$\bigcup$</li><li><code>\iint</code> : $\iint$</li></ul><h4 id="分式和根式"><a href="#分式和根式" class="headerlink" title="分式和根式"></a>分式和根式</h4><ul><li><code>\frac ab</code>   ： $\frac ab$   (如果分子分母不是单个字符，使用{…}分组)</li><li><code>\over</code> ：<code>&#123;a+1\over b+1&#125;</code>: ${a+1\over b+1}$</li><li><code>\sqrt</code> :   <code>\sqrt&#123;\frac ab&#125;</code> :  $\sqrt{\frac ab}$   <code>\sqrt[4]&#123;a \over b&#125;$</code> : $\sqrt[4]{a \over b}$</li></ul><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><ul><li>\mathbb 或 \Bbb 显示黑板粗体字，此字体经常用来表示实数，整数，有理数和负数：$\mathbb {CHNQRZ}$</li><li>\mathbf 显示黑体字：$\mathbf  {BCDEFG}$</li><li>\mathtt 显示打印机字体：$\mathtt  {BCDEFG}$</li><li>\mathrm 显示罗马体 : $\mathrm {ABCD}$</li><li>\mathscr 显示手写体 : $\mathscr {ABCD}$</li><li>\mathfrak 显示Fraktur字母（一种德国字体）：$\mathfrak{ABCD}$</li></ul><h4 id="特殊函数和符号"><a href="#特殊函数和符号" class="headerlink" title="特殊函数和符号"></a>特殊函数和符号</h4><ul><li>常见三角函数 $sin(x)$  $arctan(x)$   $\lim_{1\rightarrow\infty}$</li><li>比较运算符 : \lt \gt \le \ge \neq : $\lt$  $\gt$  $\le$  $\ge$  $\neq$   。可以加上\not： $\not\lt$ </li><li>\times  \div \pm \mp : $\times$   $\div$  $\pm$  $\mp$ </li><li>\cdot 表示居中的点 : x \codt y : $x \cdot y$</li><li>集合关系与运算：<ul><li>\cup $\cup$</li><li>\cap $\cap$</li><li>\setminus $\setminus$</li><li>\subset $\subset$</li><li>\subseteq $\subseteq$</li><li>\subsetneq $\subsetneq$</li><li>\supset $\supset$</li><li>\in $\in$</li><li>\notin $\notin$</li><li>\emptyset $\emptyset$</li><li>\varnothing  $\varnothing$</li></ul></li><li>表示排列使用 \binom  {n+1}{2k}或{n+1\choose 2k}<ul><li>$\binom {n+1}{2k}$   $ {n+1\choose 2k}$ </li></ul></li><li>箭头：\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto<ul><li>$\to$ $\rightarrow$ $\leftarrow$ $\Rightarrow$ $\Leftarrow$ $\mapsto$</li></ul></li><li>逻辑运算符：\land \lor \lnot \forall \exists \top \bot \vdash \vDash<ul><li>$\land$  $\lor$ $\lnot$    $\forall$    $\exists$  </li></ul></li><li>\star \ast \oplus \circ \bullet <ul><li>$\star$ $\ast$ $\oplus$ $\circ$ $\bullet$ </li></ul></li><li>\approx $\approx$   \sim $\sim$  \cong $\cong$  \equiv $\equiv$  \prec $\prec$ </li><li>\infty $\infty$ \aleph_o $\aleph_o$ \navla $\nabla$  \Im $\Im$  \Re $\Re$ </li><li>\pmode   $a\equiv b \pmod n$</li><li>\ldots  \cdots  ldots 的位置稍低，cdots位置居中<ul><li>$a_1 + a_2 +\cdots +a_n$   </li><li>$a_1,a_2,\ldots,a_n$</li></ul></li></ul><h4 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h4><p><code>a \ b</code> ：$a \ b$ </p><p><code>a \; b</code> :  $a \; b$</p><p><code>a\quad b</code> ：$a\quad b$</p><p><code>a\qquad b</code> :  $a\qquad b$</p><h4 id="顶部符号"><a href="#顶部符号" class="headerlink" title="顶部符号"></a>顶部符号</h4><p>加波浪线 输入 \widetilde   \sim</p><p>加一个点 \dot{要加点的字母}加两个点\ddot{要加点的字母}</p><h4 id="声调-变音符号"><a href="#声调-变音符号" class="headerlink" title="声调/变音符号"></a>声调/变音符号</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;a&#125; <span class="keyword">\ddot</span>&#123;a&#125; <span class="keyword">\acute</span>&#123;a&#125; <span class="keyword">\grave</span>&#123;a&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p> $\dot{a} \quad \ddot{a} \quad\acute{a}\quad \grave{a}$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\check</span>&#123;a&#125; <span class="keyword">\breve</span>&#123;a&#125; <span class="keyword">\tilde</span>&#123;a&#125; <span class="keyword">\bar</span>&#123;a&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p> $\check{a} \quad \breve{a} \quad \tilde{a} \quad \bar{a}$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\widehat</span>&#123;a&#125; <span class="keyword">\vec</span>&#123;a&#125; <span class="keyword">\overline</span>&#123;a&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p> $\hat{a}\quad \widehat{a} \quad\vec{a} \quad \overline{a}$</p><h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><h5 id="1-界限"><a href="#1-界限" class="headerlink" title="1. 界限"></a>1. 界限</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\min</span> x <span class="keyword">\max</span> y <span class="keyword">\inf</span> s <span class="keyword">\sup</span> t<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\lim</span> u <span class="keyword">\liminf</span> v <span class="keyword">\limsup</span> w<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\dim</span> p <span class="keyword">\deg</span> p <span class="keyword">\det</span> m <span class="keyword">\ker</span><span class="keyword">\phi</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\infty</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\min x \quad \max y \quad \inf s \quad \sup t$<br>$\lim u \quad \liminf v \quad \limsup w$<br>$\dim p \quad \deg p \quad \det m \quad \ker\phi$</p><p> $\infty$</p><h5 id="2-微分以及导数"><a href="#2-微分以及导数" class="headerlink" title="2. 微分以及导数"></a>2. 微分以及导数</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>dt <span class="keyword">\mathrm</span>&#123;d&#125;t <span class="keyword">\partial</span> t <span class="keyword">\nabla</span><span class="keyword">\psi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$dt \quad \mathrm{d}t \quad \partial t \quad \nabla\psi$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prime</span> <span class="keyword">\backprime</span> f<span class="built_in">^</span><span class="keyword">\prime</span> f&#x27; f&#x27;&#x27; f<span class="built_in">^</span>&#123;(3)&#125; <span class="keyword">\dot</span>&#123;y&#125; <span class="keyword">\ddot</span>&#123;y&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>$\prime \quad \backprime \quad f^\prime \quad f’ \quad f’’ \quad f^{(3)} \quad \dot{y} \quad \ddot{y}$ </p><h5 id="3-模算数"><a href="#3-模算数" class="headerlink" title="3. 模算数"></a>3. 模算数</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>a <span class="keyword">\equiv</span> 1 <span class="keyword">\pmod</span> &#123;m&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>a<span class="keyword">\%</span>b<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>$a \equiv 1 \pmod {m}$</p><p> $a\%b$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>a <span class="keyword">\bmod</span> b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$a \bmod b$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\gcd</span>(m,n) <span class="keyword">\operatorname</span>&#123;lcm&#125;(m,n)<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>  $\gcd(m,n) \quad \operatorname{lcm}(m,n)$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mid</span> <span class="keyword">\nmid</span> <span class="keyword">\shortmid</span> <span class="keyword">\nshortmid</span><span class="built_in">$</span>  ps：<span class="keyword">\mid</span>可以用|代替。</span><br></pre></td></tr></table></figure><p>$\mid \quad \nmid \quad \shortmid \quad \nshortmid$  </p><h5 id="4-根号"><a href="#4-根号" class="headerlink" title="4. 根号"></a>4. 根号</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\surd</span> <span class="keyword">\sqrt</span>&#123;2&#125; <span class="keyword">\sqrt</span>[n]&#123;&#125; <span class="keyword">\sqrt</span>[n]&#123;x&#125;<span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>$\surd \quad \sqrt{2} \quad \sqrt[n]{} \quad \sqrt[n]{x}$ </p><h5 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>+ - <span class="keyword">\pm</span> <span class="keyword">\mp</span> <span class="keyword">\dotplus</span><span class="built_in">$</span>  <span class="built_in">$</span><span class="keyword">\times</span> <span class="keyword">\div</span> <span class="keyword">\divideontimes</span> / <span class="keyword">\backslash</span><span class="built_in">$</span>  <span class="built_in">$</span><span class="keyword">\cdot</span> * <span class="keyword">\star</span> <span class="keyword">\circ</span> <span class="keyword">\bullet</span><span class="built_in">$</span>  <span class="built_in">$</span><span class="keyword">\oplus</span> <span class="keyword">\ominus</span> <span class="keyword">\otimes</span> <span class="keyword">\oslash</span> <span class="keyword">\odot</span><span class="built_in">$</span>  <span class="built_in">$</span><span class="keyword">\bigoplus</span> <span class="keyword">\bigotimes</span> <span class="keyword">\bigodot</span><span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>$+ \quad - \quad \pm \quad \mp \quad \dotplus$<br> $\times \quad \div \quad \divideontimes \quad / \quad \backslash$<br> $\cdot \quad * \quad \star \quad \circ \quad \bullet$ </p><p>$\oplus\quad \ominus\quad \otimes\quad \oslash\quad \odot$ </p><p>$\bigoplus \quad \bigotimes \quad \bigodot$ </p><h5 id="6-集合"><a href="#6-集合" class="headerlink" title="6. 集合"></a>6. 集合</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\emptyset</span> <span class="keyword">\varnothing</span><span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p> $\emptyset \quad \varnothing$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\in</span> <span class="keyword">\notin</span> <span class="keyword">\not</span><span class="keyword">\in</span> <span class="keyword">\ni</span> <span class="keyword">\not</span><span class="keyword">\ni</span><span class="built_in">$</span>  ps:<span class="keyword">\not</span>是在下一个字符上画斜杠。</span><br></pre></td></tr></table></figure><p> $\in \quad \notin \quad \not\in \quad \ni \quad \not\ni$  </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\subset</span> <span class="keyword">\supset</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\subset\quad  \supset$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\subseteq</span> <span class="keyword">\nsubseteq</span> <span class="keyword">\subsetneq</span> <span class="keyword">\varsubsetneq</span> <span class="keyword">\sqsubseteq</span><span class="built_in">$</span> <span class="built_in">$</span><span class="keyword">\supseteq</span> <span class="keyword">\nsupseteq</span> <span class="keyword">\supsetneq</span> <span class="keyword">\varsupsetneq</span> <span class="keyword">\sqsupseteq</span><span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>$\subseteq \quad \nsubseteq \quad \subsetneq \quad \varsubsetneq \quad \sqsubseteq$ </p><p>$\supseteq \quad \nsupseteq \quad \supsetneq \quad \varsupsetneq \quad \sqsupseteq$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cap</span> <span class="keyword">\bigcap</span> <span class="keyword">\cup</span> <span class="keyword">\bigcup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\cap \quad \bigcap \quad \cup \quad \bigcup$</p><h5 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h5><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>= <span class="keyword">\ne</span> <span class="keyword">\neq</span> <span class="keyword">\equiv</span> <span class="keyword">\not</span><span class="keyword">\equiv</span><span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p> $= \quad \ne \quad \neq \quad \equiv \quad \not\equiv$ </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sim</span> <span class="keyword">\nsim</span> <span class="keyword">\backsim</span> <span class="keyword">\thicksim</span> <span class="keyword">\simeq</span> <span class="keyword">\backsimeq</span> <span class="keyword">\eqsim</span> <span class="keyword">\cong</span> <span class="keyword">\ncong</span><span class="built_in">$</span> </span><br></pre></td></tr></table></figure><p>$\sim \quad \nsim \quad \backsim \quad \thicksim \quad \simeq \quad \backsimeq\quad  \eqsim \quad \cong\quad  \ncong$ </p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown扩展</title>
      <link href="/2021/07/31/markdown_extension/"/>
      <url>/2021/07/31/markdown_extension/</url>
      
        <content type="html"><![CDATA[<div class="note primary simple"><p>Markdown 系列有三部分构成：</p><ol><li><a href="/2021/07/31/markdown/">Markdown的基本语法</a></li><li><a href="/2021/07/31/markdown_extension/">Mardkwon的扩展语法</a></li><li><a href="/2021/07/31/markdown_Mathjax/">Markdown的扩展应用-Mathjax</a></li></ol></div><h2 id="Markdown-扩展语法"><a href="#Markdown-扩展语法" class="headerlink" title="Markdown 扩展语法"></a>Markdown 扩展语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><p>单元格宽度可以变化，如下所示。呈现的输出将看起来相同。（基于不同的Markdown解析器，所展现出来的效果也不同）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><p>可以使用该网站加快表格的创建：<a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a></p><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table></div><h4 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="格式化表格中的文字"></a>格式化表格中的文字</h4><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（```）中的单词或短语，<strong>而不是代码块</strong>）和强调。</p><p><strong>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</strong></p><h4 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="在表中转义管道字符"></a>在表中转义管道字符</h4><p>您可以使用表格的HTML字符代码（<code>&amp;#124</code>）在表中显示竖线（<code>|</code>）字符。</p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳至页面底部的脚注内容。</p><p>要创建脚注参考，请在方括号（<code>[^1]</code>）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联-在输出中，脚注按顺序编号。</p><p>在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（<code>[^1]: My footnote.</code>）。您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s a simple footnote,[^1] and here&#x27;s a longer one.[^bignote]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">This is the first footnote.</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^bignote</span>]: <span class="link">Here&#x27;s one with multiple paragraphs and code.</span></span><br><span class="line"></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">Indent paragraphs to include them in the footnote.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">`&#123; my code &#125;`</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">Add as many paragraphs as you like.</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p>呈现的输出如下：</p><p>Here’s a simple footnote,<sup><a href="#fn_1" id="reffn_1">1</a></sup> and here’s a longer one.<sup><a href="#fn_bignote" id="reffn_bignote">bignote</a></sup></p><blockquote id="fn_1"><sup>1</sup>. This is the first footnote.<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_bignote"><sup>bignote</sup>. Here’s one with multiple paragraphs and code.<a href="#reffn_bignote" title="Jump back to footnote [bignote] in the text."> &#8617;</a></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Indent paragraphs to include them in the footnote.</span><br><span class="line"></span><br><span class="line">`&#123; my code &#125;`</span><br><span class="line"></span><br><span class="line">Add as many paragraphs as you like.</span><br></pre></td></tr></table></figure><h3 id="标题编号"><a href="#标题编号" class="headerlink" title="标题编号"></a>标题编号</h3><p>许多Markdown处理器支持<a href="https://markdown.com.cn/basic-syntax/headings.html">标题</a>的自定义ID - 一些Markdown处理器会自动添加它们。添加自定义ID允许您直接链接到标题并使用CSS对其进行修改。要添加自定义标题ID，请在与标题相同的行上用大括号括起该自定义ID。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### My Great Heading &#123;#custom-id&#125;</span></span><br></pre></td></tr></table></figure><p>对应的HTML代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 id=&quot;custom-id&quot;&gt;My Great Heading&lt;/h3&gt;</span><br></pre></td></tr></table></figure><p>通过创建带有数字符号（<code>#</code>）和自定义标题ID的<a href="(/basic-syntax/links.html">标准链接</a>，可以链接到文件中具有自定义ID的标题。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>[Heading IDs](#heading-ids)</code></td><td><code>&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</code></td><td><a href="https://markdown.com.cn/extended-syntax/heading-ids.html#heading-ids">Heading IDs</a></td></tr></tbody></table></div><p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<code>[Heading IDs](https://markdown.com.cn/extended-syntax/heading-ids.html#headid)</code>）来链接到标题。</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，并不表示要包含在文档中。若要删除单词，请<code>~~</code>在单词前后使用两个波浪号。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><p><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号（<code>-</code>）和方括号，并<code>[ ]</code>在其前面加上空格。要选择一个复选框，请x在方括号（<code>[x]</code>）之间添加in 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><ul><li>[x] Write the press release</li><li>[ ] Update the website</li><li>[ ] Contact the media</li></ul><h3 id="使用Emoji表情"><a href="#使用Emoji表情" class="headerlink" title="使用Emoji表情"></a>使用Emoji表情</h3><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入<em>emoji shortcodes</em>。</p><h4 id="复制和粘贴表情符号"><a href="#复制和粘贴表情符号" class="headerlink" title="复制和粘贴表情符号"></a>复制和粘贴表情符号</h4><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia</a> 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。</p><p><strong>Tip:</strong> 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。.</p><h4 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h4><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">去露营了！ :tent: 很快回来。</span><br><span class="line"></span><br><span class="line">真好笑！ :joy:</span><br></pre></td></tr></table></figure><p>呈现的输出如下所示：</p><p>去露营了！⛺很快回来。</p><p>真好笑！😂</p><p>其他表情符号请戳：<a href="https://blog.csdn.net/weixin_42395140/article/details/111642339">表情符号</a></p><h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>展开<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">这是展开后的内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><details><summary>展开</summary>这是展开后的内容</details><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>markdown支持生成目录，部分博客网站也支持。</p><p><code>[TOC]</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 的使用</title>
      <link href="/2021/07/31/markdown/"/>
      <url>/2021/07/31/markdown/</url>
      
        <content type="html"><![CDATA[<div class="note primary simple"><p>Markdown 系列有三部分构成：</p><ol><li><a href="/2021/07/31/markdown/">Markdown的基本语法</a></li><li><a href="/2021/07/31/markdown_extension/">Mardkwon的扩展语法</a></li><li><a href="/2021/07/31/markdown_Mathjax/">Markdown的扩展应用-Mathjax</a></li></ol></div><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><ol><li><p><a href="https://typora.io"><img src="https://typora.io/img/favicon-64.png" alt="这是图片"></a></p><p> 所编即所得，是当前非常热门的Markdown编辑器</p></li><li><p><a href="https://code.visualstudio.com/"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.FKwwHOVWQXEDwANxN03tiAHaD_?pid=ImgDet&rs=1" width="100px"></a></p><p> Visual Studio Code，需要一些配置，但也十分的简单易用。</p></li></ol><h2 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h2><p>总述：Markdown 是一种轻量级的标记语言，排班语法简介，让人更容易关注内容本身而非排版，它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：CSDN、博客园、简书等。</p><p>「标记」、「语言」等听起来很高大上，实则在Markdown中非常简单，你只需要记住不超过十个标记就能处理日常中的大多数事务。这将大大提升你的工作效率。</p><p>本文仅供学习参考用途，参考网站有：</p><ol><li><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 | Markdown 语法教程</a></li></ol><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。例如，添加三个 <code>#</code> 表示创建一个三级标题 (<code>&lt;h3&gt;</code>) (例如：<code>### My Header</code>)。</p><div class="table-container"><table><thead><tr><th>Markdown语法</th><th>HTML</th></tr></thead><tbody><tr><td><code># Heading level 1</code></td><td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td></tr><tr><td><code>## Heading level 2</code></td><td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td></tr><tr><td><code>### Heading level 3</code></td><td><code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code></td></tr><tr><td><code>#### Heading level 4</code></td><td><code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code></td></tr><tr><td><code>##### Heading level 5</code></td><td><code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code></td></tr><tr><td><code>###### Heading level 6</code></td><td><code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code></td></tr></tbody></table></div><p>不同的 Markdown 应用程序处理 <code>#</code> 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 <code>#</code> 和标题之间进行分隔。</p><div class="table-container"><table><thead><tr><th>✅ Do this</th><th>❌ Don’t do this</th></tr></thead><tbody><tr><td><code># Here&#39;s a Heading</code></td><td><code>#Here&#39;s a Heading</code></td></tr></tbody></table></div><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><div class="table-container"><table><thead><tr><th>Markdown语法</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>I really like using Markdown.</code><br><br><code>I think I&#39;ll use it to format all of my documents from now on.</code></td><td><code>&lt;p&gt;I really like using Markdown.&lt;/p&gt;</code><br><br><code>&lt;p&gt;I think I&#39;ll use it to format all of my documents from now on.&lt;/p&gt;</code></td><td>I really like using Markdown.<br><br>I think I’ll use it to format all of my documents from now on.</td></tr></tbody></table></div><p>不要用空格（spaces）或制表符（ tabs）缩进段落。在Markdown渲染时并不会显示缩进。</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>在一行的末尾添加两个或多个空格，然后按回车键，即可创建一个换行(<code>&lt;br&gt;</code>)。</p><div class="table-container"><table><thead><tr><th>Markdown语法</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>This is the first line.</code><br><code>And this is the second line.</code></td><td><code>&lt;p&gt;This is the first line.</code><br><code>&lt;br&gt;</code><br><code>And this is the second line.&lt;/p&gt;</code></td><td>This is the first line. <br>And this is the second line.</td></tr></tbody></table></div><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 <code>结尾空格（trailing whitespace)</code> 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><h4 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h4><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**strongcontent**</span></span><br><span class="line"><span class="strong">__strongcontent__</span></span><br><span class="line">stro<span class="strong">**ngc**</span>ontent</span><br></pre></td></tr></table></figure><p><strong>strongcontent</strong></p><p><strong>strongcontent</strong></p><p>stro<strong>ngc</strong>ontent</p><blockquote><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）<code>*</code>。</p></blockquote><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*Italiccontent*</span></span><br><span class="line"><span class="emphasis">_Italiccontent_</span></span><br><span class="line">Itali<span class="emphasis">*cco*</span>ntent</span><br></pre></td></tr></table></figure><p><em>Italiccontent</em></p><p><em>Italiccontent</em></p><p>Itali<em>cco</em>ntent</p><blockquote><p>与加粗一样，要用斜体突出单词的中间部分，请使用星号（asterisks）<code>*</code>。</p></blockquote><h4 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h4><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This <span class="strong">**<span class="emphasis">*text*</span>**</span> is really important.</span><br><span class="line">This <span class="strong">__<span class="emphasis">_text_</span>__</span> is really important.</span><br><span class="line">This <span class="strong">__<span class="emphasis">*text*</span>__</span> is really important.</span><br><span class="line">This <span class="strong">**<span class="emphasis">_text_</span>**</span> is really important.</span><br><span class="line">This t<span class="strong">**<span class="emphasis">*ex*</span>**</span>t is really important.</span><br></pre></td></tr></table></figure><p>This <strong><em>text</em></strong> is really important.</p><p>This <strong><em>text</em></strong> is really important.</p><p>This <strong><em>text</em></strong> is really important.</p><p>This <strong><em>text</em></strong> is really important.</p><p>This t<strong><em>ex</em></strong>t is really important.</p><blockquote><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span></span><br></pre></td></tr></table></figure><p>渲染效果如下所示：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h4 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h4><p>块引用可以包含多个段落。为段落之间的空白行添加一个 <code>&gt;</code> 符号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span></span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h4 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h4><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span></span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h4 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h4><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; #### The quarterly results look great!</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; - Revenue was off the chart.</span></span><br><span class="line"><span class="quote">&gt; - Profits were higher than ever.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;  <span class="emphasis">*Everything*</span> is going according to <span class="strong">**plan**</span>.</span></span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>可以将多个条目组织成有序或无序列表。</p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> First item</span><br><span class="line"><span class="bullet">2.</span> Second item</span><br><span class="line"><span class="bullet">3.</span> Third item</span><br><span class="line"><span class="bullet">4.</span> Fourth item</span><br></pre></td></tr></table></figure><ol><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ol><blockquote><p>请确保有序列表序号中的点是英文格式的点，另外请不要使用 1、, 1) 等格式。</p></blockquote><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> First item</span><br><span class="line"><span class="bullet">-</span> Second item</span><br><span class="line"><span class="bullet">-</span> Third item</span><br><span class="line"><span class="bullet">-</span> Fourth item</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> First item</span><br><span class="line"><span class="bullet">-</span> Second item</span><br><span class="line"><span class="bullet">-</span> Third item</span><br><span class="line"><span class="bullet">    -</span> Indented item</span><br><span class="line"><span class="bullet">    -</span> Indented item</span><br><span class="line"><span class="bullet">-</span> Fourth item</span><br></pre></td></tr></table></figure><ul><li>First item</li><li>Second item</li><li>Third item</li><li>Fourth item</li></ul><ul><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ul><h4 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h4><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><h5 id="段落-1"><a href="#段落-1" class="headerlink" title="段落"></a>段落</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   This is the first list item.</span><br><span class="line"><span class="bullet">*</span>   Here&#x27;s the second list item.</span><br><span class="line"></span><br><span class="line"><span class="code">    I need to add another paragraph below the second list item.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   And here&#x27;s the third list item.</span><br></pre></td></tr></table></figure><ul><li>This is the first list item.</li><li><p>Here’s the second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h5 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   This is the first list item.</span><br><span class="line"><span class="bullet">*</span>   Here&#x27;s the second list item.</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt; A blockquote would look great below the second list item.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   And here&#x27;s the third list item.</span><br></pre></td></tr></table></figure><ul><li>This is the first list item.</li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Open the file.</span><br><span class="line"><span class="bullet">2.</span>  Find the following code block on line 21:</span><br><span class="line"><span class="code">```html</span></span><br><span class="line"><span class="code">    &lt;html&gt;</span></span><br><span class="line"><span class="code">    &lt;head&gt;</span></span><br><span class="line"><span class="code">        &lt;title&gt;Test&lt;/title&gt;</span></span><br><span class="line"><span class="code">    &lt;/head&gt;</span></span><br></pre></td></tr></table></figure><ol><li>Update the title to match the name of your website.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.  Open the file.</span><br><span class="line">2.  Find the following code block on line 21:</span><br><span class="line">```html</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Test&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br></pre></td></tr></table></figure></li><li>Update the title to match the name of your website.</li></ol><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Open the file containing the Linux mascot.</span><br><span class="line"><span class="bullet">2.</span>  Marvel at its beauty.</span><br><span class="line"></span><br><span class="line"><span class="code">    ![img](https://typora.io/img/favicon-64.png)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">3.</span>  Close the file.</span><br></pre></td></tr></table></figure><ol><li>Open the file containing the Linux mascot.</li><li><p>Marvel at its beauty.</p><p><img src="https://typora.io/img/favicon-64.png" alt="img"></p></li><li><p>Close the file.</p></li></ol><h5 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> First item</span><br><span class="line"><span class="bullet">2.</span> Second item</span><br><span class="line"><span class="bullet">3.</span> Third item</span><br><span class="line"><span class="bullet">    -</span> Indented item</span><br><span class="line"><span class="bullet">    -</span> Indented item</span><br><span class="line"><span class="bullet">4.</span> Fourth item</span><br></pre></td></tr></table></figure><ol><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>要将单词或短语表示为代码，请将其包裹在反引号 (<code>` </code>) 中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">At the command prompt, type <span class="code">`nano`</span>.</span><br></pre></td></tr></table></figure><p>At the command prompt, type <code>nano</code>.</p><h4 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h4><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(<code>`` </code>)中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">``Use `</span>code<span class="code">` in your Markdown file.`</span>`</span><br></pre></td></tr></table></figure><p><code>Use `code` in your Markdown file.</code></p><h4 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h4><p>Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。但这种写法不方便，可以直接用两个 <code>``` </code> 进行包裹</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">​<span class="code">```</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">  &quot;firstName&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="code">  &quot;lastName&quot;: &quot;Smith&quot;,</span></span><br><span class="line"><span class="code">  &quot;age&quot;: 25</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure><p>呈现出的效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若想要语法高亮，可以在反引号后指定语言</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">​<span class="code">```json</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">  &quot;firstName&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="code">  &quot;lastName&quot;: &quot;Smith&quot;,</span></span><br><span class="line"><span class="code">  &quot;age&quot;: 25</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Smith&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---------------</span></span><br></pre></td></tr></table></figure><p>呈现样式如下：</p><hr><p>为了兼容性，请在分隔线的前后均添加空白行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Try to put a blank line before...</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">...and after a horizontal rule.</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接 [Markdown语法](https://markdown.com.cn)。</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p>这是一个链接 <a href="https://markdown.com.cn/">Markdown语法</a>。</p><p>链接的更多应用请戳：<a href="https://markdown.com.cn/basic-syntax/links.html">Markdown 链接语法</a></p><blockquote><p>不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。</p><p><code>[link](https://www.example.com/my%20great%20page)</code></p></blockquote><h3 id="图片-1"><a href="#图片-1" class="headerlink" title="图片"></a>图片</h3><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><p>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">这是图片</span>](<span class="link">https://typora.io/img/favicon-64.png</span>)</span><br></pre></td></tr></table></figure><p><img src="https://typora.io/img/favicon-64.png" alt="这是图片"></p><h4 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h4><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![这是图片</span>](<span class="link">https://typora.io/img/favicon-64.png</span>)](<span class="link">https://typora.io</span>)</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><a href="https://typora.io"><img src="https://typora.io/img/favicon-64.png" alt="这是图片"></a></p><h3 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h3><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 (<code>\</code>) 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p>* Without the backslash, this would be a bullet in an unordered list.</p><h4 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h4><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><div class="table-container"><table><thead><tr><th>Character</th><th>Name</th></tr></thead><tbody><tr><td>\</td><td>backslash</td></tr><tr><td>`</td><td>backtick (see also <a href="https://markdown.com.cn/basic-syntax/escaping-characters.html#escaping-backticks">escaping backticks in code</a>)</td></tr><tr><td>*</td><td>asterisk</td></tr><tr><td>_</td><td>underscore</td></tr><tr><td>{ }</td><td>curly braces</td></tr><tr><td>[ ]</td><td>brackets</td></tr><tr><td>( )</td><td>parentheses</td></tr><tr><td>#</td><td>pound sign</td></tr><tr><td>+</td><td>plus sign</td></tr><tr><td>-</td><td>minus sign (hyphen)</td></tr><tr><td>.</td><td>dot</td></tr><tr><td>!</td><td>exclamation mark</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第八讲-数据结构进阶（二）</title>
      <link href="/2020/08/17/AdvancedDataStructure(2)/"/>
      <url>/2020/08/17/AdvancedDataStructure(2)/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第十讲-计算几何</title>
      <link href="/2020/08/14/ComputationalGeometry/"/>
      <url>/2020/08/14/ComputationalGeometry/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第九讲-后缀数组</title>
      <link href="/2020/08/13/SuffixArray/"/>
      <url>/2020/08/13/SuffixArray/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第八讲-二分图与网络流</title>
      <link href="/2020/08/10/BipartiteGraph&amp;Network-flows/"/>
      <url>/2020/08/10/BipartiteGraph&amp;Network-flows/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E7%BD%91%E7%BB%9C%E6%B5%81.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第七讲-动态规划（二）</title>
      <link href="/2020/08/05/DP(2)/"/>
      <url>/2020/08/05/DP(2)/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第七讲-动态规划（一）</title>
      <link href="/2020/08/04/DP(1)/"/>
      <url>/2020/08/04/DP(1)/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第六讲-字符串</title>
      <link href="/2020/07/30/String/"/>
      <url>/2020/07/30/String/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B2%E8%AF%BE.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第五讲-数据结构进阶（一）</title>
      <link href="/2020/07/28/AdvancedDataStructure(1)/"/>
      <url>/2020/07/28/AdvancedDataStructure(1)/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B61.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第四讲-图论（二）</title>
      <link href="/2020/07/24/GraphTheory(2)/"/>
      <url>/2020/07/24/GraphTheory(2)/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/图论2.pptx">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第三讲-图论（一）</title>
      <link href="/2020/07/22/GraphTheory(1)/"/>
      <url>/2020/07/22/GraphTheory(1)/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%9B%BE%E8%AE%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%85%E5%AE%B9.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第二讲-数据结构基础</title>
      <link href="/2020/07/20/BasicDataStructure/"/>
      <url>/2020/07/20/BasicDataStructure/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020暑期集训第一讲-博弈论</title>
      <link href="/2020/07/02/GameTheory/"/>
      <url>/2020/07/02/GameTheory/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E7%AE%80%E5%8D%95%E5%8D%9A%E5%BC%88%E8%AE%BA.pptx">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第七讲-动态规划</title>
      <link href="/2019/11/16/yd/"/>
      <url>/2019/11/16/yd/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%BE%E4%BB%B6.ppt">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第六讲-简单搜索</title>
      <link href="/2019/11/09/ww/"/>
      <url>/2019/11/09/ww/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2.pptx">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第五讲-STL&amp;并查集</title>
      <link href="/2019/11/02/zzy/"/>
      <url>/2019/11/02/zzy/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%26%26%E5%B9%B6%E6%9F%A5%E9%9B%86.pptx">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第四讲-数论基础</title>
      <link href="/2019/10/26/lhy/"/>
      <url>/2019/10/26/lhy/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第三讲-前缀和&amp;差分&amp;二分&amp;贪心&amp;高精度</title>
      <link href="/2019/10/19/lhj/"/>
      <url>/2019/10/19/lhj/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86%E4%BA%8C%E5%88%86%E8%B4%AA%E5%BF%83.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第二讲-C语言基础教程（二）</title>
      <link href="/2019/10/12/C%EF%BC%882%EF%BC%89/"/>
      <url>/2019/10/12/C%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B(%E4%BA%8C">课件下载</a>.pdf)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019算法讲堂第一讲-C语言基础教程（一）</title>
      <link href="/2019/09/28/C%EF%BC%881%EF%BC%89/"/>
      <url>/2019/09/28/C%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="cources/2020-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B(%E4%B8%80">课件下载</a>%E8%AE%B2%E4%B9%89.pdf)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第十三讲：计算几何</title>
      <link href="/2019/08/16/GM/"/>
      <url>/2019/08/16/GM/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第十二讲：高级数据结构（三）</title>
      <link href="/2019/08/12/datastruct/"/>
      <url>/2019/08/12/datastruct/</url>
      
        <content type="html"><![CDATA[<h1 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h1><p>分块是一种思想，对于一些题目，首先线段树等数据结构，分块作为一个备用方案</p><p>它擅长做的一些事情</p><ul><li>区间和<ul><li>将序列分段，每段长度$T$，那么一共右$n\over T$段，大段维护小段暴力，复杂度$O({n\over T}+T)$</li><li>也可以维护很多种前缀和进而做到$O(1)$查询</li></ul></li><li>对询问分块<ul><li>如果操作次数比较少，可以先把操作记下来，在询问的时候加上这些操作的影响</li><li>T个操作，则修改$O(1)$，询问$O(T)$</li></ul></li></ul><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>莫队算法是由莫涛提出的算法，可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。 </p><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>假设 n=m，那么对于序列上的区间询问问题，如果从$[l,r]$的答案能够$O(1)$扩展到 $[l-1,r],[l+1,r],[l,r+1],[l,r-1]$（即与 $[l,r]$ 相邻的区间）的答案，那么可以在$O(n\sqrt n)$ 的复杂度内求出所有询问的答案。 </p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>排序：对于区间$[l,r]$，以$l$所在块的编号为第一关键字，以$r$为第二关键字从小到大排序</li><li>实现：先排序，顺序处理每一个询问，暴力从上一个区间的答案转移到下一个区间的答案</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// update nowAns</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BLOCK_SIZE = <span class="built_in">int</span>(<span class="built_in">ceil</span>(<span class="built_in">pow</span>(n, <span class="number">0.5</span>)));</span><br><span class="line">  <span class="built_in">sort</span>(querys, querys + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> query &amp;q = querys[i];</span><br><span class="line">    <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">move</span>(r++, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">move</span>(--r, <span class="number">-1</span>);</span><br><span class="line">    ans[q.id] = nowAns;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li>当n和m同级时，对于每个块内，右端点单调递增，左端点都在块内，所以处理每个块内的询问操作右端点最多移动$n$次，所以所有的询问右端点最多移动$n\cdot {n\over T}$次。而对于所有询问的左端点，每次移动最多$T$次，所以复杂度$O(n\cdot T)$，所以总复杂度$O(n\cdot{n\over T}+n\cdot T)$ 当$T=\sqrt n$时最优达到$O(n\sqrt T)$</li><li>当n和m不同级时，对于每个块，右端点最多修改$n$次，每个询问左端点最多移动$T$次，所以复杂度$O({n\over T}\cdot n + mT)$ 当$T={n\over{\sqrt m}}$时最优</li></ol><h4 id="例题-小Z的袜子-HYSBZ-2038"><a href="#例题-小Z的袜子-HYSBZ-2038" class="headerlink" title="例题 小Z的袜子 (HYSBZ-2038)"></a>例题 小Z的袜子 (HYSBZ-2038)</h4><p>作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命…… 具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。 你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。 </p><p>思路：模板题</p><p>某个区间$[l,r]$的答案：</p><script type="math/tex; mode=display">{\sum_{i是区间内出现的颜色} sum[i]\cdot (sum[i]-1)/2}\over {C_{r-l+1}^2}</script><ol><li>对询问排序<ol><li>$[l,r]$，以$l$所在块的编号为第一关键字，r为第二关键字从小到大排序。</li></ol></li><li>暴力维护答案的分子部分即可</li><li>可以发现答案分子分母同时将2约掉，分子展开后变成$sum[i]\cdot sum[i] - sum[i]$可以发现对于所有的 i ，$sum[i]$的和将变成$r-l+1$，所以我们只需要维护所有$sum[i]$的平方和即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a[N],be[N],n,m;</span><br><span class="line">ll res = <span class="number">0</span>,sum[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    ll A,B;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="comment">//如果在同一块，则按照右端点排序，否则按照左端点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l] == be[b.l] ? a.r &lt; b.r : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x)</span></span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"><span class="comment">//先减去上一次的影响，修改后再重新加新的影响</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> add)</span></span>&#123;res -= <span class="built_in">S</span>(sum[a[pos]]);sum[a[pos]] += add;res += <span class="built_in">S</span>(sum[a[pos]]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> base = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);q[i].id = i;</span><br><span class="line">        be[i] = (i<span class="number">-1</span>) / base + <span class="number">1</span>;<span class="comment">//be[i]即i在第几块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m,cmp1);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line">    res = <span class="number">0</span>;<span class="comment">//res为当点询问区间内出现的所有颜色的个数平方和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//暴力调整区间，维护res</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; q[i].l)<span class="built_in">move</span>(l++,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(l &gt; q[i].l)<span class="built_in">move</span>(--l,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r &lt; q[i].r)<span class="built_in">move</span>(++r,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(r &gt; q[i].r)<span class="built_in">move</span>(r--,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            q[i].A = <span class="number">0</span>;q[i].B = <span class="number">1</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].A  = res - (r - l + <span class="number">1</span>);<span class="comment">//计算答案分子部分</span></span><br><span class="line">        q[i].B = <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * (r - l);<span class="comment">//分母部分</span></span><br><span class="line">        ll g = <span class="built_in">gcd</span>(q[i].A,q[i].B);<span class="comment">//约分</span></span><br><span class="line">        q[i].A /= g;</span><br><span class="line">        q[i].B /= g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,q[i].A,q[i].B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通莫队优化"><a href="#普通莫队优化" class="headerlink" title="普通莫队优化"></a>普通莫队优化</h3><p>可以发现当第一块内的询问处理完之后，r的位置应该特别靠后，但是当移动到下一个块之后，r可能会往前移动很多，比如如下询问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//第一个块</span><br><span class="line">1 50</span><br><span class="line">2 100</span><br><span class="line">//第二个块</span><br><span class="line">12 13</span><br><span class="line">14 100</span><br></pre></td></tr></table></figure><p>在完成[2,100]的询问后，r从100-&gt; 13 然后又从13 -&gt; 100。这样显然不如100-&gt;100, 100 -&gt; 13。</p><p>如何优化？</p><p>相邻两块之间r的排序规则相反即可</p><p>即奇数块按照升序，偶数快按照降序</p><div class="table-container"><table><thead><tr><th>Result</th><th>Memory</th><th>Time</th></tr></thead><tbody><tr><td>Accepted</td><td>3456 kb</td><td>1840 ms</td></tr><tr><td>Accepted</td><td>3456 kb</td><td>1392 ms</td></tr></tbody></table></div><p>下面的是优化过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l] == be[b.l] ? </span><br><span class="line">        (be[a.l]&amp;<span class="number">1</span> ? a.r &lt; b.r : a.r &gt; b.r)</span><br><span class="line">        : a.l &lt; b.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带修改的莫队"><a href="#带修改的莫队" class="headerlink" title="带修改的莫队"></a>带修改的莫队</h3><p>考虑普通莫队加入修改修做，如果修改操作可以$O(1)$的应用以及撤销(同时也要维护当前区间的答案)，那么可以在$O(n^{5\over 3})$的复杂度内求出所有询问的答案。</p><p>实现: 离线后排序，顺序遍历询问，先将时间转移到当前询问的时间，然后再像普通莫队一样转移区间。</p><p>排序方法: 设定块的长度为$S_1,S_2$，按照($\lfloor{l\over S_1}\rfloor \lfloor{r\over S_2}\rfloor,t$)的三元组小到大排序，其中 $t$ 表示这个询问的时刻之前经历过了几次修改操作</p><p>复杂度分析：考虑询问序列中的每个小块，小块内每个询问的一二关键字相同。在这个小块内，时间 $t$ 最多变化 $m$ ，对于每个询问，$l,r$ 最多变化 $S_1,S_2$, 一共右$n^2\over {S_1,S_2}$ 个这样的块，相邻块之间转移复杂度是$O(n)$, 总复杂度就是</p><p>$O(mS_1+mS_2+{n^2m\over S_1S_2}+{n^3\over S_1S_2})$</p><p>当$n,m$同阶时，取$S_1 = S_2 = n^{2\over 3}$ 时可达到最优复杂度$O(n^{5\over 3})$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, t = <span class="number">0</span>, nowAns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// update nowAns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">moveTime</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// apply or revoke modification</span></span><br><span class="line">    <span class="comment">// update nowAns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BLOCK_SIZE = <span class="built_in">int</span>(<span class="built_in">ceil</span>(<span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3</span>)));</span><br><span class="line">    <span class="built_in">sort</span>(querys, querys + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q1; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> query q = querys[i];</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q.t) <span class="built_in">moveTime</span>(t++, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q.t) <span class="built_in">moveTime</span>(--t, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">move</span>(r++, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">move</span>(--r, <span class="number">-1</span>);</span><br><span class="line">        ans[q.id] = nowAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树分块"><a href="#树分块" class="headerlink" title="树分块"></a>树分块</h2><p>递归处理子树，把当前结点当作栈底，然后递归，回溯回来之后如果栈中结点数量到达某一个标准时，弹出栈中所有的元素分到一个块中，最后递归结束了如果栈中还有元素，那么剩下的这些元素放在新的块中</p><p><img src="https://images2015.cnblogs.com/blog/1101338/201706/1101338-20170602203815430-2027368449.png" alt="image"></p><p>题目：<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1086">BZOJ-1086</a></p><p>当块中元素大于B时，立即释放放入到一个新块中，省会可以直接用当前递归到的点，因为它的子节点一定是在栈中的。最后栈中剩下的部分是小于B的，所以可以直接加到上一个块中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];  </span><br><span class="line"><span class="type">int</span> n,B,st[N],sz = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> block_cnt = <span class="number">0</span>,province[N],be[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa = <span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> bottom = sz;<span class="comment">//把当前结点当作栈底</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> y = G[u][i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,u);</span><br><span class="line">        <span class="keyword">if</span>(sz - bottom &gt;= B)&#123;<span class="comment">//如果栈中元素大于B</span></span><br><span class="line">            block_cnt++;<span class="comment">//块数++</span></span><br><span class="line">            <span class="keyword">while</span>(sz != bottom)&#123;</span><br><span class="line">                be[st[sz--]] = block_cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            province[block_cnt] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[++sz] = u;<span class="comment">//栈中加入该元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(sz)be[st[sz--]] = block_cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,block_cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,be[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=block_cnt;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,province[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h3><p><a href="https://blog.sengxian.com/algorithms/mo-s-algorithm">参考博客</a></p><p>对于树上的路径询问问题</p><ul><li>O(1)的时间加入或删除一个点的贡献 -&gt; $O(n\sqrt n)$的复杂度求出所有询问的答案</li></ul><p>对树上的结点进行分块，离线询问后排序，顺序遍历暴力转移路径（转移时加入或删除路径上的点的贡献即可）。</p><p>关于转移路径：首先定义路径：设$T_u$为$u$ 到根的路径上边的集合，那么$u$到$v$ 的路径上的边的集合就是$T_u \triangle T_v$ ($\triangle$ 是对称差）。要从$u\rightarrow v$ 转移到 $u’\rightarrow v’$ 等价于</p><script type="math/tex; mode=display">T_u \triangle T_v\rightarrow T_{u'}\triangle T_{v'}</script><p>根据对称差的性质$T<em>u\triangle T_u\triangle T</em>{u’} = T_{u’}$ 所以只需要：</p><script type="math/tex; mode=display">T_u \triangle T_v \triangle (T_u\triangle T_{u'})\triangle (T_v\triangle T_{v'}) = T_{u'}\triangle T_{v'}</script><p>体现在程序上就是从$u\rightarrow v$ 转移到$u’ \rightarrow v’$时，暴力遍历路径$u\rightarrow u’$和路径$v\rightarrow v’$上的边，如果一条边已经加入，那么删除它，如果没有加入，就加入它。这样就完成了对称差运算。</p><p>复杂度分析：设树分块大小为S，每次转移$u\rightarrow u’$在块内的转移路径长度是$O(S)$的，而$v\rightarrow v’$的转移可以按照$dfs$序来递增，这样复杂度就是$O(ms+{n^2\over S})$</p><p>当$S=\sqrt n$时最优</p><p>例题 <a href="https://www.luogu.org/problem/SP10707">题目传送门</a></p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N],alls;</span><br><span class="line"><span class="type">int</span> be[N],f[N][<span class="number">19</span>],n,m,ans[M],dep[N],u=<span class="number">1</span>,v=<span class="number">1</span>,sum[N],vis[N],a[N],base,cnt;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> st[N],top;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;q[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa = <span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">18</span>;i++)</span><br><span class="line">        f[x][i] = f[f[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> bottom = top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;G[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> y = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        f[y][<span class="number">0</span>] = x;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(top - bottom &gt;= base)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">while</span>(top != bottom)&#123;</span><br><span class="line">                be[st[top--]] = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Query a,Query b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> be[a.l] == be[b.l] ? be[a.r] &lt; be[b.r] : be[a.l] &lt; be[b.l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(dep[x] &lt;= dep[f[y][i]]) y = f[y][i];</span><br><span class="line">    <span class="keyword">if</span>(x == y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(f[x][i] != f[y][i])x = f[x][i],y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[u] == <span class="number">1</span>)&#123;</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(--sum[a[u]] == <span class="number">0</span>)res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum[a[u]]++ == <span class="number">0</span>)res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">while</span>(dep[x] &gt; dep[y])<span class="built_in">Run</span>(x),x = f[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(x != y)<span class="built_in">Run</span>(x),<span class="built_in">Run</span>(y),x = f[x][<span class="number">0</span>],y = f[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    base = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*离散化*/</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id = <span class="built_in">lower_bound</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>(),a[i]) - alls.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">        a[i] = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//这里如果不单独设为wa</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(top)be[st[top--]] = cnt;</span><br><span class="line">    <span class="comment">//存询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>,q<span class="number">+1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u != q[i].l)&#123;<span class="built_in">move</span>(u,q[i].l);u=q[i].l;&#125;</span><br><span class="line">        <span class="keyword">if</span>(v != q[i].r)&#123;<span class="built_in">move</span>(v,q[i].r);v=q[i].r;&#125;</span><br><span class="line">        <span class="type">int</span> anc = <span class="built_in">LCA</span>(u,v);</span><br><span class="line">        <span class="built_in">Run</span>(anc);<span class="comment">//单独考虑LCA</span></span><br><span class="line">        ans[q[i].id] = res;</span><br><span class="line">        <span class="built_in">Run</span>(anc);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树上带修改的莫队与上面带修改的莫队处理方式相近</p><h2 id="块状数组"><a href="#块状数组" class="headerlink" title="块状数组"></a>块状数组</h2><p>同进阶指南分块部分</p><p>把一个数组分成若干段，$L[i],R[i]$ 分别表示第 $i$ 段的左右端点，$be[i]$ 表示 $i$ 属于第几段。大段维护局部朴素</p><p>直接上题</p><p><a href="https://www.luogu.org/problem/P2801">Luogu2801</a></p><p>长度为$n(n\le 1000000)$的数组，$q(q\le 3000)$ 次操作。修改操作即将某个区间的值增加某个不大于1000的值，查询操作即查询某个区间比C大于等于的数有多少个</p><p>我们用一个数组$add[i]$来表示第$i$段增量，如果查询区间完全包含第$i$段，那么就相当于是在原数组中查找大于等于$C-add[i]$的数，怎么找？排序后二分找。而对于左右不完整的那部分，直接暴力查询就可以。</p><p>对于修改操作。整段的直接增加增量，不完整的直接修改原数组，然后重新排序即可。</p><p>假设一段长度为$t$ 则复杂度$O(C(t+{nlog(t)\over t}))$ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],be[N],L[N],R[N],add[N];</span><br><span class="line"><span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> l,r,x;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = be[l],q = be[r];</span><br><span class="line">    <span class="keyword">if</span>(p == q)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)a[i] += x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L[p];i&lt;=R[p];i++)b[i] = a[i];</span><br><span class="line">        <span class="built_in">sort</span>(b+L[p],b+R[p]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=p<span class="number">+1</span>;i&lt;=q<span class="number">-1</span>;i++)add[i] += x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=R[p];i++)a[i] += x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L[p];i&lt;=R[p];i++)b[i] = a[i];</span><br><span class="line">        <span class="built_in">sort</span>(b+L[p],b+R[p]<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L[q];i&lt;=r;i++)a[i] += x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L[q];i&lt;=R[q];i++)b[i] = a[i];</span><br><span class="line">        <span class="built_in">sort</span>(b+L[q],b+R[q]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = be[l],q = be[r];</span><br><span class="line">    <span class="keyword">if</span>(p == q)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] + add[p] &gt;= x)res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=p<span class="number">+1</span>;i&lt;=q<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            res += (R[i]-L[i]<span class="number">+1</span>) - (<span class="built_in">lower_bound</span>(b+L[i],b+R[i]<span class="number">+1</span>,x-add[i]) - (b+L[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=R[p];i++)<span class="keyword">if</span>(a[i] + add[p] &gt;= x)res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L[q];i&lt;=r;i++)<span class="keyword">if</span>(a[i] + add[q] &gt;= x)res++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),b[i] = a[i];</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        L[i] = (i - <span class="number">1</span>) * t + <span class="number">1</span>;</span><br><span class="line">        R[i] = i * t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R[t] &lt; n)t++,L[t] = R[t<span class="number">-1</span>] + <span class="number">1</span>,R[t] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)<span class="keyword">for</span>(<span class="type">int</span> j=L[i];j&lt;=R[i];j++)be[j] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(b+L[i],b+R[i]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%d&quot;</span>,op,&amp;l,&amp;r,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)<span class="built_in">change</span>(l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solve</span>(l,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于蓝书上的例题，细节上的问题可以看喔之前写的总结：</p><p><a href="https://www.cnblogs.com/1625--H/p/11309888.html">蒲公英</a></p><p><a href="https://www.cnblogs.com/1625--H/p/11310523.html">磁力块</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第十一讲：图论（二）</title>
      <link href="/2019/08/09/GraphTheory2/"/>
      <url>/2019/08/09/GraphTheory2/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%9B%BE%E8%AE%BA2.pptx">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第十讲：高级数据结构（三）</title>
      <link href="/2019/08/07/datastruct/"/>
      <url>/2019/08/07/datastruct/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B62.pdf">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第九讲：图论（一）</title>
      <link href="/2019/08/06/GraphTheory/"/>
      <url>/2019/08/06/GraphTheory/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/%E5%9B%BE%E8%AE%BA.pptx">课件下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第八讲：数据结构进阶（一）</title>
      <link href="/2019/08/05/datastruct/"/>
      <url>/2019/08/05/datastruct/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构进阶-一"><a href="#数据结构进阶-一" class="headerlink" title="数据结构进阶(一)"></a>数据结构进阶(一)</h1><p><strong>主讲人：孙翔</strong></p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="为什么要线段树？"><a href="#为什么要线段树？" class="headerlink" title="为什么要线段树？"></a>为什么要线段树？</h3><p>题目一： 10000个正整数，编号1到10000，用A[1],A[2],A[10000]表示。 修改：无 统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000. </p><p><strong>方法一：对于统计L,R ，需要求下标从L到R的所有数的和，从L到R的所有下标记做[L..R],问题就是对A[L..R]进行求和。这样求和，对于每个询问，需要将(R-L+1)个数相加。</strong></p><p> <strong>方法二：更快的方法是求前缀和,令 S[0]=0, S[k]=A[1..k] ，那么，A[L..R]的和就等于S[R]-S[L-1]，这样，对于每个询问，就只需要做一次减法，大大提高效率。</strong> </p><p>题目二： 10000个正整数，编号从1到10000，用A[1],A[2],A[10000]表示。 修改：1.将第L个数增加C （1 &lt;= L &lt;= 10000） 统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000. </p><p>再使用方法二的话，假如A[L]+=C之后，S[L],S[L+1],,S[R]都需要增加C,全部都要修改，见下表。 </p><p><img src="https://cos.chdacm.cn//imgs/1565071358584.png" alt="1565071358584"></p><p>从上表可以看出，方法一修改快，求和慢。 方法二求和快，修改慢。那有没有一种结构，修改和求和都比较快呢？答案当然是线段树。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计。与按照二进制位（2的次幂）进行区间划分的树状数组相比，线段树是一种更加通用的结构。</p><p>1.线段树的每个节点都代表一个区间。</p><p>2.线段树具有唯一的根节点，代表的区间是整个统计范围。</p><p>3.线段树的每个叶节点都代表一个长度为1的元区间[x,x]。</p><p>4.对于每个内部节点[l,r],它的左子节点是[l,mid],右子节点是[mid+1,r],其中mid=(l+r)/2。</p><p><img src="https://cos.chdacm.cn//imgs/1565071333038.png" alt="1565071333038"></p><p>如上图所示为一棵线段树。可以发现，除去树的最后一层，整棵线段树一定是一棵完全二叉树，数的深度是O(logN)。因此，我们可以按照与二叉堆类似的方法建树：</p><p>1.根节点的编号为1。</p><p>2.编号为x的节点的左子节点编号为x <em> 2，右子节点编号为x </em> 2 + 1。</p><p>​    这样我们就能简单地使用一个结构体数组来保存线段树。当然，树的最后一层节点在数组中保存的位置不是连续的，直接空出数组中多余的位置即可。那么，N个叶子节点的满二叉树有N+N/2+N/4…..+2+1=2N-1个节点。由于在最后一层可能还有剩余，因此保存线段树的数组长度不小于4N才能保证不越界。**</p><h3 id="线段树建树"><a href="#线段树建树" class="headerlink" title="线段树建树"></a>线段树建树</h3><p>线段树的基本用途是对序列进行维护，支持查询与修改指令。给定一个长度为N的序列A，我们可以在区间[1,N]上建立一棵线段树，每个叶子结点[i,i]保存A[i]的值。线段树的二叉树结构可以很方便地从下往上传递信息。以区间最大值问题为例，记dat(l,r)等于max{A[i]},l&lt;=i&lt;=r。显然dat(l,r)=max(dat(l,mid),dat(mid+1,r))。</p><p>下面这段代码建立了一棵线段树并在每个节点上保存了对应区间的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> dat;</span><br><span class="line">&#125;t[SIZE*<span class="number">4</span>];<span class="comment">//结构体数组存储线段树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].l=l,t[p].r=r;<span class="comment">//节点p代表区间[l,r] </span></span><br><span class="line"><span class="keyword">if</span>(l==r)<span class="comment">//叶子节点 </span></span><br><span class="line">&#123;</span><br><span class="line">t[p].dat=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span><span class="number">+1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span><span class="number">+1</span>].dat);<span class="comment">//从下往上传递信息 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">//调用入口 </span></span><br></pre></td></tr></table></figure><h3 id="线段树的单点修改"><a href="#线段树的单点修改" class="headerlink" title="线段树的单点修改"></a>线段树的单点修改</h3><p>单点修改是一条形如”C x y”的指令，表示把A[x]的值修改为v。</p><p>在线段树中，根节点(即编号为1的点)是执行各种指令的入口。我们需要从根节点出发，递归找到代表区间[x,x]的叶子节点，然后从下往上更新[x,x]以及它的所有祖先上保存的信息。容易知道，其时间复杂度也是O(logN)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].l==t[p].r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].dat=v;</span><br><span class="line"><span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">change</span>(p*<span class="number">2</span>,x,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">change</span>(p*<span class="number">2</span><span class="number">+1</span>,x,v);</span><br><span class="line">&#125;</span><br><span class="line">t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span><span class="number">+1</span>].dat);<span class="comment">//从下往上更新信息 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,x,v);</span><br></pre></td></tr></table></figure><h3 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h3><p>区间查询是一条形如”Q l r”的指令，例如查询序列A在区间[l,r]上的最大值，即max{A[i]},l&lt;=i&lt;=r。我们只需要从根节点开始，递归执行如下过程。</p><p>​    1.若[l,r]完全覆盖了当前节点代表的区间，则立即回溯，并且该节点的dat值为候选答案。</p><p>​    2.若左子节点与[l,r]有重叠部分，则递归访问左子节点。</p><p>​    3.若右子节点与[l,r]有重叠部分，则递归访问右子节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;r&gt;=t[p].r)<span class="comment">//完全包含 </span></span><br><span class="line"><span class="keyword">return</span> t[p].dat;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> val=-(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);<span class="comment">//负无穷 </span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">val=<span class="built_in">max</span>(val,<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">&#123;</span><br><span class="line">val=<span class="built_in">max</span>(val,<span class="built_in">ask</span>(p*<span class="number">2</span><span class="number">+1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,r)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定长度为N的数列A，以及M条指令 (N≤500000, M≤100000)，每条指令可能是以下两种之一：</p><p>“1 x y”，查询区间 [x,y] 中的最大连续子段和，即 max(x≤l≤r≤y)⁡ { ∑(i=l~r) A[i] }。</p><p>“2 x y”，把 A[x] 改成 y。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>针对操作1，在线段树上的每个节点上，除了区间端点外，再维护4个信息：区间和sum，区间最大连续字段和dat,紧靠左端的最大连续字段和lmax,紧靠右端的最大连续子弹和rmax。则得到如下式子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t[p].sum=t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span><span class="number">+1</span>].sum;</span><br><span class="line">t[p].lmax=<span class="built_in">max</span>(t[p*<span class="number">2</span>].lmax,t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span><span class="number">+1</span>].lmax);</span><br><span class="line">t[p].rmax=<span class="built_in">max</span>(t[p*<span class="number">2</span>].rmax,t[p*<span class="number">2</span><span class="number">+1</span>].sum+t[p*<span class="number">2</span>].rmax);</span><br><span class="line">t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span><span class="number">+1</span>].dat,t[p*<span class="number">2</span>].rmax+t[p*<span class="number">2</span><span class="number">+1</span>].lmax); </span><br></pre></td></tr></table></figure><p>针对操作2，单点修改即可。</p><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>在线段树的“区间修改”指令中，如果某个节点被修改区间[l,r]完全覆盖，那么以该节点为根的整棵子树中的所有节点存储的信息都要修改，若一个一个更新(单点修改)，时间复杂度是O(N)的，我们难以接受。</p><p>试想一下如果在一次修改指令中发现节点p代表的区间[pl,pr]被修改区间[l,r]完全覆盖，并且一个一个更新了子树p的所有节点，但是在之后的查询指令中却没有用到[l,r]的子区间作为候选答案，那么更新p的整棵子树就是徒劳的。</p><p>那么我们考虑在执行修改指令的时候，可以在l&lt;=pl&lt;=pr&lt;=r的情况下立即返回，但是在回溯之前给p节点加一个标记，表示该节点曾经被修改，但是其子节点还没有被修改。</p><p>如果在后续的指令中，需要从节点p向下递归，我们再检查p是否有标记。如果有标记，就根据标记信息更新p的两个子节点，同时为p的两个子节点增加标记，然后清除p的标记。</p><p>也就是说，除了在修改指令中直接划分的O(logN)个节点外，对任意节点的修改都延迟到在后续操作中递归进入它的父亲节点时再执行。这样，查询和修改指令的时间复杂度都降到了O(logN)。延迟标记提供了线段树中从上向下传递信息的方式。也是设计算法和解决问题的一个重要思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum,add;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tree[x].l;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tree[x].r;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add(x) tree[x].add</span></span><br><span class="line">&#125;tree[<span class="number">100010</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">l</span>(p)=l;</span><br><span class="line"><span class="built_in">r</span>(p)=r;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sum</span>(p)=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span><span class="number">+1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line"><span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p*<span class="number">2</span>)+<span class="built_in">sum</span>(p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">add</span>(p))<span class="comment">//如果p节点有标记 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sum</span>(p*<span class="number">2</span>)+=<span class="built_in">add</span>(p)*(<span class="built_in">r</span>(p*<span class="number">2</span>)-<span class="built_in">l</span>(p*<span class="number">2</span>)<span class="number">+1</span>);<span class="comment">//更新左子节点信息</span></span><br><span class="line"><span class="built_in">sum</span>(p*<span class="number">2</span><span class="number">+1</span>)+=<span class="built_in">add</span>(p)*(<span class="built_in">r</span>(p*<span class="number">2</span><span class="number">+1</span>)-<span class="built_in">l</span>(p*<span class="number">2</span><span class="number">+1</span>)<span class="number">+1</span>);<span class="comment">//更新右子节点</span></span><br><span class="line"><span class="built_in">add</span>(p*<span class="number">2</span>)+=<span class="built_in">add</span>(p);<span class="comment">//给左子节点打延迟标记 </span></span><br><span class="line"><span class="built_in">add</span>(p*<span class="number">2</span><span class="number">+1</span>)+=<span class="built_in">add</span>(p);<span class="comment">//给右子节点打延迟标记 </span></span><br><span class="line"><span class="built_in">add</span>(p)=<span class="number">0</span>; <span class="comment">//清除p的标记 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;r&gt;=<span class="built_in">r</span>(p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sum</span>(p)+=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)d*(<span class="built_in">r</span>(p)-<span class="built_in">l</span>(p)<span class="number">+1</span>);</span><br><span class="line"><span class="built_in">add</span>(p)+=d;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">(l(p)+r(p))</span>/2</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line"><span class="built_in">change</span>(p*<span class="number">2</span>,l,r,d);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)</span><br><span class="line"><span class="built_in">change</span>(p*<span class="number">2</span><span class="number">+1</span>,l,r,d);</span><br><span class="line"><span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p*<span class="number">2</span>)+<span class="built_in">sum</span>(p*<span class="number">2</span><span class="number">+1</span>)； </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="built_in">ask</span>(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;r&gt;=<span class="built_in">r</span>(p))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(p);</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">val+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">val+=<span class="built_in">ask</span>(p*<span class="number">2</span><span class="number">+1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题：POJ3468"><a href="#例题：POJ3468" class="headerlink" title="例题：POJ3468"></a>例题：POJ3468</h4><p>题意：给定长度为N(N&lt;=1e5)的数列A，然后输入Q(Q&lt;=1e5)行操作指令。</p><p>第一类指令形如”C l r d”，表示把数列中的第l~r个数都加d。</p><p>第二类指令形如”Q l r”，表示询问数列中第l~r个数的和。</p><p>分析：区间修改裸题，区间修改时加一个lazy下标即可。</p><h4 id="Billboard"><a href="#Billboard" class="headerlink" title="Billboard"></a><a href="https://vjudge.net/problem/HDU-2795">Billboard</a></h4><p>题意：有一块h <em> w的矩形广告板，要往上面贴广告;然后给n个1 </em> wi的广告，要求把广告贴上去;而且要求广告要尽量往上贴并且尽量靠左;求第n个广告的所在的位置，不能贴则为-1;</p><p>分析：利用线段树可以求区间的最大值;将位置即h用来建树(h&lt;=n,大了没有意义);树中存储的为该位置还拥有的空间;若左子树的最大值大于他,就查询左子树，否则查询右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200010  <span class="comment">//元素总个数</span></span></span><br><span class="line"><span class="type">int</span> A[maxn&lt;&lt;<span class="number">2</span>];<span class="comment">//存原数组数据下标[1,n] </span></span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Build函数建树 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//l,r表示当前节点区间，rt表示当前节点编号</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">A[rt]=w;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="comment">//若到达叶节点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">//左右递归建树 </span></span><br><span class="line"><span class="built_in">Build</span>(l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Build</span>(m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//x表示要查询的值，l,r表示当前节点区间，rt表示当前节点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">A[rt]-=x;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="keyword">if</span>(A[rt&lt;&lt;<span class="number">1</span>]&gt;=x)</span><br><span class="line">&#123;</span><br><span class="line">res=<span class="built_in">Query</span>(x,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">res=<span class="built_in">Query</span>(x,m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">A[rt]=<span class="built_in">max</span>(A[rt&lt;&lt;<span class="number">1</span>],A[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;h,&amp;w,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(h&gt;n)</span><br><span class="line">            h=n;</span><br><span class="line"><span class="built_in">Build</span>(<span class="number">1</span>,h,<span class="number">1</span>);<span class="comment">//从1-h建树，根节点是1 </span></span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(A[<span class="number">1</span>]&lt;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="built_in">Query</span>(x,<span class="number">1</span>,h,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>题意：给定一个字符串(长度&lt;=100000)，有两个操作。   1：改变某个字符。 2：判断某个子串是否构成回文串。  </p><p>分析：直接判断是不是字符串必定超时，所以考虑用线段树维护字符串哈希。对于一个字符串a[0],a[1],…,a[n-1] 它对应的哈希函数为a[0]+a[1]<em>K + a[2]</em>K^2 +…+a[n-1]<em>K^(n-1)。<br>再维护一个从右往左的哈希值：a[0]</em>K^(n-1) + a[1]*K^(n-2) +…+a[n-1]<br>若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。</p><p>若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l , m , rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson m + 1 , r , rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull __int64</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">123</span>;</span><br><span class="line">ull sum[<span class="number">2</span>][maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ull h[maxn],p[maxn];</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span> <span class="params">( <span class="type">int</span> rt , <span class="type">int</span> flag )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[flag][rt] = sum[flag][rt&lt;&lt;<span class="number">1</span>] + sum[flag][rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">( <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> rt , <span class="type">int</span> flag )</span> <span class="comment">//1,n,1,0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[flag][rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( l == r ) </span><br><span class="line">&#123;</span><br><span class="line">        sum[flag][rt] = h[l] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = ( l + r ) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">build</span> ( lson , flag ) ;</span><br><span class="line">    <span class="built_in">build</span> ( rson , flag ) ;</span><br><span class="line">    <span class="built_in">push_up</span> ( rt , flag ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span> <span class="params">( <span class="type">int</span> a , ull b , <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> rt , <span class="type">int</span> flag )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r ) </span><br><span class="line">&#123;</span><br><span class="line">        sum[flag][rt] = b ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = ( l + r ) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> ( a &lt;= m ) </span><br><span class="line"><span class="built_in">update</span> ( a , b , lson , flag ) ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"><span class="built_in">update</span> ( a , b , rson , flag ) ;</span><br><span class="line">    <span class="built_in">push_up</span> ( rt , flag ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b , <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> rt , <span class="type">int</span> flag )</span> <span class="comment">//要查询的范围a,b  从1-n查  根是1  flag判断正反哈希建树 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a &lt;= l &amp;&amp; r &lt;= b ) </span><br><span class="line"><span class="keyword">return</span> sum[flag][rt] ;</span><br><span class="line">    <span class="type">int</span> m = ( l + r ) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    ull ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> ( a &lt;= m ) </span><br><span class="line">ret += <span class="built_in">query</span> ( a , b , lson , flag ) ;</span><br><span class="line">    <span class="keyword">if</span> ( m &lt; b ) </span><br><span class="line">ret += <span class="built_in">query</span> ( a , b , rson , flag ) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i , j , k , m , a , b , c , d ;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">111</span>] ;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span> ( <span class="string">&quot;%s&quot;</span> , s ) != EOF ) <span class="comment">//输入原字符串 </span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">scanf</span> ( <span class="string">&quot;%d&quot;</span> , &amp;m ) ;<span class="comment">//m个操作 </span></span><br><span class="line">        <span class="comment">//哈希 </span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span> ( s ) ;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= len ; i ++ ) </span><br><span class="line">p[i] = p[i<span class="number">-1</span>] * x ;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">            h[i<span class="number">+1</span>] = p[i] * (ull) s[i] ;</span><br><span class="line">        <span class="type">int</span> n = len ;</span><br><span class="line">        <span class="built_in">build</span> ( <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">0</span> ) ;<span class="comment">//flag用于正反哈希的判别 </span></span><br><span class="line">        <span class="built_in">reverse</span> ( s , s + len ) ;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">            h[i<span class="number">+1</span>] = p[i] * (ull) s[i] ;</span><br><span class="line">        <span class="built_in">build</span> ( <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">1</span> ) ;<span class="comment">//反着再哈希一次建树 </span></span><br><span class="line">        <span class="keyword">while</span> ( m -- ) </span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">scanf</span> ( <span class="string">&quot;%s&quot;</span> , op ) ;</span><br><span class="line">            <span class="keyword">if</span> ( op[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> ) </span><br><span class="line">&#123;</span><br><span class="line">                <span class="built_in">scanf</span> ( <span class="string">&quot;%d%d&quot;</span> , &amp;a , &amp;b ) ;</span><br><span class="line">                ull k1 = <span class="built_in">query</span> ( a , b , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">0</span> ) ;</span><br><span class="line">                <span class="type">int</span> l = len - b + <span class="number">1</span> , r = len - a + <span class="number">1</span> ;<span class="comment">//反向哈希之后的a,b  </span></span><br><span class="line">                ull k2 = <span class="built_in">query</span> ( l , r , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">1</span> ) ;</span><br><span class="line">                <span class="type">int</span> t1 = a - <span class="number">1</span> , t2 = len - b ;</span><br><span class="line">                <span class="keyword">if</span> ( t2 &gt; t1 ) </span><br><span class="line">k1 *= p[t2-t1] ;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">k2 *= p[t1-t2] ;</span><br><span class="line">                <span class="keyword">if</span> ( k1 == k2 ) </span><br><span class="line"><span class="built_in">puts</span> ( <span class="string">&quot;Yes&quot;</span> ) ;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line"><span class="built_in">puts</span> ( <span class="string">&quot;No&quot;</span> ) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">                <span class="built_in">scanf</span> ( <span class="string">&quot;%d%s&quot;</span> , &amp;a , op ) ;</span><br><span class="line">                <span class="built_in">update</span> ( a , (ull) p[a<span class="number">-1</span>] * op[<span class="number">0</span>] , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">0</span> ) ;</span><br><span class="line">                <span class="built_in">update</span> ( len - a + <span class="number">1</span> , (ull) p[len-a] * op[<span class="number">0</span>] , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">1</span> ) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一：将问题转换成点信息和目标信息。即，将问题转换成对一些点的信息的统计问题。</p><p>二：将目标信息根据需要扩充成区间信息<br>    1.增加信息符合区间加法。<br>    2.增加标记支持区间操作。</p><p>三：代码中的主要模块：<br>    1.区间加法<br>    2.标记下推<br>    3.点信息-&gt;区间信息<br>    4.操作（各种操作，包括修改和查询）</p><p>完成第一步之后，题目有了可以用线段树解决的可能。<br>完成第二步之后，题目可以由线段树解决。</p><p>第三步就是慢慢写代码了。</p><p>解题模型如图所示：</p><p><img src="https://cos.chdacm.cn//imgs/1565071398804.png" alt="1565071398804"></p><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>线段树的一大应用是扫描线。</p><p><img src="https://cos.chdacm.cn//imgs/1565071440070.png" alt="1565071440070"> </p><p><img src="https://cos.chdacm.cn//imgs/1565071453653.png" alt="1565071453653"></p><p>观察第三个图：<br>扫描线的思路：使用一条垂直于X轴的直线，从左到右来扫描这个图形，明显，只有在碰到矩形的左边界或者右边界的时候，这个线段所扫描到的情况才会改变，所以把所有矩形的入边，出边按X值排序。然后根据X值从小到大去处理，就可以用线段树来维护扫描到的情况。如上图，X1到X8是所有矩形的入边，出边的X坐标。而红色部分的线段，是这样，如果碰到矩形的入边，就把这条边加入，如果碰到出边，就拿走。红色部分就是有线段覆盖的部分。要求面积，只需要知道图中的L1到L8。而线段树就是用来维护这个L1到L8的。</p><p><strong>算法流程：</strong></p><p>X1:首先遇到X1,将第一条线段加入线段树，由线段树统计得到线段长度为L1.</p><p>X2:然后继续扫描到X2,此时要进行两个动作：<br>    1.计算面积，目前扫过的面积=L1*(X2-X1)<br>    2.更新线段。由于X2处仍然是入边，所以往线段树中又加了一条线段，加的这条线段可以参考3幅图中的第一幅。然后线段树自动得出此时覆盖的线段长度为L2 （注意两条线段有重叠部分，重叠部分的长度只能算一次）。</p><p>X3:继续扫描到X3，步骤同X2，先计算 扫过的面积+=L2*(X3-X2)，再加入线段，得到L3。</p><p>X4:扫描到X4有些不一样了。首先还是计算  扫过的面积+=L3*(X4-X3)，然后这时遇到了第一个矩形的出边，这时要从线段树中删除一条线段。删除之后的结果是线段树中出现了2条线段，线段树自动维护这两条线段的长度之和L4。</p><p>思考：线段树进行线段操作时，每个点的含义应该是什么？ </p><p>线段树如果没有离散化，那么线段树下标为1，就代表线段[1,2)<br>线段树下标为K的时候，代表的线段为[K,K+1) （长度为1）<br>所以，将上面的所有线段都化为[y1,y2)就可以理解了，线段[y1,y2)只包括线段树下标中的y1,y1+1,…,y2-1</p><p>当y值的范围是10^9时，就不能再按照上面的办法按值建树了，这时需要离散化。</p><p>其实就是把每条边提前找到存到一个数组里面，让叶子节点维护的不是长度1，而是对应的一个高度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 201</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;<span class="comment">//线段树的左右整点</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//c用来记录重叠情况</span></span><br><span class="line">    <span class="type">double</span> cnt,lf,rf;</span><br><span class="line">    <span class="comment">//cnt用来计算实在的长度，rf,lf分别是对应的左右(上下)真实的浮点数端点 </span></span><br><span class="line">&#125;segTree[MAXN*<span class="number">3</span>];     </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> f;<span class="comment">//入边还是出边，1入，-1出 </span></span><br><span class="line">&#125;line[MAXN];</span><br><span class="line"><span class="comment">//把一段段平行于y轴的线段表示成数组 ，</span></span><br><span class="line"><span class="comment">//x是线段的x坐标，y1,y2线段对应的下端点和上端点的坐标 </span></span><br><span class="line"><span class="comment">//一个矩形 ，左边的那条边f为1，右边的为-1，</span></span><br><span class="line"><span class="comment">//用来记录重叠情况，可以根据这个来计算，nod节点中的c </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Line a,Line b)</span><span class="comment">//sort排序的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> y[MAXN];<span class="comment">//记录y坐标的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//构造线段树，t是当前节点   1,1,t-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    segTree[t].l=l;segTree[t].r=r;</span><br><span class="line">    segTree[t].cnt=segTree[t].c=<span class="number">0</span>;</span><br><span class="line">    segTree[t].lf=y[l];</span><br><span class="line">    segTree[t].rf=y[r];</span><br><span class="line">    <span class="keyword">if</span>(l<span class="number">+1</span>==r)  </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Build</span>(t&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">Build</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid,r);<span class="comment">//递归构造 </span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calen</span><span class="params">(<span class="type">int</span> t)</span><span class="comment">//计算长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(segTree[t].c&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;123&quot;&lt;&lt;endl;</span></span><br><span class="line">        segTree[t].cnt=segTree[t].rf-segTree[t].lf;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(segTree[t].l<span class="number">+1</span>==segTree[t].r)  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;456&quot;&lt;&lt;endl;</span></span><br><span class="line">segTree[t].cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;789&quot;&lt;&lt;endl;</span></span><br><span class="line">segTree[t].cnt=segTree[t&lt;&lt;<span class="number">1</span>].cnt+segTree[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t,Line e)</span><span class="comment">//加入线段e，后更新线段树  1，line[1] </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.y1==segTree[t].lf&amp;&amp;e.y2==segTree[t].rf)<span class="comment">//找到对应的边 </span></span><br><span class="line">    &#123;</span><br><span class="line">        segTree[t].c+=e.f;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;segTree[t].c:&quot;&lt;&lt;segTree[t].c&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">calen</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(e.y2&lt;=segTree[t&lt;&lt;<span class="number">1</span>].rf)  <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.y1&gt;=segTree[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lf)  <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Line tmp=e;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;e.y2:&quot;&lt;&lt;e.y2&lt;&lt;&quot; e.y1:&quot;&lt;&lt;e.y1&lt;&lt;&quot; e.f:&quot;&lt;&lt;e.f&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;tmp.y2:&quot;&lt;&lt;tmp.y2&lt;&lt;&quot; tmp.y1:&quot;&lt;&lt;tmp.y1&lt;&lt;&quot; tmp.f:&quot;&lt;&lt;tmp.f&lt;&lt;endl;</span></span><br><span class="line">        tmp.y2=segTree[t&lt;&lt;<span class="number">1</span>].rf;</span><br><span class="line">        <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,tmp);</span><br><span class="line">        tmp=e;</span><br><span class="line">        tmp.y1=segTree[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lf;</span><br><span class="line">        <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tmp);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;999999999segTree[t].c:&quot;&lt;&lt;segTree[t].c&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">calen</span>(t);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,n,t,Case=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        Case++;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            line[t].x=x1;</span><br><span class="line">            line[t].y1=y1;</span><br><span class="line">            line[t].y2=y2;</span><br><span class="line">            line[t].f=<span class="number">1</span>;<span class="comment">//一开始入边 </span></span><br><span class="line">            y[t]=y1;<span class="comment">//y点坐标 </span></span><br><span class="line">            t++;</span><br><span class="line">            line[t].x=x2;</span><br><span class="line">            line[t].y1=y1;</span><br><span class="line">            line[t].y2=y2;</span><br><span class="line">            line[t].f=<span class="number">-1</span>;<span class="comment">//出边 </span></span><br><span class="line">            y[t]=y2;</span><br><span class="line">            t++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">sort</span>(line<span class="number">+1</span>,line+t,cmp);<span class="comment">//输入完之后根据x坐标对所有的线段排序 </span></span><br><span class="line">        <span class="built_in">sort</span>(y<span class="number">+1</span>,y+t);   <span class="comment">//对y点从小到大排序 </span></span><br><span class="line">        <span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,t<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,line[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;t;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=segTree[<span class="number">1</span>].cnt*(line[i].x-line[i<span class="number">-1</span>].x);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,line[i]);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;</span>,Case,res);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是求所有矩形围成的图形的周长呢？</p><p><img src="https://cos.chdacm.cn//imgs/1565071481570.png" alt="1565071481570"></p><p>这个图是在原来的基础上多画了一些东西，这次是要求周长。<br>所有的横向边都画了紫色，所有的纵向边画了绿色。</p><p>先考虑绿色的边，由图可以观察到，绿色边的长度其实就是L的变化值。<br>比如考虑X1,本来L是0,从0变到L1,所以绿色边长为L1.<br>再考虑X2,由L1变成了L2,所以绿色边长度为L2-L1,<br>于是，绿色边的长度就是L的变化值（注意上图中令L0=0,L9=0）。<br>因为长度是从0开始变化，最终归0.</p><p>再考虑紫色的边，要计算紫色边，其实就是计算L的线段是有几个线段组成的，每个线段会贡献两个端点（紫色圆圈）<br>而每个端点都会向右延伸出一条紫色边一直到下一个X值。</p><p>所以周长就是以上两部分的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> left;</span><br><span class="line">  <span class="type">int</span> right;</span><br><span class="line">  <span class="type">int</span> count;<span class="comment">//被覆盖次数</span></span><br><span class="line">  <span class="type">int</span> line;<span class="comment">//所包含的区间数量</span></span><br><span class="line">  <span class="type">int</span> lbd;<span class="comment">//左端点是否被覆盖</span></span><br><span class="line">  <span class="type">int</span> rbd;<span class="comment">//右端点是否被覆盖</span></span><br><span class="line">  <span class="type">int</span> len;<span class="comment">//长度 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScanLine</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y1;</span><br><span class="line">  <span class="type">int</span> y2;</span><br><span class="line">  <span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> node[LEN*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScanLine</span> scan[LEN];</span><br><span class="line"><span class="type">int</span> y[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i)</span><span class="comment">//0 n-1 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node[i].left = l;</span><br><span class="line">  node[i].right = r;</span><br><span class="line">  node[i].count = <span class="number">0</span>;</span><br><span class="line">  node[i].len = <span class="number">0</span>;</span><br><span class="line">  node[i].line = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (r - l &gt; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, mid, <span class="number">2</span>*i);</span><br><span class="line">    <span class="built_in">build</span>(mid, r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新测度m</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_len</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node[i].count &gt; <span class="number">0</span>)</span><br><span class="line">    node[i].len = y[node[i].right] - y[node[i].left];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">    node[i].len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    node[i].len = node[<span class="number">2</span>*i].len + node[<span class="number">2</span>*i + <span class="number">1</span>].len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新line</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_line</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node[i].count &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    node[i].lbd = <span class="number">1</span>;</span><br><span class="line">    node[i].rbd = <span class="number">1</span>;</span><br><span class="line">    node[i].line = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    node[i].lbd = <span class="number">0</span>;</span><br><span class="line">    node[i].rbd = <span class="number">0</span>;</span><br><span class="line">    node[i].line = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    node[i].lbd = node[<span class="number">2</span>*i].lbd;</span><br><span class="line">    node[i].rbd = node[<span class="number">2</span>*i + <span class="number">1</span>].rbd;</span><br><span class="line">    node[i].line = node[<span class="number">2</span>*i].line + node[<span class="number">2</span>*i + <span class="number">1</span>].line - node[<span class="number">2</span>*i].rbd*node[<span class="number">2</span>*i + <span class="number">1</span>].lbd;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;node[i].lbd:&quot;&lt;&lt;node[i].lbd&lt;&lt;&quot; node[i].rbd:&quot;&lt;&lt;node[i].rbd&lt;&lt;endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i)</span>  <span class="comment">//y1,y2,1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//在这里要取离散化之前的原值进行比较</span></span><br><span class="line">  <span class="keyword">if</span> (y[node[i].left] &gt;= l &amp;&amp; y[node[i].right] &lt;= r)</span><br><span class="line">    (node[i].count)++;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid = (node[i].left + node[i].right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= y[mid])</span><br><span class="line">      <span class="built_in">insert</span>(l, r, <span class="number">2</span>*i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= y[mid])</span><br><span class="line">      <span class="built_in">insert</span>(l, r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">insert</span>(l, y[mid], <span class="number">2</span>*i );</span><br><span class="line">      <span class="built_in">insert</span>(y[mid], r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">update_len</span>(i);</span><br><span class="line">  <span class="built_in">update_line</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//在这里要取离散化之前的原值进行比较</span></span><br><span class="line">  <span class="keyword">if</span> (y[node[i].left] &gt;= l &amp;&amp; y[node[i].right] &lt;= r)</span><br><span class="line">    (node[i].count)--;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid = (node[i].left + node[i].right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= y[mid])</span><br><span class="line">      <span class="built_in">remove</span>(l, r, <span class="number">2</span>*i );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= y[mid])</span><br><span class="line">      <span class="built_in">remove</span>(l, r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">remove</span>(l, y[mid], <span class="number">2</span>*i );</span><br><span class="line">      <span class="built_in">remove</span>(y[mid], r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">update_len</span>(i);</span><br><span class="line">  <span class="built_in">update_line</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> ScanLine line1, <span class="keyword">struct</span> ScanLine line2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (line<span class="number">1.</span>x == line<span class="number">2.</span>x)</span><br><span class="line">    <span class="keyword">return</span> line<span class="number">1.f</span>lag &gt; line<span class="number">2.f</span>lag;</span><br><span class="line">  <span class="keyword">return</span> (line<span class="number">1.</span>x &lt; line<span class="number">2.</span>x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    scan[i].x = x1;</span><br><span class="line">    scan[i].y1 = y1;</span><br><span class="line">    scan[i].y2 = y2;</span><br><span class="line">    scan[i].flag = <span class="number">1</span>;</span><br><span class="line">    y[i++] = y1;</span><br><span class="line">    scan[i].x = x2;</span><br><span class="line">    scan[i].y1 = y1;</span><br><span class="line">    scan[i].y2 = y2;</span><br><span class="line">    scan[i].flag = <span class="number">0</span>;</span><br><span class="line">    y[i++] = y2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(y, y + i);</span><br><span class="line">  <span class="built_in">sort</span>(scan, scan + i, cmp);</span><br><span class="line">  <span class="comment">//y数组中不重复的个数</span></span><br><span class="line">  <span class="type">int</span> unique_count = <span class="built_in">unique</span>(y, y + i) - y;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  for(int i=1;i&lt;n*2;i++)//Y数组去重</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        if(Index[i]!=Index[i-1])</span></span><br><span class="line"><span class="comment">            Index[cnt++]=Index[i-1];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Index[cnt++]=Index[2*n-1];//这里很容易错!</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//离散化，建立线段树</span></span><br><span class="line">  <span class="built_in">build</span>(<span class="number">0</span>, unique_count - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> perimeter = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> now_len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> now_line = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (scan[j].flag)</span><br><span class="line">      <span class="built_in">insert</span>(scan[j].y1, scan[j].y2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">remove</span>(scan[j].y1, scan[j].y2, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">1</span>)</span><br><span class="line">      perimeter += <span class="number">2</span>*now_line*(scan[j].x - scan[j<span class="number">-1</span>].x);</span><br><span class="line">    perimeter += <span class="built_in">abs</span>(node[<span class="number">1</span>].len - now_len);</span><br><span class="line">    now_len = node[<span class="number">1</span>].len;</span><br><span class="line">    now_line = node[<span class="number">1</span>].line;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, perimeter);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><p><img src="https://cos.chdacm.cn//imgs/1565071506572.png" alt="1565071506572"></p><p>笛卡尔树是形如上图的一棵树，满足<br>①堆的性质，如本图，小根堆，两子的值大于等于父亲的值<br>②二叉搜索树性质，即左子树的点key(默认为下标)比根小，右子树的点key(默认为下标)比根大<br>显然，按中序遍历这棵树，可得原序列<br>③询问下标i到下标j之间(i&lt;j)的最小值，只需寻找[i,j]的lca</p><p>可由数列构造，在范围最值查询、范围top k查询(range top k queries)等问题上有广泛应用。它具有堆的有序性，中序遍历可以输出原数列</p><p>笛卡尔树比较难的地方在于构造，这里给出大概的思路。</p><p>笛卡尔树模板：<br>从前往后遍历A[i]，<br>1.对于每一个A[i]，从栈中找出（从栈顶往栈底遍历，或者从数组后往前遍历）第一个小于等于A[i]的元素<br>2.如果找到，i.parent为sta[k],同时sta[k].r=i，即i为sta[k]的右子树,<br>3.如果栈中存在比A[i]大的元素 这些元素肯定是出栈了，这个问题最后的代码统一表示。<br>同时，sta[k+1].parent=i; i.l=sta[k+1] 即sta[K+1]为i的左子树<br>4.最后i入栈，比i大的A[i]都自动出栈了**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxnum=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxnum];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;tree[maxnum];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxnum;i++)</span><br><span class="line">        tree[i].parent=tree[i].l=tree[i].r=<span class="number">-1</span>;  <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Build_Tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,top,k;</span><br><span class="line">    <span class="type">int</span> stack[maxnum];</span><br><span class="line">    top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k=top;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; a[stack[k]]&gt;a[i])  <span class="comment">//栈中比当前元素大的都出栈</span></span><br><span class="line">            k--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">-1</span>)  <span class="comment">//find it，栈中元素没有完全出栈，当前元素为栈顶元素的右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].parent=stack[k];</span><br><span class="line">            tree[stack[k]].r=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;top)    <span class="comment">//出栈的元素为当前元素的左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[stack[k<span class="number">+1</span>]].parent=i;</span><br><span class="line">            tree[i].l=stack[k<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack[++k]=i;<span class="comment">//当前元素入栈</span></span><br><span class="line">        top=k;<span class="comment">//top指向栈顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    tree[stack[<span class="number">0</span>]].parent=<span class="number">-1</span>;<span class="comment">//遍历完成后的栈顶元素就是根</span></span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node!=<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">inorder</span>(tree[node].l);</span><br><span class="line">       cout&lt;&lt;tree[node].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">       <span class="built_in">inorder</span>(tree[node].r);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelorder</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;tree[k].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[k].l!=<span class="number">-1</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(tree[k].l);</span><br><span class="line">        <span class="keyword">if</span>(tree[k].r!=<span class="number">-1</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(tree[k].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        tree[i].key=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root=<span class="built_in">Build_Tree</span>();</span><br><span class="line">    cout&lt;&lt;root&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorder</span>(root);<span class="comment">//中序遍历 </span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">levelorder</span>(root);<span class="comment">//层序遍历 </span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2 4 5 6 8 1 9 1 0 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="例题：牛客多校第一场"><a href="#例题：牛客多校第一场" class="headerlink" title="例题：牛客多校第一场"></a>例题：牛客多校第一场</h3><p>题意：给两个数组a和b，让你找最大的p坐标使得1到p这个范围中，a和b数组里面的最小值的下标一样。</p><p>分析：根据笛卡尔树的性质，那不就是求一个最大的下标p，使得两个序列构建的笛卡尔树同构。问题变得简单清晰，直接二分p坐标即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>; </span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],l[<span class="number">2</span>][maxn],r[<span class="number">2</span>][maxn],rt[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//找最大的p，使得a,b两数组中1-p范围内，最小元素的下标相同 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">di</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[<span class="number">0</span>][i]=r[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((!s.<span class="built_in">empty</span>())&amp;&amp;(a[i]&lt;a[s.<span class="built_in">top</span>()]))<span class="comment">//i对应的元素值最大,a[i]为父节点,小根堆 </span></span><br><span class="line">            l[<span class="number">0</span>][i]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();<span class="comment">//如果a[i]小于根节点，则将a[i]作为根节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="comment">//如果a[i]大于根节点，则从根节点的右节点去找位置 </span></span><br><span class="line">            r[<span class="number">0</span>][s.<span class="built_in">top</span>()]=i;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        rt[<span class="number">0</span>]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[<span class="number">1</span>][i]=r[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((!s.<span class="built_in">empty</span>())&amp;&amp;(b[i]&lt;b[s.<span class="built_in">top</span>()]))</span><br><span class="line">            l[<span class="number">1</span>][i]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">            r[<span class="number">1</span>][s.<span class="built_in">top</span>()]=i;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        rt[<span class="number">1</span>]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//ab两个数组构成的笛卡尔树一样则可以 </span></span><br><span class="line">        <span class="keyword">if</span>(l[<span class="number">0</span>][i]!=l[<span class="number">1</span>][i]||r[<span class="number">0</span>][i]!=r[<span class="number">1</span>][i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        <span class="type">int</span> L=<span class="number">1</span>,R=n;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)<span class="comment">//二分找最大的符合条件的下标 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">di</span>(mid))</span><br><span class="line">            L=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">R=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">di</span>(L))</span><br><span class="line">L--;</span><br><span class="line">        cout&lt;&lt;L&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2018年杭电多校"><a href="#2018年杭电多校" class="headerlink" title="2018年杭电多校"></a>2018年杭电多校</h3><p>题意：定义RMQ(A,l,r)为：序列A中，满足A[i] = max(A[l],A[l+1],…,A[r])的最小的i。如果对于任意(l,r)都满足RMQ(A,l,r)=RMQ(B,l,r)则为A和B是RMQ Similar。现在出A序列，B序列的每个数都是0~1之间的实数，问满足与A是RMQ Similar的所有B序列中所有数之和的期望。</p><p>分析：不难发现，如果A和B是RMQ相似，那么A和B就是笛卡尔树同构。因为B中的每一个数都是 0~1之间的实数，因此出现相同数字的概率可以认为是0，可以假设B是每个数都不相同的排列。设A的笛卡尔树每个子树大小为sz[i]，那么任一B排列和A同构的概率就是sz[i],i从1到n的累乘。又根据题意，B满足均匀分布，因此B的和的期望值是n/2。因此总期望<img src="/.com//posts/1565071537875.png" alt="1565071537875"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">ll inv[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,sz;<span class="comment">//sz表示size,子树大小 </span></span><br><span class="line">    <span class="type">int</span> l,r,par;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        t[i].l=<span class="number">0</span>,t[i].r=<span class="number">0</span>,t[i].par=<span class="number">0</span>,t[i].sz=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">    t[<span class="number">0</span>].val=inf;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;t[st.<span class="built_in">top</span>()].val&lt;t[i].val)<span class="comment">//从栈顶往栈底遍历，</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> par=st.<span class="built_in">top</span>();</span><br><span class="line">        t[i].par=par;<span class="comment">//i.par为st.pop()</span></span><br><span class="line">        t[i].l=t[par].r;<span class="comment">//i的左子树是原来父节点的右节点，因为此点比i先到，且&gt;=i。 </span></span><br><span class="line">        t[t[par].r].par=i;</span><br><span class="line">        t[par].r=i;<span class="comment">//i作为右子树</span></span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//求子树大小 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    t[u].sz=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(t[u].l);</span><br><span class="line">    <span class="built_in">dfs</span>(t[u].r);</span><br><span class="line">    t[u].sz+=t[t[u].l].sz+t[t[u].r].sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inv</span><span class="params">()</span><span class="comment">//扩展gcd求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=inv[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Inv</span>();</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;t[i].val;</span><br><span class="line">        <span class="built_in">build</span>();<span class="comment">//建树 </span></span><br><span class="line">        <span class="built_in">dfs</span>(t[<span class="number">0</span>].r);<span class="comment">//从0节点的右子树开始，计算每个节点的大小 </span></span><br><span class="line"></span><br><span class="line">        ll ans=n*inv[<span class="number">2</span>]%mod;<span class="comment">//以下就是公式的代码表达。 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=ans*inv[t[i].sz]%mod;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>给定一棵二叉树，树上的每个节点带有一个数值，称为节点的关键码。所谓“BST性质”是指，对于树中的任意一个节点：</p><p>​    1.该节点的关键码不小于它的左子树中任意节点的关键码。</p><p>​    2.该节点的关键码不大于它的右子树中任意节点的关键码。</p><p>满足上述性质的二叉树就是一棵“二叉搜索树”。显然，二叉搜索树的中序遍历是一个关键码单调递增的节点序列。</p><h3 id="BST的建立"><a href="#BST的建立" class="headerlink" title="BST的建立"></a>BST的建立</h3><p>为了避免越界，减少边界情况的特殊判断，我们一般在BST中额外插入一个关键码为正无穷和一个关键码为负无穷的节点。仅由这两个节点构成的BST就是一棵初始的空的BST。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BST</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r; <span class="comment">//左右孩子节点在数组中的下标 </span></span><br><span class="line"><span class="type">int</span> val;  <span class="comment">//节点关键码 </span></span><br><span class="line">&#125; a[SIZE]; </span><br><span class="line"><span class="type">int</span> tot, root, INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">New</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[++tot].val = val;</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">New</span>(-INF), <span class="built_in">New</span>(INF);</span><br><span class="line">root = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST的检索"><a href="#BST的检索" class="headerlink" title="BST的检索"></a>BST的检索</h3><p>在BST中检索是否存在关键码为val的节点。设变量p等于根节点root，则执行如下过程：</p><p>1.若p的关键码等于val，则已经找到。</p><p>2.若p的关键码大于val</p><p>​    (1)若p的左子节点为空，则说明不存在val。</p><p>​    (2)若p的左子节点不为空，则p的左子树中递归进行检索。</p><p>3.若p的关键码小于val</p><p>​    (1)若p的右子节点为空，则说明不存在val。</p><p>​    (2)若p的右子节点不为空，在p的右子树中递归检索。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) <span class="comment">//检索失败 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) <span class="comment">// 检索成功 </span></span><br><span class="line"><span class="keyword">return</span> p; </span><br><span class="line"><span class="keyword">return</span> val &lt; a[p].val ? <span class="built_in">Get</span>(a[p].l, val) : <span class="built_in">Get</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST的插入"><a href="#BST的插入" class="headerlink" title="BST的插入"></a>BST的插入</h3><p>在BST中插入一个新的值val(假设目前BST中不存在关键码为val的节点)。那么与BST检索过程类似。</p><p>在发现要走向的p的子节点为空，说明val不存在，直接建立关键码为val的新节点作为p的子节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">p = <span class="built_in">New</span>(val); <span class="comment">// 注意p是引用，其父亲节点的l和r值会被同时更新 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (val &lt; a[p].val) </span><br><span class="line"><span class="built_in">Insert</span>(a[p].l, val);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">Insert</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST求前驱和后继"><a href="#BST求前驱和后继" class="headerlink" title="BST求前驱和后继"></a>BST求前驱和后继</h3><p>以后继为例。val的后继指的是在BST中关键码大于val的前提下，关键码最小的节点。</p><p>初始化ans为具有正无穷关键码的那个节点的编号。然后，在BST中检索val。在检索过程中，没经过一个节点，都检查该节点的关键码，判断能否更新所求的后继ans。</p><p>检索完成后，有三种可能的结果：</p><p>​    1.没有找到val。此时val的后继就在已经经过的节点中，ans即为所求。</p><p>​    2.找到了关键码为val的节点p，但是p没有右子树。与上种情况相同，ans即为所求。</p><p>​    3.找到了关键码为val的节点p，且p有右子树。那就从p的右子树出发，一直向左走就找到了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNext</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">2</span>; <span class="comment">// a[2].val==INF</span></span><br><span class="line"><span class="type">int</span> p = root;</span><br><span class="line"><span class="keyword">while</span> (p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) <span class="comment">// 检索成功 </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (a[p].r &gt; <span class="number">0</span>) <span class="comment">// 有右子树 </span></span><br><span class="line">&#123; </span><br><span class="line">p = a[p].r;</span><br><span class="line"><span class="keyword">while</span> (a[p].l &gt; <span class="number">0</span>) <span class="comment">// 右子树一直向左走 </span></span><br><span class="line">p = a[p].l;</span><br><span class="line">ans = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每经过一个节点，都尝试更新后继</span></span><br><span class="line"><span class="keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) </span><br><span class="line">ans = p;</span><br><span class="line">p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BST的节点删除"><a href="#BST的节点删除" class="headerlink" title="BST的节点删除"></a>BST的节点删除</h3><p>从BST中删除关键码为val的节点。</p><p>首先，在BST中检索val，得到节点p。</p><p>若p的子节点个数小于2，则直接删除p,并令p的子节点 代替p的位置，与p的父节点相连即可。</p><p>若p既有左子树又有右子树，则在BST中求出val的后继节点next。因为next没有左子树，所以可以直接删除next，令next的右子树代替next即可。最后让next代替p节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> val)</span>  <span class="comment">//从子树p中删除值为val的节点 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (val == a[p].val) <span class="comment">// 检索到值为val的节点 </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (a[p].l == <span class="number">0</span>)  <span class="comment">// 没有左子树 </span></span><br><span class="line">&#123;</span><br><span class="line">p = a[p].r; <span class="comment">// 右子树代替p的位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[p].r == <span class="number">0</span>) <span class="comment">//没有右子树 </span></span><br><span class="line">&#123; </span><br><span class="line">p = a[p].l; <span class="comment">// 左子树代替p的位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 既有左子树又有右子树 </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 求后继节点 </span></span><br><span class="line"><span class="type">int</span> next = a[p].r;</span><br><span class="line"><span class="keyword">while</span> (a[next].l &gt; <span class="number">0</span>) </span><br><span class="line">next = a[next].l;</span><br><span class="line"><span class="comment">// next一定没有左子树，直接删除 </span></span><br><span class="line"><span class="built_in">Remove</span>(a[p].r, a[next].val);</span><br><span class="line"><span class="comment">// 令next节点代替p节点 </span></span><br><span class="line">a[next].l = a[p].l, a[next].r = a[p].r;</span><br><span class="line">p = next; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &lt; a[p].val) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Remove</span>(a[p].l, val);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Remove</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在随机数据情况下，BST一次操作的期望复杂度是O(logN)。但是，BST很容易退化，试想如果插入一个有序序列，就会得到一条链，那么平均每次操作的复杂度就是O(N)的，这是我们无法忍受的。这种左右子树大小相差很大的BST是不平衡的。有很多方法可以维持BST的平衡，从而产生了各种平衡树。</p><p>那么欲知后事如何，请听下回分解。treap,splay。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 笛卡尔树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第七讲：动态规划(II)</title>
      <link href="/2019/07/31/DP2/"/>
      <url>/2019/07/31/DP2/</url>
      
        <content type="html"><![CDATA[<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><p> 首先回顾一下位运算</p><ul><li>与 &amp;</li><li>或 |</li><li>异或 ^</li><li>取反 ~</li><li>左移 &lt;&lt;</li><li>右移 &gt;&gt;<blockquote><p>^ 运算的逆运算是它本身</p></blockquote></li></ul><p>取反是对 1 个数 $num$ 进行的计算，~ 把$num$种的0 和 1 全部取反<br>补码——正数的补码是其（二进制) 本身，负数的补码是其（二进制）取反后加一</p><p>右移在C++中将直接舍弃右侧多余位，左侧则较为复杂，无符号数会在左侧补0，对于有符号书，则会用最高位的数补齐<br>[注]：</p><pre><code>1. 左移和右移是有返回值的，并非对$num$本身进行操作2. 左移和右移优先级低于四则运算，`x&lt;&lt;1+1` 会被解释为`x&lt;&lt;(1+1)`，所以一般最好都加上括号</code></pre><p>一些应用</p><ul><li><code>num&lt;&lt;i</code> 相当于$num\times 2^i$ ，而<code>num&gt;&gt;i</code> 相当于$num \div 2^i$ 。效率要比 % 和 / 操作快得多（60%？）<ul><li>当$num&gt;0$时两者并没有差别，但是当$num&lt;0$时，普通除法时向0取整，而右移是向下取整</li></ul></li><li><code>num * 10 = (num &lt;&lt; 1) + (num &lt;&lt; 3)</code></li><li>num &amp; 1 取num二进制末尾，判断奇偶性</li><li>对应于集合上的运算</li></ul><div class="table-container"><table><thead><tr><th>操作</th><th>集合表示</th><th>位运算语句</th></tr></thead><tbody><tr><td>交集</td><td>$a\cap b$</td><td>a&amp;b</td></tr><tr><td>并集</td><td>$a\cup b$</td><td>a</td></tr><tr><td>补集</td><td>$\overline a$</td><td>~a</td></tr><tr><td>差集</td><td>$a\setminus b$</td><td>~a</td></tr><tr><td>对称差</td><td>$a\triangle b$</td><td>a^b</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历一个集合的子集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S0 = S;S0;S0 = (S0<span class="number">-1</span>) &amp; S)</span><br><span class="line"><span class="comment">//取出n二进制下的第k位</span></span><br><span class="line">(n &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line"><span class="comment">//取出整数n在二进制表示下第0~k-1位（后k位</span></span><br><span class="line">n &amp; ((<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>)</span><br><span class="line"><span class="comment">//把整数n在二进制下的第k位取反</span></span><br><span class="line">n ^ (<span class="number">1</span> &lt;&lt; k)</span><br><span class="line"><span class="comment">//对整数 n 在二进制下第k位赋值1</span></span><br><span class="line">n | (<span class="number">1</span> &lt;&lt; k)</span><br><span class="line"><span class="comment">//对整数 n 在二进制表示下第k位赋值0</span></span><br><span class="line">n &amp; (~(<span class="number">1</span> &lt;&lt; k))</span><br><span class="line"><span class="comment">//判断一个数的奇偶性</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isOddNumber</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断一个数是不是2的幂</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFactorialofTwo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了开始正题</p><p>状压DP是DP的一种，通过状态压缩为整数来优化转移<br>直接上题<br><a href="https://loj.ac/problem/2153">题目链接</a><br>在$N\times N$ 的棋盘里面放 $K$个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共$8$ 个格子。<br>$1\le N\le 9,0\le K\le N*N$<br>$f(i,j,l)$来表示前 $i$ 行，当前状态为$j$ ，且已经放置 $l$个国王时的方案。<br>$j$ 这一维用二进制来表示<br>先预处理在一行上的所有合法状态（即排除同一行上两个相邻的情况），然后直接枚举这些来匹配上一行的状态即可。<br>$f(i,j,l) = \sum f(i-1,x,l-num(x))$<br>$num(x)$ 为x在二进制下有多少个1<br>转移时要排除两行间国王互相攻击不合法的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; sta,stan;</span><br><span class="line">ll d[<span class="number">10</span>][(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &amp; j)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((i &lt;&lt; <span class="number">1</span>) &amp; j)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &amp; (j &lt;&lt; <span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; (j<span class="number">+1</span>) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">continue</span>;</span><br><span class="line">        sta.<span class="built_in">push_back</span>(i);</span><br><span class="line">        stan.<span class="built_in">push_back</span>(num + (i &gt;&gt; (n<span class="number">-1</span>) &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sta.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        d[<span class="number">1</span>][i][stan[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;sta.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;sta.<span class="built_in">size</span>();t++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">ok</span>(sta[j],sta[t]))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> p = stan[j];p &lt;= k;p++)&#123;</span><br><span class="line">                        d[i][j][p] += d[i<span class="number">-1</span>][t][p-stan[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sta.<span class="built_in">size</span>();i++)</span><br><span class="line">        res += d[n][i][k];</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>不过瘾就再来一道</p></blockquote><p><strong>Mondriann’s Dream</strong><br>求把$N*M(1\le N,M \le 11)$ 的棋盘分割成若干个$1\times 2$ 的长方形，有多少种方案。例如当 $N=2,M=4$时，共有5种方案。当$N=2,M=3$时，有3种方案。</p><p>NM只有11，八九不离十可以状压了，反正得挨个铺，所以从上到下考虑。假如现在铺好了前$i$ 层，基本思想就是从$i$ 层的状态转移到$i+1$层的状态。但是该如何表示？观察一下铺满第 $i$ 层的样子（必须保证第$i$层是满的，也就是说有的可以凸出来到$i+1$层但是要保证$i$层是满的）<br><img src="https://img2018.cnblogs.com/blog/1447410/201907/1447410-20190730100655184-1295226505.png" alt="enter image description here"><br>对于第 i 行中竖着放的，第 $i+1$ 层要受到牵连，它必须补全竖着放置的上一半才行。但对于横着放的，第$i+1$层则无所谓。<br>所以我们可以用二进制中的 1  来表示他是否是竖着放置的上一半。为0则为其他状况。<br>$d[i][j]$表示第 $i$ 的形态为$j$ 时，前$i$ 行分割方案的总数。 $j$ 是用十进制整数记录的 $m$ 位二进制数。考虑$i+1$行的状态$k$在满足什么情况下转移是合法的。</p><ul><li>$j$中为 1 的位，$k$中必须为0</li><li>$j$中为 0 的位，$k$中可以为1，但 k 要是为 0，就必须是连续的偶数个0（想一想为什么)<br>对于第一条，可以用 $i\&amp;j = 0$ 来判断，对于第二条，有$z = i|j$，那么 z 的二进制表示中，每一段连续的 0 都必须有偶数个。（这些0代表若干个横着的 $1\times 2$ 长方形，奇数个0无法分割成这种形态。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">12</span>][<span class="number">1</span>&lt;&lt;<span class="number">11</span>];</span><br><span class="line"><span class="type">bool</span> in_s[<span class="number">1</span>&lt;&lt;<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n)&#123;</span><br><span class="line">        <span class="comment">//先把合法状态筛出来，即二进制表示中每一段连续的0都有偶数个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">bool</span> cnt = <span class="number">0</span>,has_odd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)has_odd |= cnt,cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt ^= <span class="number">1</span>;</span><br><span class="line">            in_s[i] = (has_odd | cnt) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1</span>&lt;&lt;m;j++)&#123;</span><br><span class="line">                f[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt; <span class="number">1</span>&lt;&lt;m;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; in_s[j|k])</span><br><span class="line">                        f[i][j] += f[i<span class="number">-1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;f[n][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><p>数位DP问题往往是这样的题型，给定一个闭区间$[l,r]$，让你求这个区间中满足某种条件的数的总数<br>又或者是求满足限制条件的第K小的数是多少。</p><ul><li>首先我们将问题转换为更加简单的形式。设$ans<em>i$ 表示$[1,i]$ 中满足条件的数的数量，那么所求的答案就是$ans_r-ans</em>{l-1}$。</li></ul><p>分开求解这两个问题即可。<br>对于一个小于$n$的数，它从高到底肯定出现某一位使得这一位上的数值小于$n$这一位上对应的数值。而之前的所有位都和$n$上的位相等。<br>有了这个性质，我们可以定义$f(i,st,op)$表示当前将要考虑的是从高到低的第$i$位，当前该前缀的状态为$st$（前一位或前几位的值），前缀和当前求解的数字的大小关系是op(op=1表示等于，op=0表示小于）时的数字个数。<br><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1026">题目链接</a></p><p><strong>windy数</strong><br>windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道， 在A和B之间，包括A和B，总共有多少个windy数？$1 \le A \le B \le 2000000000$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll A,B;</span><br><span class="line"><span class="type">int</span> k[<span class="number">20</span>],pos;<span class="comment">//存数字各位</span></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">10</span>];<span class="comment">//第i位为j的数字个数(不能大小限制)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pos : 当前考虑的第pos位，例如十进制数12345,5为第0位</span></span><br><span class="line"><span class="comment">pre : 当前位的前一位的数字</span></span><br><span class="line"><span class="comment">lead ： 是否有前导0，比如之前枚举的两位 00xxx，在枚举3位时是有前导0的。</span></span><br><span class="line"><span class="comment">limit : 是否有大小限制，比如枚举了12xxx,在枚举3位时最大枚举到3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> pre,<span class="type">bool</span> lead,<span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre])<span class="keyword">return</span> dp[pos][pre];</span><br><span class="line">    <span class="type">int</span> up = limit ? k[pos] : <span class="number">9</span>;<span class="comment">//确定枚举上界</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,<span class="literal">false</span>,limit &amp;&amp; i == k[pos]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(i-pre) &lt; <span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,<span class="literal">false</span>,limit &amp;&amp; i == k[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead)dp[pos][pre] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        k[pos++] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;A,&amp;B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(B) - <span class="built_in">solve</span>(A<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Valley Number</strong><br>当一个数字，从左到右依次看过去数字没有出现先递增接着递减的“山峰”现象，就被称作 Valley Number。它可以递增，也可以递减，还可以先递减再递增。在递增或递减的过程中可以出现相等的情况。<br>比如，1，10，12，212，32122都是 Valley Number。<br>121，12331，21212则不是。<br>度度熊想知道不大于N的Valley Number数有多少。<br>注意，前导0是不合法的。<br>每组数据包含一个数N。<br>● 1≤T≤200<br>● 1≤length(N)≤100<br>结果对$1000000007$取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">ll d[<span class="number">101</span>][<span class="number">11</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> k[<span class="number">101</span>],pos;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">减后可以增。增后不能减</span></span><br><span class="line"><span class="comment">status : </span></span><br><span class="line"><span class="comment">    0 不增不减</span></span><br><span class="line"><span class="comment">    1 增</span></span><br><span class="line"><span class="comment">    2 减</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> pre,<span class="type">int</span> status,<span class="type">bool</span> lead,<span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)<span class="keyword">return</span> lead ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!lead &amp;&amp; !limit &amp;&amp; d[pos][pre][status])<span class="keyword">return</span> d[pos][pre][status];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> up = limit ? k[pos] : <span class="number">9</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                (res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">false</span>))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                (res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,<span class="number">0</span>,<span class="literal">false</span>,limit &amp;&amp; i == k[pos]))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; pre)&#123;</span><br><span class="line">                <span class="keyword">if</span>(status == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                (res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,<span class="number">2</span>,<span class="literal">false</span>,limit &amp;&amp; i == k[pos]))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == pre)&#123;</span><br><span class="line">                (res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,status,<span class="literal">false</span>,limit &amp;&amp; i == k[pos]))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                (res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,i,<span class="number">1</span>,<span class="literal">false</span>,limit &amp;&amp; i == k[pos]))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!lead &amp;&amp; !limit) d[pos][pre][status] = res % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)k[pos++] = s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>()%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>POJ-3208 启示录</strong><br>只要某数字的十进制表示中有三个6相邻，则该数字为魔鬼数，求第X小的魔鬼数$X\le 5e7$</p><blockquote><p>这一类题目可以先用DP进行预处理，再基于拼凑思想，用“试填法”求出最终的答案</p></blockquote><p>$F[i,3]$表示由 $i$ 位数字构成的魔鬼数有多少个，$F<a href="0\le j\le 2">i,j</a>$ 表示由 $i$ 位数字构成的，开头已经有连续 $j$ 个6的非魔鬼数有多少个。（允许前导0的存在，想一想为什么）<br>转移方程</p><ol><li>$F[i,0] = 9*(F[i-1,0] + F[i-1,1] + F[i-1,2])$</li><li>$F[i,1] = F[i-1,0]$</li><li>$F[i,2] = F[i-1,1]$</li><li>$F[i,3] = F[i-1,2] + 10 * F[i-1,3]$</li></ol><p>然后一位一位的试填，要注意前面填过的数字结尾如果有 k 个6，通过后面拼接 3-k 个6也可以构成魔鬼数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll f[<span class="number">21</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> T,n,l;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">9</span>*(f[i<span class="number">-1</span>][<span class="number">0</span>] + f[i<span class="number">-1</span>][<span class="number">1</span>] + f[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">        f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        f[i][<span class="number">2</span>] = f[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        f[i][<span class="number">3</span>] = f[i<span class="number">-1</span>][<span class="number">2</span>] + <span class="number">10</span> * f[i<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="comment">//l为答案的长度</span></span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">3</span>;f[l][<span class="number">3</span>] &lt; n;l++);</span><br><span class="line">        <span class="comment">//k表示填过的数字末尾有k个6</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l,k=<span class="number">0</span>;i;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">                ll cnt = f[i<span class="number">-1</span>][<span class="number">3</span>];<span class="comment">//后面预处理出的魔鬼数</span></span><br><span class="line">                <span class="comment">//找能够拼凑出来的魔鬼数</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">6</span> || k == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>;x &lt; <span class="number">3</span>;x++)</span><br><span class="line">                            cnt += f[i<span class="number">-1</span>][x];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="built_in">max</span>(<span class="number">3</span>-k<span class="number">-1</span>, <span class="number">0</span>);x&lt;<span class="number">3</span>;x++)&#123;</span><br><span class="line">                            cnt += f[i<span class="number">-1</span>][x];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; n) n -= cnt;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">3</span>) j == <span class="number">6</span> ? k ++ : k=<span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,j);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>BZOJ1799 月之迷</strong><br>给出两个数a,ba,b，求出$[a,b]$中各位数字之和能整除原数的数的个数。<br>我们按照模板的做法来想，枚举到第pos位时，要确定这一位的数字，可以更新现在所填数字的和，但对于最终的和无从得知，是否能整除也无从判别，我们试着先确定了最终的和，在枚举每一位的时候注意到，枚举x，则对最终和模数可以更新为 $(mod * 10 + x) \% sum$ ，所以可以想到每一次枚举一个和sum<br>$d[i][j][k]$表示 i 位数字，前面填过的数字和为 j 时，模sum为 k 的数字个数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll d[<span class="number">20</span>][<span class="number">160</span>][<span class="number">160</span>],L,R;</span><br><span class="line"><span class="type">int</span> k[<span class="number">20</span>],pos,mod;</span><br><span class="line"><span class="comment">//sum为之前填过的数字的和,p为之后要填的数字对mod的模为p</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> sum,<span class="type">int</span> p,<span class="type">bool</span> lead,<span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">0</span> &amp;&amp; sum == mod)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; d[pos][sum][p] != <span class="number">-1</span>)<span class="keyword">return</span> d[pos][sum][p];</span><br><span class="line">    <span class="type">int</span> up = limit ? k[pos] : <span class="number">9</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= up;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, sum + i, p, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, sum + i, (p * <span class="number">10</span> + i) % mod, <span class="literal">false</span>, limit &amp;&amp; i == k[pos]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>,sum + i, (p * <span class="number">10</span> + i) % mod, <span class="literal">false</span>, limit &amp;&amp; i == k[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; !lead) d[pos][sum][p] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        k[pos++] = x % <span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//mod为当前枚举的和</span></span><br><span class="line">    <span class="keyword">for</span>(mod=<span class="number">1</span>;mod &lt;= pos * <span class="number">9</span>;mod++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        res += <span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;L,&amp;R);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;solve(R)&lt;&lt;&#x27; &#x27; &lt;&lt;solve(L-1)&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(R)-<span class="built_in">solve</span>(L<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><p>直接上题，跟之前的排列组合有比较大的联系</p><p><strong>CF-559C Gerald and Giant Chess</strong><br> 给定一个 $H*W$的棋盘，棋盘上只有$N$ 个格子是黑色的，其他格子都是白色的。<br> 在棋盘左上角有一个卒，每一步可以向右或者向下移动一格，并且不能移动到黑色格子中。求这个卒从左上角移动到右下角，一共有多少种可能的路线<br> $1\le H,W\le 10^5,1\le N\le 2000$ 输出对$10^9+7$取模<br> H，W巨大，普通DP不用想，考虑如何用黑格子计数</p><p> <img src="http://images.cnblogs.com/cnblogs_com/1625--H/1515339/o_QQ%E5%9B%BE%E7%89%8720190730145133.png" alt="黑格子"></p><p> 由组合数学知识可知，从S到T的总路径条数为$C<em>{H+W-2}^{H-1}$，只要减去至少经过一个黑格子的路径条数即为答案。<br> 那么如何不重不漏的计数呢？<br> 考虑每条至少经过一个黑格子的路径所包含的第一个黑格子，以4号黑格子(4,5)为例，从S到4号，总路径条数有$C</em>{4+5-1-1}^{4-1}$条，只要排除掉经过3和经过1的路径条数即为从S到4，不经过黑格子的路径数。如何排除？其实我们之前已经算出来了，在算S到4的不经过黑格子路径条数时，已经分别算过了S到3，S到1的不经过黑格子路径条数，只要分别乘上由3到4，由1到4的所有路径数即可。</p><p>把所有黑色格子按照行列坐标递增的顺序排序，设$f[i]$ 为从S到第 $i$个格子，途中不经过其他黑色格子的路径数</p><script type="math/tex; mode=display">f[i] = C_{x_i-1+y_i-1}^{x_i-1} - \sum_{j=1}^{i-1}f[j]*C_{x_i-x_j+y_i-y_j}^{x_i-x_j},其中x_i\ge x_j,y_i\ge x_j</script><p><strong>在求解计数类动态规划时，通常要找一个“基准点”,围绕这个基准点构造一个不可划分的”整体”,以避免子问题之间的重叠</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line">ll jc[N],inv[N];</span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line">ll f[<span class="number">2010</span>];</span><br><span class="line">pii a[<span class="number">2010</span>];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jc[x] * inv[y] %mod * inv[x-y] % mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>] = <span class="number">1</span>;inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)jc[i] = jc[i<span class="number">-1</span>] * i % mod,inv[i] = <span class="built_in">ksm</span>(jc[i],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;h,&amp;w,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].fi,&amp;a[i].se);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">    a[n<span class="number">+1</span>].fi = h;a[n<span class="number">+1</span>].se = w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">+1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i].fi,y = a[i].se;</span><br><span class="line">        f[i] = <span class="built_in">C</span>(x+y<span class="number">-2</span>,x<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="type">int</span> xj = a[j].fi;</span><br><span class="line">            <span class="type">int</span> yj = a[j].se;</span><br><span class="line">            <span class="keyword">if</span>(xj &gt; x || yj &gt; y)<span class="keyword">continue</span>;</span><br><span class="line">            f[i] = (f[i] - (ll)f[j] * <span class="built_in">C</span>(x-xj+y-yj,x-xj)%mod + mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n<span class="number">+1</span>]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斜率优化DP"><a href="#斜率优化DP" class="headerlink" title="斜率优化DP"></a>斜率优化DP</h2><h3 id="P3195-HNOI2008-玩具装箱TOY"><a href="#P3195-HNOI2008-玩具装箱TOY" class="headerlink" title="P3195 [HNOI2008]玩具装箱TOY"></a>P3195 [HNOI2008]玩具装箱TOY</h3><p><a href="https://www.luogu.org/problemnew/solution/P3195">题目链接</a><br>设$d[i]$为将前 $i$ 个玩具装入箱中所需得最小费用<br>容易得到动态转移方程：</p><script type="math/tex; mode=display">d[i] = min(d[j] + (s[i]-s[j]+i-j-1-L)^2), (j<i)</script><p>其中$s[i] = \sum_1^iC[i]$，普通DP复杂度为$O(n^2)$。经过斜率优化后将变为$O(n)$。<br>仔细观察我们便于表示可以令$f[i] = s[i]+i$<br>那么式子变成了</p><script type="math/tex; mode=display">d[i] = min(d[j] + (f[i]-f[j]-1-L)^2)</script><p>我们讨论$j_1，j_2(1\le j_1&lt; j_2&lt;i)$决策，假设$j_2$要比$j_1$更优，那么有</p><p>$d[j_1] + (f[i] -f[j_1]-1-L)^2 \ge d[j_2]+(f[i]-f[j_2]-1-L)^2$</p><p>展开后得到</p><p>$d[j_1] + f[i]^2 - 2\times f[i]\times (f[j_1]+1+L)+(f[j_1]+1+L)^2 \ge d[j_2]+f[i]^2-2\times f[i]\times (f[j_2]+1+L)+(f[j_2]+1+L)^2$</p><p>移项后可得</p><p>$2\cdot f[i]\ge {d[j_2]+(f[j_2]+1+L)^2-d[j_1]-(f[j_1]+1+L)^2 \over f[j_2]-f[j_1]}$</p><p>令$g[i] = f[i]+1+L$， 则有</p><p>$2\cdot f[i]\ge {(d[j_2]+g[j_2])-(d[j_1]+g[j_1])\over f[j_2]-f[j_1]}$</p><p>所以用一个队列维护决策集，当$j_1&lt;j_2$，并且上式满足时，$j_1$ 出队。<br>又由于$f[i]$随$i$单调递增。所以计算$d[i]$之后要将 $i$ 入队时，要及时排除掉不可能作为决策的元素。<br>如何计算？队尾的斜率也要满足单调性，保持跟$f[i]$的单调性一致即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> db;</span><br><span class="line">db c[N],d[N],f[N],s[N],g[N];</span><br><span class="line"><span class="type">int</span> n,L;</span><br><span class="line"><span class="type">int</span> q[N],l,r;</span><br><span class="line"><span class="function">db <span class="title">sqr</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"><span class="function">db <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((d[i] +  g[i]) - (d[j] + g[j])) / (f[i] - f[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;L);</span><br><span class="line">    l=r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    cin&gt;&gt;c[i];</span><br><span class="line">    s[i]=s[i<span class="number">-1</span>] + c[i];</span><br><span class="line">    f[i] = s[i] + i;</span><br><span class="line">    g[i] = (f[i] + <span class="number">1</span> + L) * (f[i] + <span class="number">1</span> + L);</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">0</span>] = (ll)(<span class="number">1</span>+L)*(<span class="number">1</span>+L);<span class="comment">//注意0号元素的g值初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; <span class="built_in">slope</span>(q[l],q[l<span class="number">+1</span>]) &lt; <span class="number">2</span> * f[i])l++;</span><br><span class="line">        <span class="type">int</span> j = q[l];</span><br><span class="line">        d[i] = d[j] + <span class="built_in">sqr</span>(f[i]-f[j]<span class="number">-1</span>-L);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; <span class="built_in">slope</span>(q[r],q[r<span class="number">-1</span>]) &gt; <span class="built_in">slope</span>(i,q[r<span class="number">-1</span>]))r--;<span class="comment">//满足队尾斜率单调性</span></span><br><span class="line">        q[++r] = i;<span class="comment">//入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ll)d[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2120-ZJOI2007-仓库建设"><a href="#P2120-ZJOI2007-仓库建设" class="headerlink" title="P2120 [ZJOI2007]仓库建设"></a>P2120 [ZJOI2007]仓库建设</h3><p>题意：$1\sim N$ 号工厂，第$i$ 个工厂有$P_i$个成品，第$i$个工厂建立仓库需要$C_i$的费用，该工厂距离第一个工厂的距离为$X_i$，编号小的工厂只能往编号大的工厂搬用成品，每单位成品搬每单位距离需要花费1，问所有成品搬到工厂里面所需的最少费用是多少</p><p>分析<br>设$f[i]$ 为第 i 个工厂建立仓库，前 i 个工厂的成品都搬到仓库中的最小花费，则容易得到动态转移方程:</p><script type="math/tex; mode=display">f[i] = min(f[j] + P_{j+1}(X_i-X_{j+1}) + P_{j+2}(X_i-X_{j+2})+\cdots + P_{i-1}(X_i-X_{i-1}))+C_i</script><p>通式为</p><script type="math/tex; mode=display">f[i]=min(f[j]+\sum_{k=j+1}^{i-1}P_k\cdot X_i-\sum_{k=j+1}^{i-1}P_k\cdot X_k)+C_i</script><p>令 $s[i] = \sum_1^i P[i], ~~g[i] = \sum_1^iP_i\cdot X_i$,<br>则方程变为</p><script type="math/tex; mode=display">f[i] = min(f[j] + X_i\cdot (s[i-1]-s[j])-(g[i-1]-g[j]))+C_i</script><p>则对于最优决策 $j$ ，有</p><script type="math/tex; mode=display">f[j]+g[j]=X_i\cdot s[j]+f[i]-X_i\cdot s[i-1]-C_i</script><p>也就是要找 $y = kx+b$，$k$已知，找一对$x,y$使得截距最小<br>由于$X[i]$是随$i$递增的，所以要维护的决策集的斜率也是递增的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll C[N],P[N],X[N],f[N],s[N],g[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N],l,r;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span> <span class="type">double</span>)((f[i]+g[i]) - (f[j]+g[j]))/(s[i]-s[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;X[i],&amp;P[i],&amp;C[i]);</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + P[i];</span><br><span class="line">        g[i] = g[i<span class="number">-1</span>] + P[i] * X[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l = r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; <span class="built_in">slope</span>(q[l],q[l<span class="number">+1</span>]) &lt;= X[i])l++;</span><br><span class="line">        <span class="type">int</span> j = q[l];</span><br><span class="line">        f[i] = f[j] + (s[i<span class="number">-1</span>] - s[j]) * X[i] - g[i<span class="number">-1</span>] + g[j] + C[i];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; <span class="built_in">slope</span>(q[r<span class="number">-1</span>],q[r]) &gt; <span class="built_in">slope</span>(q[r<span class="number">-1</span>],i))r--;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 状态压缩DP </tag>
            
            <tag> 数位DP </tag>
            
            <tag> 计数DP </tag>
            
            <tag> 斜率优化DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第六讲：动态规划(I)</title>
      <link href="/2019/07/30/DP/"/>
      <url>/2019/07/30/DP/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划（线性，区间，树形）"><a href="#动态规划（线性，区间，树形）" class="headerlink" title="动态规划（线性，区间，树形）"></a>动态规划（线性，区间，树形）</h1><p>对于动态规划 我们所需要确定的肯定就是以下几种元素</p><ol><li><strong>状态（阶段）</strong></li></ol><p>我们确定的状态要保证当前的状态不会对于后面的状态产生影响 这个条件也被叫做无后效性  并且这个状态能够表示出所有的状态</p><p>​    2.<strong>决策</strong></p><p>我们利用什么样的决策从前面一个阶段转移到我当前的阶段过来（可能是前面的阶段去最小值，最大值之类的）</p><p>开始写代码的时候要确定状态的起始条件（也就是边界条件）  再确定状态的最总目标 （也就是我们要求的答案）</p><h2 id="1-线性dp"><a href="#1-线性dp" class="headerlink" title="1.线性dp"></a>1.线性dp</h2><p><strong>具有线性“阶段”划分的动态规划算法被称为线性dp</strong></p><p>题目 1：</p><p>给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为1 * 1或更大的连续子阵列。矩形的总和是该矩形中所有元素的总和。在这个问题中，具有最大和的子矩形被称为最大子矩形。例如，下列数组：</p><p>0 -2 -7 0<br>9 2 -6 2<br>-4 1 -4 1<br>-1 8 0 -2<br>其最大子矩形为：</p><p>9 2<br>-4 1<br>-1 8<br>它拥有最大和15</p><p>对于这个问题 我们当然可以直接暴力枚举这个区间的起始端点和结束端点来求答案，但是这个方案的复杂度太高了，我们可以想到之前做过的<strong>最大的连续子序列和的线性dp来解这道题目</strong> 这道题目只不过是扩大到了二维而已；</p><p>解题思路：我们假设把<strong>每一行和看做一个新的元素</strong> 然后就是二维的降到了一维的 然后在跑一次一维的连续子序列dp 更新一下答案就好了</p><p>具体代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">102</span>][<span class="number">102</span>],sum[<span class="number">102</span>][<span class="number">102</span>],dp[<span class="number">102</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            sum[i][j] = sum[i][j<span class="number">-1</span>] + a[i][j];<span class="comment">// 每一行都当做一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++)<span class="comment">// 这两个for循环枚举区间的左右端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt; <span class="number">102</span> ; p++) dp[p] = <span class="number">-1000</span>;<span class="comment">// 每次dp都需要初始化</span></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">// dp求和</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(sum[i][j] - sum[i][k],dp[i<span class="number">-1</span>] + sum[i][j] - sum[i][k]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,dp[i]); <span class="comment">// 更新答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目2：</p><h3 id="就是给你一个序列-让你求这个序列的最长下降子序列-并且就子序列的方案数-这个方案数对于相同的价格序列需要去重（也就是不能多算）"><a href="#就是给你一个序列-让你求这个序列的最长下降子序列-并且就子序列的方案数-这个方案数对于相同的价格序列需要去重（也就是不能多算）" class="headerlink" title="就是给你一个序列 让你求这个序列的最长下降子序列 并且就子序列的方案数 这个方案数对于相同的价格序列需要去重（也就是不能多算）"></a>就是给你一个序列 让你求这个序列的最长下降子序列 并且就子序列的方案数 这个方案数对于相同的价格序列需要去重（也就是不能多算）</h3><p>这个题目的前半部分求最长下降子序列我们应该都是会求的 但是<strong>后面的计数我们要怎么考虑呢</strong></p><p>计数的话就是从后面开始个g[i] 表示以当前第i位为结尾的最长下降子序列的长度的个数  当满足</p><p>dp[i] = dp[j] + 1  并且 a[j] &gt; a[i]  那么就说明g[i] 可以由 g[j] 转移过来 g[i] += g[j]; <strong>现在考虑怎么去重</strong></p><p>假设我现在有如右一个下降子序列 5 4 3 …. 2 1  那么如果在 3 的后面还有一个3的话 是不是后面的3能够构成的下降子序列我前面的这个3其实也是能够构成的 那么我们去重的话就可以从这里入手 我们设值一个g数组，g[i]表示以i为结尾的最长下降子序列有多少个 这时候从i往前面扫过去 如果前面的a[j] == a[i] 的话 <strong>就把g[j]置为0</strong> 这样就不会出现重复的情况了 简单的来说就是把a[j] 的方案数嫁接到了 a[i] 上面了 <strong>因为序列等效了 就没有必要有g[j]了</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn],dp[maxn],g[maxn]; <span class="comment">// 可以注意一下是倒序的 值相等的f前面有的我后面肯定也有</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; a[j]) dp[i] = <span class="built_in">max</span>(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] == <span class="number">1</span>) g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) <span class="comment">// 防止后面又多算了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] == a[i]) g[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; a[j] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>) g[i] += g[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;g[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i] == ans) cnt += g[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目3：给你一堆箱子的长宽高-问你对多能够利用这些箱子叠的多高-注意就是底面一直要是能够完全覆盖的"><a href="#题目3：给你一堆箱子的长宽高-问你对多能够利用这些箱子叠的多高-注意就是底面一直要是能够完全覆盖的" class="headerlink" title="题目3：给你一堆箱子的长宽高 问你对多能够利用这些箱子叠的多高 注意就是底面一直要是能够完全覆盖的"></a>题目3：给你一堆箱子的长宽高 问你对多能够利用这些箱子叠的多高 注意就是底面一直要是能够完全覆盖的</h3><h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>思路 ：一个箱子可以有六种形态 假设初始给的 x y z 那么我们可以有 x为长 y宽的长方形为底 z为高 的立方体 也可以有以x为长 y为宽的长方形 z为高的长方体 所以共有6种 预先按照 底面的长方形 的长与宽先排序 （如果不排序取的不是最优的） 设dp[i] 表示第i个能够构成的最长高 <strong>边界条件 dp[1] = rec[i].h 最值目标 max(dp[i]) ;转移方程： dp[i] = max(dp[i],dp[j]+rec[i].h);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">&#125;rec[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> <span class="comment">// 将一个长方形的六种状态加入候选集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rec[m].x = a,rec[m].y = b,rec[m].h = c,m++;</span><br><span class="line">    rec[m].x = a,rec[m].y = c,rec[m].h = b,m++;</span><br><span class="line">    rec[m].x = b,rec[m].y = a,rec[m].h = c,m++;</span><br><span class="line">    rec[m].x = b,rec[m].y = c,rec[m].h = a,m++;</span><br><span class="line">    rec[m].x = c,rec[m].y = b,rec[m].h = a,m++;</span><br><span class="line">    rec[m].x = c,rec[m].y = a,rec[m].h = b,m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> <span class="comment">// 按照宽优先排序 然后再长</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x!=b.x)</span><br><span class="line">        <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y&gt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> a,b,c,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(rec,rec+m,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = rec[i].h;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(rec[j].x&gt;rec[i].x&amp;&amp;rec[j].y&gt;rec[i].y)</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+rec[i].h);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: maximum height = &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目-4：-求最长上升公共子序列-并且要求记录所有的路径"><a href="#题目-4：-求最长上升公共子序列-并且要求记录所有的路径" class="headerlink" title="题目 4：  求最长上升公共子序列 并且要求记录所有的路径"></a>题目 4：  求最长上升公共子序列 并且要求记录所有的路径</h3><p>前一问的话我们之前其实是都学过的 这题的难点就是在于后面的求出所有的公共路径的，求公共路径我们需要用到两个辅助数组，这两个数组的作用是一样的，只是作用的串不一样 ， posa [i] [j] 表示第i位之前字符j第一次出现的位置 具体看代码</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[maxn][maxn],posa[maxn][<span class="number">30</span>],posb[maxn][<span class="number">30</span>],tot = <span class="number">0</span>,t_len;</span><br><span class="line"><span class="type">char</span> a[maxn],b[maxn];</span><br><span class="line">string ans[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string s,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == t_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()); <span class="comment">// 因为是从前面往后面找的 所以在这里需要翻转一下</span></span><br><span class="line">        ans[tot++] = s;<span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(a[x] == b[y]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s + a[x], x - <span class="number">1</span>,y - <span class="number">1</span>,len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 两个不相等的话 那么只能从前面相等的部分去找了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[posa[x][i]][posb[y][i]] == len) <span class="comment">//找到前面最近的相同的节点 并且长度等于我接下来的长度</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(s,posa[x][i],posb[y][i],len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); i++) a[i + <span class="number">1</span>] = x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; y.<span class="built_in">size</span>(); j++) b[j + <span class="number">1</span>] = y[j];</span><br><span class="line">    <span class="type">int</span> n = x.<span class="built_in">size</span>(),m = y.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 求最长公共上升子序列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t_len = dp[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 记录i前面离i最近的字符j的位置在哪里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j  = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="string">&#x27;a&#x27;</span> + j) posa[i][j] = i; </span><br><span class="line">            <span class="keyword">else</span> posa[i][j] = posa[i - <span class="number">1</span>][j]; <span class="comment">// 可能为0 也就是没有这个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i] == <span class="string">&#x27;a&#x27;</span> + j) posb[i][j] = i;</span><br><span class="line">            <span class="keyword">else</span> posb[i][j] = posb[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(s,n,m,t_len);</span><br><span class="line">    <span class="built_in">sort</span>(ans,ans + tot); <span class="comment">// 按照升序输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p><strong>区间DP过程大致相同，大都满足第一层循环枚举长度，第二层循环枚举起点。最内层往往有两种形式，第一种是需要在[i,j]中找一个分割点k使得将[i,j]分成[i,k]和[k+1,j]这样两个区间能够得到最优解</strong></p><p><strong>第二种形式是[i,j]可以由[i,j-1]或者[i,j+1]转移过来.重要的是找出新添加的元素（可以是k或者i）与之前那个len-1长度区间的关系</strong></p><p>题目5：多边形游戏”是一款单人益智游戏。</p><p>游戏开始时，给定玩家一个具有N个顶点N条边（编号1-N）的多边形，如图1所示，其中N = 4。</p><p>每个顶点上写有一个整数，每个边上标有一个运算符+（加号）或运算符*（乘号）。</p><p><img src="https://www.acwing.com/media/article/image/2019/01/25/19_5bc58b2420-1179_1.jpg" alt="1179_1.jpg"></p><p>第一步，玩家选择一条边，将它删除。</p><p>接下来在进行N-1步，在每一步中，玩家选择一条边，把这条边以及该边连接的两个顶点用一个新的顶点代替，新顶点上的整数值等于删去的两个顶点上的数按照删去的边上标有的符号进行计算得到的结果。</p><p>下面是用图1给出的四边形进行游戏的全过程。</p><p><img src="https://www.acwing.com/media/article/image/2019/01/25/19_579cb74c20-1179_2.jpg" alt="1179_2.jpg"></p><p>最终，游戏仅剩一个顶点，顶点上的数值就是玩家的得分，上图玩家得分为0。</p><p>请计算对于给定的N边形，玩家最高能获得多少分，以及第一步有哪些策略可以使玩家获得最高得分</p><p>思路：区间dp问题，思路的话就是上面讲的区间dp的第一种形式 我们可以设dp[l] [r] 表示区间能够获得的最大值 那么这个区间肯定是由两个子区间通过两个子区间之间的乘号或者加号连接起来的 <strong>需要在[i,j]中找一个分割点k使得将[i,j]分成[i,k]和[k+1,j]这样两个区间能够得到最优解dp[l] [j]</strong> 不过这个题目因为<strong>有乘号和负数的干扰</strong> 所以我们还是需要记录区间的<strong>最小值</strong>和<strong>最大值</strong>这两个属性 因为区间的最大值可能有两个最大的整数转移过来 也有可能由两个最小的整数相乘转移过来  <strong>环形的处理的话就是将其拆乘一个链。</strong></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MA = <span class="number">1e9</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[maxn];</span><br><span class="line"><span class="type">int</span> num[maxn];</span><br><span class="line"><span class="type">int</span> dpmax[maxn][maxn],dpmin[maxn][maxn];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(dpmax,<span class="number">-128</span>,<span class="built_in">sizeof</span>(dpmax));</span><br><span class="line">    <span class="built_in">memset</span>(dpmin,<span class="number">0x3f3f</span>,<span class="built_in">sizeof</span>(dpmin));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            a[i<span class="number">+2</span>*n] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;num[i];</span><br><span class="line">            num[i<span class="number">+2</span>*n] = num[i];</span><br><span class="line">            dpmin[i][i] = num[i];</span><br><span class="line">            dpmax[i][i] = num[i];</span><br><span class="line">            dpmin[i<span class="number">+2</span>*n][i<span class="number">+2</span>*n] = num[i];</span><br><span class="line">            dpmax[i<span class="number">+2</span>*n][i<span class="number">+2</span>*n] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= <span class="number">2</span>*n; len+=<span class="number">2</span>) <span class="comment">// 枚举区间长度  1 3 5</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len  &lt;= <span class="number">4</span>*n ; l+=<span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = len + l ;<span class="comment">// 枚举左右区间</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt; r; k+=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[k<span class="number">+1</span>]==<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dpmax[l][r] = <span class="built_in">max</span>(dpmax[l][r],dpmax[l][k]+dpmax[k<span class="number">+2</span>][r]); <span class="comment">// 加的话最大值肯定是取最大</span></span><br><span class="line">                    dpmin[l][r] = <span class="built_in">min</span>(dpmin[l][r],dpmin[l][k]+dpmin[k<span class="number">+2</span>][r]); <span class="comment">// 最小值肯定是取最小</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dpmax[l][r] = <span class="built_in">max</span>(dpmax[l][r],dpmax[l][k]*dpmax[k<span class="number">+2</span>][r]); <span class="comment">// *的话有两个方向 一个是最大值 和最大值过来</span></span><br><span class="line">                    dpmax[l][r] = <span class="built_in">max</span>(dpmax[l][r],dpmin[l][k]*dpmin[k<span class="number">+2</span>][r]); <span class="comment">// 还有就是最小值和最小值过来 因为存在负数</span></span><br><span class="line">                    dpmin[l][r] = <span class="built_in">min</span>(dpmin[l][r],dpmin[l][k]*dpmin[k<span class="number">+2</span>][r]); <span class="comment">// 最小的的转移就是最小的最小 还有可能是大的乘以一个负数</span></span><br><span class="line">                    dpmin[l][r] = <span class="built_in">min</span>(dpmin[l][r],dpmax[l][k]*dpmin[k<span class="number">+2</span>][r]); <span class="comment">// 左右两边都转移一下</span></span><br><span class="line">                    dpmin[l][r] = <span class="built_in">min</span>(dpmin[l][r],dpmin[l][k]*dpmax[k<span class="number">+2</span>][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n; i+=<span class="number">2</span>) ret = <span class="built_in">max</span>(ret,dpmax[i][<span class="number">2</span>*n+i<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*n; i+=<span class="number">2</span>) <span class="keyword">if</span>(dpmax[i][<span class="number">2</span>*n+i<span class="number">-2</span>]==ret) ans.<span class="built_in">push_back</span>((i<span class="number">+1</span>)/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="题目6-：-求一个区间有多少个回文子序列-注意子序列是可以不连续的"><a href="#题目6-：-求一个区间有多少个回文子序列-注意子序列是可以不连续的" class="headerlink" title="题目6 ： 求一个区间有多少个回文子序列 注意子序列是可以不连续的"></a>题目6 ： 求一个区间有多少个回文子序列 注意子序列是可以不连续的</h3><p>思路：</p><p>因为是区间dp  那么我们就可以想到用dp[i] [j]来表示区间l到r之间的回文串的个数 边界条件就是l == r 此时dp[l] [r] = 1 对于任意一个区间都有状态转移方程 dp[l] [r] =(dp[l] [r-1] + dp[l+1] [r] - dp[l+1] [r-1] + mod) % mod; 这个式子画一个图 在利用容斥原理就可以的出来 然后就是要特判一下如果s[l] == s[r] 的画 就需要再加上</p><p>dp[l] [r] = (dp[l+1] [r-1] + dp[l] [r] + 1 + mod) % mod;  以为上面的式子成立的花 那么就可以多  dp[l+1] [r-1] 个回文串 加1的话是加上 s[l] 与 s[r] 这两个字符组成的回文串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">10007</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; maxn; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;s.size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt; s.<span class="built_in">size</span>(); len ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l + len &lt; s.<span class="built_in">size</span>(); l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> r = len + l;</span><br><span class="line">                dp[l][r] =(dp[l][r<span class="number">-1</span>] + dp[l<span class="number">+1</span>][r] - dp[l<span class="number">+1</span>][r<span class="number">-1</span>] + mod) % mod; <span class="comment">// 这个区间回文串的个数等于 容斥原理</span></span><br><span class="line">                <span class="keyword">if</span>(s[l] == s[r]) dp[l][r] = (dp[l<span class="number">+1</span>][r<span class="number">-1</span>] + dp[l][r] + <span class="number">1</span> + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目7-有n个人排成一排要上台表演，每个人有一个屌丝值pi。第i个上台表演的人，他的不满意度为-i-1-pi。"><a href="#题目7-有n个人排成一排要上台表演，每个人有一个屌丝值pi。第i个上台表演的人，他的不满意度为-i-1-pi。" class="headerlink" title="题目7 有n个人排成一排要上台表演，每个人有一个屌丝值pi。第i个上台表演的人，他的不满意度为(i-1)*pi。"></a>题目7 有n个人排成一排要上台表演，每个人有一个屌丝值pi。第i个上台表演的人，他的不满意度为(i-1)*pi。</h3><p>现在有一个类似于栈的黑屋子，你可以让某些人进入这个黑屋子。这些人要按照排的顺序来，那么对于排在最前面的人，</p><p>就有两个选择：</p><p>（1）让他直接上台表演；</p><p>（2）让他暂时进黑屋子。</p><h2 id="现在请你选择一个合理的调度顺序，使得最后的总不满意度最小？"><a href="#现在请你选择一个合理的调度顺序，使得最后的总不满意度最小？" class="headerlink" title="现在请你选择一个合理的调度顺序，使得最后的总不满意度最小？"></a>现在请你选择一个合理的调度顺序，使得最后的总不满意度最小？</h2><p>思路：这个可以划分成一个个子区间来求解  设dp[l] [r] 表示l 到 r直接最小的屌丝值为多少，那么我们肯定关心的就是第一个人到底是排在第几位的 如果他排在第k位的话 那么 2 ~（ l + k - 1） 这些人肯定就排在他的前面 就可以再把  2 ~（ l + k - 1）这里人在看成一个子区间来求解 (l + k) ~ r 这些人肯定排在前面的k个人后面 我们就得把前面的k个人对于他们的影响给消除掉 也就是在这个基础上加上 k * (sum[r] - sum[l + k - 1]) 那么对于后面的 (l + k) ~ r这个区间就又可以看成一个子区间来求解</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn  = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[maxn][maxn],sum[maxn],a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = dp[l][r];</span><br><span class="line">    <span class="keyword">if</span>(ans != inf) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= r - l + <span class="number">1</span>;k ++) <span class="comment">// 这个其实可以看作一个个区间的子问题 那么就可以用区间dp来写</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,<span class="built_in">solve</span>(l + <span class="number">1</span>,l + k - <span class="number">1</span>) + (k - <span class="number">1</span>)*a[l] + k * (sum[r] - sum[l + k - <span class="number">1</span>]) + <span class="built_in">solve</span>(l + k,r)); <span class="comment">// 第k个上场的话 产生</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l][r] = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,cas = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cas++;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, cas, <span class="built_in">solve</span>(<span class="number">1</span>,n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1><p>树的特征</p><p>1.N个点 只有N-1条边的无向图</p><p>2.无向图里 任意两点有且只有一条路</p><p>3.一个点只有一个前驱 但可以有多个后继</p><p>4.无向图没有环</p><p>树形DP</p><p>由于树有着天然的递归结构 父子结构 而且它作为一种特殊的图 可以描述许多复杂的信息 因此在树就成了一种很适合DP的框架</p><p>问题：给你一棵树 要求用最少的代价（最大的收益）完成给定的操作</p><p>树形DP 一般来说都是从叶子从而推出根 当然 从根推叶子的情况也有 不过很少（本蒟蒻还没有做到过~）</p><h2 id="一般实现方式-DFS-包括记忆化搜索-，递推等"><a href="#一般实现方式-DFS-包括记忆化搜索-，递推等" class="headerlink" title="一般实现方式: DFS(包括记忆化搜索)，递推等"></a>一般实现方式: DFS(包括记忆化搜索)，递推等</h2><h3 id="题目8："><a href="#题目8：" class="headerlink" title="题目8："></a>题目8：</h3><h3 id="就是给你一棵树，每个节点有一个权重，如果你选择了根节点的话-那么他的子节点就不能再次选择，如果你选择子节点的话那么根节点就不能在选"><a href="#就是给你一棵树，每个节点有一个权重，如果你选择了根节点的话-那么他的子节点就不能再次选择，如果你选择子节点的话那么根节点就不能在选" class="headerlink" title="就是给你一棵树，每个节点有一个权重，如果你选择了根节点的话 那么他的子节点就不能再次选择，如果你选择子节点的话那么根节点就不能在选"></a>就是给你一棵树，每个节点有一个权重，如果你选择了根节点的话 那么他的子节点就不能再次选择，如果你选择子节点的话那么根节点就不能在选</h3><p>如果是<strong>线型的一串一维数组</strong>的话 不能选择相邻的数字 要让选择的数的和最大</p><p>那么就有递推方程dp[i] = max(dp[i-1],dp[i-2] + a[i])</p><p>max里面前一个式子代表我不选a[i] 那么就能从dp[i-1] 转移过来<br>后面一个代表我选了这个 那么就是从dp[i-2] + a[i] 转移过来</p><p>两者取最大值就是我们需要的答案 那么这题的话就可以<strong>用这个思想</strong></p><p>如果我们选择了这个节点的值的话 我们就只能从这个节点出发的下下一层转移了 下一层不能选了</p><p>如果我们不选这个节点 我们直接从下一层节点转移就好了 两者取最大值</p><p>代码如下 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">// 第一个写的代码比较垃圾 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[maxn] , in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 记忆化优化 相当于剪枝了</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[maxn]; <span class="comment">// 记录树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tans = dp[root]; <span class="comment">// 如果前面搜索到了就直接输出就好了</span></span><br><span class="line">    <span class="keyword">if</span>(tans!=<span class="number">0</span>) <span class="keyword">return</span> tans;</span><br><span class="line">    <span class="keyword">if</span>(g[root].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> val[root]; <span class="comment">// 递归到叶子节点直接返回</span></span><br><span class="line">    <span class="type">int</span> ans = val[root] , ans1 = <span class="number">0</span> ;<span class="comment">// ans 代表我选择了这个节点 ans1 代表我不选择这个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; g[root].<span class="built_in">size</span>(); i++) <span class="comment">// 第一层</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; g[g[root][i]].<span class="built_in">size</span>(); j++) </span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="built_in">dfs</span>(g[g[root][i]][j]);<span class="comment">// 那么按照刚才的思路 ans就是从下下一层转移</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans1 += <span class="built_in">dfs</span>(g[root][i]);<span class="comment">// 我不选这个就可以直接从这一层转移</span></span><br><span class="line">            tans = <span class="built_in">max</span>(ans1,ans); <span class="comment">// 两者取一下最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[root] = tans; <span class="comment">// 记忆化 避免很多的多余运算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;u&gt;&gt;v&amp;&amp;u!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        in[u]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root , ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>) root = i; <span class="comment">// 找到根节点开始dfs</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对于树形dp中的换根-二次扫描法-题目一般会让你算出以每一个节点为根的某些值-然后再在这些值中取最大值或者最小值，这时候你就需要找到每个根节点直接的练习，利用第一次dfs出来的数据，再根据节点之间的关系，进行第二次dfs算出以其他节点为根的时候的最大值"><a href="#对于树形dp中的换根-二次扫描法-题目一般会让你算出以每一个节点为根的某些值-然后再在这些值中取最大值或者最小值，这时候你就需要找到每个根节点直接的练习，利用第一次dfs出来的数据，再根据节点之间的关系，进行第二次dfs算出以其他节点为根的时候的最大值" class="headerlink" title="对于树形dp中的换根(二次扫描法) 题目一般会让你算出以每一个节点为根的某些值 然后再在这些值中取最大值或者最小值，这时候你就需要找到每个根节点直接的练习，利用第一次dfs出来的数据，再根据节点之间的关系，进行第二次dfs算出以其他节点为根的时候的最大值"></a>对于树形dp中的换根(二次扫描法) 题目一般会让你算出以每一个节点为根的某些值 然后再在这些值中取最大值或者最小值，这时候你就需要找到每个根节点直接的练习，利用第一次dfs出来的数据，再根据节点之间的关系，进行第二次dfs算出以其他节点为根的时候的最大值</h2><h3 id="题目9：首先给你一颗树-树的叶子节点就是汇点，就是可以无穷尽的流出水量，每条边有一个权值说明这条边的最大能够流出的水量，现在让你选择一个根节点，也就是源点，源点可以流出无穷多的水量，问你选择那一个节点为源点能够让流出的总水量最大。"><a href="#题目9：首先给你一颗树-树的叶子节点就是汇点，就是可以无穷尽的流出水量，每条边有一个权值说明这条边的最大能够流出的水量，现在让你选择一个根节点，也就是源点，源点可以流出无穷多的水量，问你选择那一个节点为源点能够让流出的总水量最大。" class="headerlink" title="题目9：首先给你一颗树 树的叶子节点就是汇点，就是可以无穷尽的流出水量，每条边有一个权值说明这条边的最大能够流出的水量，现在让你选择一个根节点，也就是源点，源点可以流出无穷多的水量，问你选择那一个节点为源点能够让流出的总水量最大。"></a>题目9：首先给你一颗树 树的叶子节点就是汇点，就是可以无穷尽的流出水量，每条边有一个权值说明这条边的最大能够流出的水量，现在让你选择一个根节点，也就是源点，源点可以流出无穷多的水量，问你选择那一个节点为源点能够让流出的总水量最大。</h3><p>思路：dfs+换根 因为这个题目是让你选择一个节点，然后这个根节点的出水量最大，如果你每一个节点每一个节点的去dfs一次的话，时间复杂度肯定是爆炸的，其实我们可以找规律，然后利用一次dfs进行第二次dfs算出来的值推出用其他节点做为源点（也就是根节点）是的最大流水，也就是二次扫描。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll t_ans = <span class="number">0</span>;</span><br><span class="line">ll sz[maxn];</span><br><span class="line"></span><br><span class="line">vector&lt; pair&lt;<span class="type">int</span>,ll&gt; &gt; g[maxn]; <span class="comment">// 第一个为u节点 第二个为权值</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs1</span><span class="params">(<span class="type">int</span> son,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[son].<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> inf;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[son].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = g[son][i].first;</span><br><span class="line">        ll w = g[son][i].second;</span><br><span class="line">        <span class="keyword">if</span>(u==fa) <span class="keyword">continue</span>;</span><br><span class="line">        ll temp = <span class="built_in">dfs1</span>(u,son);</span><br><span class="line">        sum += <span class="built_in">min</span>(w,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    sz[son] = sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> son,<span class="type">int</span> fa,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[son].<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    t_ans = <span class="built_in">max</span>(t_ans,val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[son].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = g[son][i].first;</span><br><span class="line">        <span class="keyword">if</span>(u==fa || g[u].<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ll w = g[son][i].second;</span><br><span class="line">        ll temp = sz[u] + <span class="built_in">min</span>(w,val - <span class="built_in">min</span>(w,sz[u]));</span><br><span class="line">        <span class="built_in">dfs2</span>(u,son,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        t_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;</span><br><span class="line">            ll w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            g[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,w));</span><br><span class="line">            g[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u,w));</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>,ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,t_ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目10：-就是问你以每个节点为根的树离叶子节点最长的距离是多少，一次输出每一个节点的距离"><a href="#题目10：-就是问你以每个节点为根的树离叶子节点最长的距离是多少，一次输出每一个节点的距离" class="headerlink" title="题目10： 就是问你以每个节点为根的树离叶子节点最长的距离是多少，一次输出每一个节点的距离"></a>题目10： 就是问你以每个节点为根的树离叶子节点最长的距离是多少，一次输出每一个节点的距离</h3><p>思路 ：dfs + 换根 也就是二次dfs扫描 不过这个题目需要记录一个最大值和次大值才能完成二次dfs</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> e[maxn],ne[maxn],idx,h[maxn],val[maxn];</span><br><span class="line"><span class="type">int</span> szma[maxn],szmi[maxn],in[maxn],t_ans[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],val[idx] = w,h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    szma[now] = <span class="number">0</span>,szmi[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[now]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i],w = val[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> ne_ma = <span class="built_in">dfs1</span>(j,now);</span><br><span class="line">        <span class="keyword">if</span>(szma[now] &lt;= w + ne_ma)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = szma[now];</span><br><span class="line">            szma[now] = w + ne_ma; <span class="comment">// 更新最大值</span></span><br><span class="line">            szmi[now] = temp; <span class="comment">// 更新次大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w + ne_ma &lt; szma[now] &amp;&amp; w + ne_ma &gt;= szmi[now]) szmi[now] = ne_ma + w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> szma[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa,<span class="type">int</span> mid,<span class="type">int</span> mid2)</span> <span class="comment">// 传入一个最大的和次二大的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[now]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i],w = val[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> tempmid = mid,tempmid2 = mid2;</span><br><span class="line">        <span class="keyword">if</span>(tempmid != szma[j] + w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(szma[j] &lt; tempmid + w)</span><br><span class="line">            &#123;</span><br><span class="line">                tempmid2 = szma[j];</span><br><span class="line">                tempmid = tempmid + w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tempmid2 = <span class="built_in">max</span>(tempmid + w,szmi[j]);</span><br><span class="line">                tempmid = szma[j];</span><br><span class="line">            &#125;</span><br><span class="line">            t_ans[j] = tempmid;</span><br><span class="line">            <span class="built_in">dfs2</span>(j,now,t_ans[j],tempmid2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(szma[j] &gt; tempmid2 + w) <span class="comment">// 是由我这个更新过来的</span></span><br><span class="line">            &#123;</span><br><span class="line">                tempmid2 = <span class="built_in">max</span>(szmi[j],tempmid2 + w);</span><br><span class="line">                tempmid = szma[j];</span><br><span class="line">                t_ans[j] = tempmid;</span><br><span class="line">                <span class="built_in">dfs2</span>(j,now,t_ans[j],tempmid2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// szma[j] &lt;= tempmid2 + w;</span></span><br><span class="line">            &#123;</span><br><span class="line">                tempmid = tempmid2 + w;</span><br><span class="line">                tempmid2 = szma[j];</span><br><span class="line">                t_ans[j] = tempmid;</span><br><span class="line">                <span class="built_in">dfs2</span>(j,now,t_ans[j],tempmid2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ne[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) h[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) e[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) t_ans[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) val[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) szma[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) szmi[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;w);</span><br><span class="line">        <span class="built_in">add</span>(i,u,w);</span><br><span class="line">        <span class="built_in">add</span>(u,i,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    t_ans[<span class="number">1</span>] = ans;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>,ans,szmi[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t_ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目11：-给你一颗树-让你任选一个节点为根节点-你要最大化所有子树的顶点数之和-让你输出这个最大值"><a href="#题目11：-给你一颗树-让你任选一个节点为根节点-你要最大化所有子树的顶点数之和-让你输出这个最大值" class="headerlink" title="题目11： 给你一颗树 让你任选一个节点为根节点 你要最大化所有子树的顶点数之和 让你输出这个最大值"></a>题目11： 给你一颗树 让你任选一个节点为根节点 你要最大化所有子树的顶点数之和 让你输出这个最大值</h3><p>思路： dfs加换根 到时候具体画图来解释</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line">ll sz[maxn],ans = <span class="number">0</span>,n;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> son,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[son].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = g[son][i];</span><br><span class="line">        <span class="keyword">if</span>(u==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(u,son);</span><br><span class="line">        sz[son] += sz[u];</span><br><span class="line">    &#125;</span><br><span class="line">    sz[son] += <span class="number">1</span>;</span><br><span class="line">    ans += sz[son];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> son,<span class="type">int</span> fa,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[son].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = g[son][i];</span><br><span class="line">        <span class="keyword">if</span>(u==fa) <span class="keyword">continue</span>;</span><br><span class="line">        ll mid = val - sz[u] + n - sz[u]; <span class="comment">// 左子树的大小是等于 n - sz[u]的</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,mid);</span><br><span class="line">        <span class="built_in">dfs2</span>(u,son,mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>,ans);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;sz[1]&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第五讲：基础数据结构</title>
      <link href="/2019/07/30/datastruct/"/>
      <url>/2019/07/30/datastruct/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><pre><code> 栈（Stack）又称堆栈，它是一种运算受限的线性表，其限制是仅允许在表的一端进行插入和删除运算。人们把此端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对地，把另一端称为栈底。向一个栈插入新元素又称为进栈或入栈，它是把该元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称为出栈或退栈，它是把栈顶元素删除掉，使其下面的相邻元素成为新的栈顶元素。 </code></pre><h3 id="2-栗子"><a href="#2-栗子" class="headerlink" title="2.栗子"></a>2.栗子</h3><p>​    放盘子，装东西….</p><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h3><p>​    实现一般有两种：第一种用一个数组和一个变量（栈顶指针）来实现。第二种用STL自带的stack。</p><p>​    常规操作：</p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">s.push(10);//入栈</span><br><span class="line">cout&lt;&lt;s.size()&lt;&lt;endl;//栈大小</span><br><span class="line">int t=s.top();//栈顶元素</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">s.pop();//出栈</span><br><span class="line">if(s.empty())//判断栈是否为空</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 </p><h3 id="2-例子"><a href="#2-例子" class="headerlink" title="2.例子"></a>2.例子</h3><p>​    排队….</p><h3 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3.实现"></a>3.实现</h3><p>​    和栈一样，一般同样有两种方法。第一种用一个数组和两个变量（分别表示队头和队尾）来模拟。第二种方法，同样利用STL的queue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">q.push(10);//入队</span><br><span class="line">q.push(20);</span><br><span class="line">cout&lt;&lt;q.size()&lt;&lt;endl;//队列大小</span><br><span class="line">int t=q.front();//队头</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">t=q.back();//队尾</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">q.pop();//出队</span><br><span class="line">if(q.empty())//判断队是否为空</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;empty&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-特殊"><a href="#4-特殊" class="headerlink" title="4.特殊"></a>4.特殊</h3><p>​    <strong>双端队列：Deque是一种具有队列和栈的性质的数据结构.双端队列中的元素可以从两端弹出,其限定插入和删除操作在表的两端进行.</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">/*--1--*--*--定义初始化队列_使用赋值操作--*--*--*/ </span><br><span class="line">deque&lt;char&gt; str(10,&#x27;A&#x27;);//10个char型的A </span><br><span class="line">deque&lt;char&gt; str1;</span><br><span class="line">str1=str;//重载赋值符号 </span><br><span class="line"> </span><br><span class="line">/*--2 --*--*--定义迭代器，遍历_基础 队列str --*--*--*/ </span><br><span class="line">deque&lt;char&gt;::iterator it;</span><br><span class="line">for(it=str1.begin();it!=str1.end();it++)//遍历 </span><br><span class="line">cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">/*--3--*--*--对容器 判空、清除、获取长度 --*--*--*/ </span><br><span class="line">bool idempty=str1.empty();</span><br><span class="line">if(idempty)</span><br><span class="line">cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">int temp_len1 =str1.size();</span><br><span class="line">cout&lt;&lt;temp_len1&lt;&lt;&quot;\n&quot;; </span><br><span class="line">str1.clear();//清空队列 </span><br><span class="line">if(str1.empty())</span><br><span class="line">cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line"> </span><br><span class="line">/*-------以下-对容器中的元素--获取--修改--插入--删除--遍历---------------------*/</span><br><span class="line"> </span><br><span class="line">/*--1--*--*--数组下标操作符重载 --*--*--*/</span><br><span class="line">deque&lt;int&gt;d1(10,1);//定义+初始化 </span><br><span class="line">int i1=d1[1];</span><br><span class="line">cout&lt;&lt;&quot;i1=&quot;&lt;&lt;i1&lt;&lt;endl; </span><br><span class="line">int first=d1[0];</span><br><span class="line">cout&lt;&lt;&quot;first=&quot;&lt;&lt;first&lt;&lt;endl;</span><br><span class="line">first=d1.front();</span><br><span class="line">cout&lt;&lt;&quot;first=&quot;&lt;&lt;first&lt;&lt;endl;</span><br><span class="line">/*--1&#x27;--*--*--获取和修改容器元素 --*--*--*/</span><br><span class="line">d1.at(3)=4;</span><br><span class="line">int i2=d1.at(3);</span><br><span class="line">cout&lt;&lt;&quot;i2= &quot;&lt;&lt;i2&lt;&lt;&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">/*--2--*--*--尾部--插入元素，删除元素 --*--*--*/</span><br><span class="line">    deque&lt;int&gt;::iterator it1;//定义迭代器，注意迭代器的类型 </span><br><span class="line">    </span><br><span class="line">d1.push_back(&#x27;C&#x27;);//后进或删除 </span><br><span class="line">for(it1=d1.begin();it1&lt;d1.begin()+11;it1++)</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;*it1&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">d1.pop_back();</span><br><span class="line"></span><br><span class="line">/*--3--*--*--头部--插入元素，删除元素--*--*--*/</span><br><span class="line">d1.push_front(404);//注意这里符合栈 </span><br><span class="line">d1.push_front(666);</span><br><span class="line">d1.pop_front();</span><br><span class="line">for(it1=d1.begin();it1!=d1.end();it1++)</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;*it1&lt;&lt;&quot; &quot;; </span><br><span class="line">d1.push_front(&#x27;45&#x27;) ;</span><br><span class="line">cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">/*--4--*--*--获取--头部和尾部元素 --*--*--*/</span><br><span class="line">int start1=d1.front();</span><br><span class="line">int end1=d1.back();</span><br><span class="line">cout&lt;&lt;&quot;star1= &quot;&lt;&lt;start1&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;end1= &quot;&lt;&lt;end1&lt;&lt;&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">/*--5--*--*--任意位置--插入、删除元素--*--*--*/</span><br><span class="line">str1.insert(str1.begin()+4,&#x27;x&#x27;);</span><br><span class="line">for(it=str1.begin();it!=str1.end();it++)</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-应用"><a href="#5-应用" class="headerlink" title="5.应用"></a>5.应用</h3><p>​    一般来说队列应用感觉更广一点，宽搜，spfa，树的层序遍历…</p><h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    二叉堆是一种支持插入，删除，查询最值的数据结构。是一棵满足堆性质的完全二叉树，书上的每一个节点带有一个权值。若树中的任意一个节点的权值都小于等于其父节点的权值，则称该二叉树满足大根堆性质。若任意一个节点的权值都大于等于其父节点的权值，则称该二叉树满足小根堆性质。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>​    一般来说，还是两种实现方式。第一种，数组模拟，根据二叉树的性质，父节点的编号等于子节点的编号/2，左孩子的节点等于父节点编号 <em> 2，右孩子的节点等于父节点编号 </em> 2+1。但是需要考虑还有三种基本操作要满足。即插入元素，移除堆顶，删除元素。</p><pre><code> 这里就手撕一下二叉堆的几个操作：</code></pre><p><strong>插入元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int heap[SIZE],n;</span><br><span class="line"></span><br><span class="line">void up(int p)//向上调 </span><br><span class="line">&#123;</span><br><span class="line">while(p&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">if(heap[p]&gt;heap[p/2])//子节点&gt;父节点，不满足大根堆的性质 </span><br><span class="line">&#123;</span><br><span class="line">swap(heap[p],heap[p/2]);</span><br><span class="line">p/=2;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(int val)</span><br><span class="line">&#123;</span><br><span class="line">heap[++n]=val;</span><br><span class="line">up(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取堆顶：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int GetTop()</span><br><span class="line">&#123;</span><br><span class="line">return heap[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除堆顶：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void down(int p)</span><br><span class="line">&#123;</span><br><span class="line">int s=p*2;//p的左孩子 </span><br><span class="line">while(s&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">if(s&lt;n&amp;&amp;heap[s]&lt;heap[s+1])//先左右节点去较大值 </span><br><span class="line">s++;</span><br><span class="line">if(heap[s]&gt;heap[p])//子节点&gt;父节点，不满足大根堆性质 </span><br><span class="line">&#123;</span><br><span class="line">swap(heap[s],heap[p]);</span><br><span class="line">p=s,s=p*2;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Extract()</span><br><span class="line">&#123;</span><br><span class="line">heap[1]=heap[n--];</span><br><span class="line">down(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Remove(int k)//和移除堆顶类似，先heap[p]和heap[n]交换，然后n--，然后可能向上调整，可能向下调整，都跑一下。 </span><br><span class="line">&#123;</span><br><span class="line">heap[k]=heap[n--];</span><br><span class="line">up(k);</span><br><span class="line">down(k);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>第二种，你们懂得。STL~。优先队列，priority_queue（优先队列)。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    可以支持在任意位置插入或删除，但只能按顺序依次访问其中的元素的一种数据结构。和数组可以鲜明对比：数组支持随机访问但不支持在任意位置插入或删除元素。</p><h3 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h3><p>​    一般来说，三种实现，两种是自己写的，第一种，动态分配内存，指针等实现。第二种，结构体数组模拟。第三种，STL的list。</p><p>这里只给出第一种和第二种的实现代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int value;//数据 </span><br><span class="line">node *prev,*next;//指针 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node *head,*tail;</span><br><span class="line">void initialize()//新建链表</span><br><span class="line">&#123;</span><br><span class="line">head=new node();</span><br><span class="line">tail=new node();</span><br><span class="line">head-&gt;next=tail;</span><br><span class="line">tail-&gt;prev=head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(node *p,int val)//在p后插入包含数据val的新节点 </span><br><span class="line">&#123;</span><br><span class="line">q=new node();</span><br><span class="line">q-&gt;value=val;</span><br><span class="line">p-&gt;next-&gt;prev=q;</span><br><span class="line">q-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">q-&gt;prev=p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void remove(node *p)//删除p </span><br><span class="line">&#123;</span><br><span class="line">p-&gt;prev-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prev=p-&gt;prev;</span><br><span class="line">delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recycle()//链表内存回收 </span><br><span class="line">&#123;</span><br><span class="line">while(head!=tail)</span><br><span class="line">&#123;</span><br><span class="line">head=head-&gt;next;</span><br><span class="line">delete head-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line">delete tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">int value;</span><br><span class="line">int prev,next;</span><br><span class="line">&#125;node[SIZE];</span><br><span class="line">int head,tail,tot;</span><br><span class="line">int initialize()</span><br><span class="line">&#123;</span><br><span class="line">tot=2;</span><br><span class="line">head=1,tail=2;</span><br><span class="line">node[head].next=tail;</span><br><span class="line">node[tail].prev=head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int insert(int p,int val)</span><br><span class="line">&#123;</span><br><span class="line">q=++tot;</span><br><span class="line">node[q].value=val;</span><br><span class="line">node[node[p].next].prev=q;</span><br><span class="line">node[q].next=node[p].next;</span><br><span class="line">node[p].next=q;</span><br><span class="line">node[q].prev=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int p)</span><br><span class="line">&#123;</span><br><span class="line">node[node[p].prev].next=node[p].next;</span><br><span class="line">node[node[p].next].prev=node[p].prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear()//数组模拟链表清空 </span><br><span class="line">&#123;</span><br><span class="line">memset(node,0,sizeof(node));</span><br><span class="line">head=tail=tot=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h3 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h3><p>单调栈是指一个栈内部的元素是具有严格单调性的一种数据结构，分为单调递增栈和单调递减栈。 </p><h3 id="2-性质"><a href="#2-性质" class="headerlink" title="2.性质"></a>2.性质</h3><p>1.满足从栈顶到栈底的元素具有严格的单调性</p><p>2.满足栈的后进先出特性越靠近栈底的元素越早进栈</p><h3 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h3><h2 id="Feel-Good"><a href="#Feel-Good" class="headerlink" title="Feel Good"></a><a href="https://vjudge.net/problem/POJ-2796">Feel Good</a></h2><p>题意：一个长度为n的序列，对于一个区间中的value为这个区间的最小值乘上这个区间的所有数的和 ，求所有value里面的最大值。</p><p>思路：将序列中的每一个元素假定为最小值，向左右扩展，求出每一个元素能到达的l,r,用一个单调递增栈维护即可。对于每一个新元素a[i]，当前值小于等于栈顶元素，表示以栈顶元素为最小值的区间的右端是i，栈顶元素a[j]出栈 ， 由于是单调递增栈，新的栈顶元素a[k]必然小于a[j]，故需要更新新的栈顶元素的，右端值，新元素的左端的值也要更新为a[j]的左端，一直重复操作直到栈顶元素大于新元素，这样这个栈的每一个元素出栈时其左右区间必然是刚好最大的以该元素为最小值的区间。时间复杂度O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll ;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l , r ;</span><br><span class="line">    ll num ;</span><br><span class="line">&#125;s[maxn] ;</span><br><span class="line">ll a[maxn] ;</span><br><span class="line">ll sum[maxn] ;</span><br><span class="line">ll ans ;</span><br><span class="line"><span class="type">int</span> ans_l , ans_r ;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = s[top].l , r = s[top].r ;</span><br><span class="line">    <span class="keyword">if</span>((sum[r] - sum[l<span class="number">-1</span>])*s[top].num &gt; ans)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = (sum[r] - sum[l<span class="number">-1</span>])*s[top].num ;</span><br><span class="line">        ans_l = l ;</span><br><span class="line">        ans_r = r ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top &gt; <span class="number">0</span>)</span><br><span class="line">    s[top<span class="number">-1</span>].r = s[top].r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n ;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">-1</span> ;</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span> , &amp;a[i]) ;</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>]+a[i];<span class="comment">//前缀和 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node v = &#123;i , i ,a[i]&#125;;</span><br><span class="line">            <span class="keyword">while</span>(top != <span class="number">-1</span> &amp;&amp; s[top].num &gt;= a[i])<span class="comment">//栈顶小，满足单调递增栈 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">update</span>(top) ;</span><br><span class="line">                v.l = s[top].l ;</span><br><span class="line">                top-- ;</span><br><span class="line">            &#125;</span><br><span class="line">            s[++top].l = v.l ;<span class="comment">//入栈 </span></span><br><span class="line">            s[top].r = v.r ;</span><br><span class="line">            s[top].num = v.num ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span>)<span class="comment">//如果最后栈非空，一边出栈，一边更新值。 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(top);</span><br><span class="line">            top-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span> , ans) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans_l , ans_r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="那么问题来了，有正有负怎么办？？"><a href="#那么问题来了，有正有负怎么办？？" class="headerlink" title="那么问题来了，有正有负怎么办？？"></a>那么问题来了，有正有负怎么办？？</h3><p><a href="https://nanti.jisuanke.com/t/38228%E5%8D%97%E6%98%8C%E7%BD%91%E7%BB%9C%E9%82%80%E8%AF%B7%E8%B5%9B%E9%A2%98%EF%BC%8C%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%B4%E6%8A%A4%EF%BC%8CI%E9%A2%98%E5%8F%98%E7%A7%8D">https://nanti.jisuanke.com/t/38228</a> 南昌网络邀请赛~</p><p>题意几乎一样，只是序列中的元素可正可负，怎么处理？</p><p>思路：正数同理，负数的话，让左边界到当前元素的值尽可能大，右边界到当前元素的值尽可能小。那么右-左最小，得出的值最大。</p><h2 id="Largest-Rectangle-in-a-Histogram"><a href="#Largest-Rectangle-in-a-Histogram" class="headerlink" title="Largest Rectangle in a Histogram"></a><a href="https://vjudge.net/problem/POJ-2559">Largest Rectangle in a Histogram</a></h2><p> 题意：柱状图是由一些宽度相等的长方形下端对齐后横向排列得到的图形。现在有n个宽度为1，<br>高度分别为h1,h2…,hn的长方形从左到右依次排列组成的柱状图。问里面包含的长方形的最大面积是多少.</p><p>分析：可以枚举每一个长方形的高度，作为组合后的长方形的高度。那么我们需要找到这个长方形，然后求出能够向左右两边延伸的长度。找左右边界的时候，需要用到单调栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span><span class="number">+100</span>;</span><br><span class="line">LL ll [MAXN];</span><br><span class="line">LL rr[MAXN];</span><br><span class="line">LL a[MAXN];</span><br><span class="line">LL n;</span><br><span class="line">LL maxx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">     maxx=<span class="number">0</span>;</span><br><span class="line">     stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(S.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">           ll[i]=<span class="number">1</span>;<span class="comment">//左界 </span></span><br><span class="line">           S.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k=S.<span class="built_in">top</span>();</span><br><span class="line">           <span class="keyword">while</span>(a[k]&gt;=a[i])<span class="comment">//单调栈，单调递减栈 </span></span><br><span class="line">           &#123;</span><br><span class="line">              rr[k]=i;<span class="comment">//k的右界就是下标i </span></span><br><span class="line">              S.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="keyword">if</span>(S.<span class="built_in">empty</span>())</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">              k=S.<span class="built_in">top</span>();</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>(S.<span class="built_in">empty</span>())<span class="comment">//如果栈空了，当前元素左界就是1，即最小 </span></span><br><span class="line">            ll[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//不然就是栈顶+1，栈中存的都是下标 </span></span><br><span class="line">            ll[i]=k<span class="number">+1</span>;</span><br><span class="line">            S.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())<span class="comment">//当栈不为空时，因为是单调递减栈，所以剩下的元素的右界都是n+1(其实是n但是后面减的时候方便而已) </span></span><br><span class="line">        &#123;</span><br><span class="line">           k=S.<span class="built_in">top</span>();</span><br><span class="line">           rr[k]=n<span class="number">+1</span>;</span><br><span class="line">           S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//扫一遍最大值即可 </span></span><br><span class="line">        maxx=<span class="built_in">max</span>(maxx,a[i]*(rr[i]-ll[i]));</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,maxx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    如果当前值是最小值，用一个单调递增栈维护，如果当前值是最大值，用一个单调递减栈维护。</p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><h3 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h3><p>单调队列是指一个队列内部的元素具有严格单调性的一种数据结构，分为单调递增队列和单调递减队列。 </p><h3 id="2-性质-1"><a href="#2-性质-1" class="headerlink" title="2.性质"></a>2.性质</h3><p>1.单调队列必须满足从队头到队尾的严格单调性。</p><p>2.排在队列前面的比排在队列后面的要先进队。</p><h3 id="3-例题-1"><a href="#3-例题-1" class="headerlink" title="3.例题"></a>3.例题</h3><h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a><a href="https://vjudge.net/problem/POJ-2823">Sliding Window</a></h2><p> 题意：给定一个大小已知的数组以及一个大小已知的滑动窗口，窗口每个时刻向后移动一位，求出每个时刻窗口中数字的最大值和最小值。</p><p>分析：</p><p>求最大值：建立一个单调递减队列，元素从左到右依次入队，入队之前必须从队列尾部开始删除那些比当前入队元素小或者相等的元素，直到遇到一个比当前入队元素大的元素，或者队列为空为止。若此时队列的大小超过窗口值，则从队头删除元素，直到队列大小小入窗口值为止。然后把当前元素插入队尾。<br>求最小值：建立一个单调递增队列，元素从左到右依次入队，入队之前必须从队列发问开始删除那些比当前入队元素大或者相等的元素，直到遇到一个比当前入队元素小的元素，或者队列为空为止。若此时队列的大小超过窗口值，则从队头删除元素，直到队列大小小入窗口值为止。然后把当前元素插入队尾。<br>设窗口大小为k，本题解法为建立两个单调队列，先从原数组中取前k个元素按上述要求入队，然后获取队头元素，再把下一个元素放入队中，再获取头元素，这样一直到最后一个元素为止。最后把答案从头到尾依次输出即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Elem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Elem maxque[N];</span><br><span class="line">Elem minque[N];</span><br><span class="line"><span class="type">int</span> maxhead, minhead, maxtail, mintail;</span><br><span class="line"><span class="type">int</span> maxans[N];</span><br><span class="line"><span class="type">int</span> minans[N];</span><br><span class="line"><span class="type">int</span> cur;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, w, num;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;w);</span><br><span class="line">minhead = mintail = <span class="number">0</span>;</span><br><span class="line">maxhead = maxtail = <span class="number">0</span>;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i)<span class="comment">//0-w，第一个窗口的情况 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (minhead &lt; mintail &amp;&amp; minque[mintail - <span class="number">1</span>].val &gt;= num) <span class="comment">//单调递增队列，非空并且队尾的值大于当前值，出队 </span></span><br><span class="line">&#123;</span><br><span class="line">--mintail;</span><br><span class="line">&#125;</span><br><span class="line">minque[mintail].val = num;</span><br><span class="line">minque[mintail].pos = i;</span><br><span class="line">++mintail;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (maxhead &lt; maxtail &amp;&amp; maxque[maxtail - <span class="number">1</span>].val &lt;= num) <span class="comment">//单调递减队列，非空并且队伍的值小于当前值，出队 </span></span><br><span class="line">&#123;</span><br><span class="line">--maxtail;</span><br><span class="line">&#125;</span><br><span class="line">maxque[maxtail].val = num;</span><br><span class="line">maxque[maxtail].pos = i;</span><br><span class="line">++maxtail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = w; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">minans[cur] = minque[minhead].val;<span class="comment">//记录答案 </span></span><br><span class="line">maxans[cur] = maxque[maxhead].val;</span><br><span class="line">++cur;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (minhead &lt; mintail &amp;&amp; i - minque[minhead].pos &gt;= w) <span class="comment">//队列非空并且当前元素位置-队列头的位置大于滑窗大小，队头元素出队 </span></span><br><span class="line">&#123;</span><br><span class="line">++minhead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (minhead &lt; mintail &amp;&amp; minque[mintail - <span class="number">1</span>].val &gt;= num) <span class="comment">//队列非空并且队尾元素大于当前值，出队 </span></span><br><span class="line">&#123;</span><br><span class="line">--mintail;</span><br><span class="line">&#125;</span><br><span class="line">minque[mintail].val = num;</span><br><span class="line">minque[mintail].pos = i;</span><br><span class="line">++mintail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (maxhead &lt; maxtail &amp;&amp; i - maxque[maxhead].pos &gt;= w) <span class="comment">//同上 </span></span><br><span class="line">&#123;</span><br><span class="line">++maxhead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (maxhead &lt; maxtail &amp;&amp; maxque[maxtail - <span class="number">1</span>].val &lt;= num) </span><br><span class="line">&#123;</span><br><span class="line">--maxtail;</span><br><span class="line">&#125;</span><br><span class="line">maxque[maxtail].val = num;</span><br><span class="line">maxque[maxtail].pos = i;</span><br><span class="line">++maxtail;</span><br><span class="line">&#125;</span><br><span class="line">minans[cur] = minque[minhead].val;</span><br><span class="line">maxans[cur] = maxque[maxhead].val;</span><br><span class="line">++cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) </span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, minans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) </span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, maxans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    此题为单调队列模板题，需要思考一下为什么求最大值要单调递减队列，求最小值需要单调递增队列？？</p><p>​    不难理解，因为是用队头去获取区间的值，单调递减队列队头必定区间最大，单调递增队列必定区间最小。</p><h2 id="Fence"><a href="#Fence" class="headerlink" title="Fence"></a><a href="https://vjudge.net/problem/POJ-1821">Fence</a></h2><pre><code> 题意：K个人对N块木板涂色，每个人初始站在一块木板前（不重复），每人最多只能涂包含所站木板的连续l个木板或一个木板也不涂。给出每人最多涂的木块数l,涂一快木板的工钱p，站的木板s。求这群人最多共获得多少工钱。</code></pre><p>​    分析：dp   <code>[i][j]</code>表示前i个人对前j块木板操作的最大收益。<br>    核心状态转移方程：<code>dp[i][j]=max(dp[i][j-1],dp[i-1][k]+P[i].p*(j-k),dp[i-1][j])</code>  </p><p>​                                      <code>max(0,P[i].s-P[i].l)&lt;=k&lt;min(P[i].s-1,j)</code> </p><p>​    显然直接做就是枚举i,j,k。观察   <code>dp[i-1][k]+P[i].p*(j-k)=(dp[i-1][k]-P[i].p*k)+P[i].p*j</code><br>在枚举k的时候,P[i].p<em>j的值已经确定不用考虑，只需要找出使 `(dp[i-1][k]-P[i].p</em>k)` 最大的k就行了，又观察到这个式子的值不与j相关，也就是说在枚举k之前我们就可以通过某种方法找出这个k，即：构造递减的 单调队列 维护k值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">16050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,p,s;<span class="comment">//最多涂的砖块数，涂一块获得的钱，位置 </span></span><br><span class="line">&#125;P[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(person p1,person p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p<span class="number">1.</span>s&lt;p<span class="number">2.</span>s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> Q[<span class="number">16050</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N,K;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;K)!=EOF)<span class="comment">//n块砖，k个人 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;P[i].l,&amp;P[i].p,&amp;P[i].s);</span><br><span class="line">        <span class="built_in">sort</span>(P<span class="number">+1</span>,P+K<span class="number">+1</span>,cmp);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> front,rear;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            front=<span class="number">0</span>;rear=<span class="number">1</span>;</span><br><span class="line">            Q[<span class="number">0</span>]=<span class="built_in">max</span>(P[i].s-P[i].l,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=P[i].s+P[i].l)<span class="comment">//这些木块涂不了</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(front&lt;rear&amp;&amp;Q[front]+P[i].l&lt;j)<span class="comment">//队中的k过小，出队</span></span><br><span class="line">                    front++;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;P[i].s)<span class="comment">//符合k的取值范围即可以考虑入队，不能超过当前人的位置 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> temp=dp[i<span class="number">-1</span>][j]-j*P[i].p;</span><br><span class="line">                    <span class="keyword">while</span>(front&lt;rear&amp;&amp;dp[i<span class="number">-1</span>][Q[rear<span class="number">-1</span>]]-Q[rear<span class="number">-1</span>]*P[i].p&lt;temp)<span class="comment">//更优的k出现，队尾出队</span></span><br><span class="line">                        rear--;</span><br><span class="line">                    Q[rear++]=j;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//第i个人无法涂这些木块</span></span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][Q[front]]+P[i].p*(j-Q[front]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[K][N]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一道</p><h2 id="Dividing-the-Path"><a href="#Dividing-the-Path" class="headerlink" title="Dividing the Path"></a><a href="https://vjudge.net/problem/POJ-2373">Dividing the Path</a></h2><pre><code> 题意：在长为L的草地上装喷水头，喷水头的喷洒半径为[a,b]，要求草地的每个整点被且只被一个喷水头覆盖</code></pre><p>有N个特殊区间，要求只能被某一个喷水头完整地覆盖，而不能由多个喷水头分段覆盖，求喷水头的最小数目</p><p>​    注意：喷水头只能建在整数点上</p><p>​    分析：dp[i] 表示区间[0,i]完全被覆盖的最少喷水头数目。dp[i]=min(dp[j]+1)   j∈[i-2<em>b,i-2</em>a]，若i处于某个特殊区间内部，则dp[i]=inf，dp[0]=0,dp[i]=min{dp[i-2<em>b]….dp[i-2</em>a]}； </p><p>​    注意：因为喷水头只能建在整数点上，当i为奇数时，区间[0,i]一共有偶数个点，喷水头不可能建在整数点上</p><p>所以只有i为偶数时才是有用的。</p><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">bool</span> all[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;e[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">int</span> h,t;<span class="comment">//双指针,head,tail </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=<span class="built_in">getchar</span>(); </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) &#123; x=x*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>; c=<span class="built_in">getchar</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node p,node q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.l!=q.l) </span><br><span class="line"><span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">    <span class="keyword">return</span> p.r&lt;q.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//i是偶数 ，单调递增队列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;t &amp;&amp; i-q[h]&gt;<span class="number">2</span>*b) <span class="comment">//队列非空，超出了喷水头射程，队头出队 </span></span><br><span class="line">h++;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;t &amp;&amp; i-q[h]&gt;=<span class="number">2</span>*a)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=dp[q[h]]<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t &amp;&amp; dp[i]&lt;dp[q[t<span class="number">-1</span>]]) <span class="comment">//到i用的喷水头更少则更新答案 </span></span><br><span class="line">t--;</span><br><span class="line">        q[t++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l;<span class="comment">//n个特殊区间，l长的草坪。喷水头的射程a,b。 </span></span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(l);</span><br><span class="line">    <span class="built_in">read</span>(a); <span class="built_in">read</span>(b);<span class="comment">//a&lt;=b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="comment">//特殊区间的左界右界</span></span><br><span class="line"><span class="built_in">read</span>(e[i].l),<span class="built_in">read</span>(e[i].r); </span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e+n<span class="number">+1</span>,cmp);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">63</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//0x3f3f3f3f</span></span><br><span class="line">    <span class="type">int</span> INF=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//cout&lt;&lt;INF&lt;&lt;endl;</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[t++]=<span class="number">0</span>;<span class="comment">//队列里面放个0 </span></span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(now&lt;=n &amp;&amp; e[now].l&lt;i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[now].r&gt;i) i=e[now].r;<span class="comment">//这里没问题，要保证特殊区间只能被一个喷水头完整的覆盖，因此i直接到右界，继续往后扫即可，如果最后发现所有队头+射程都达不到，就真的不行了 </span></span><br><span class="line">            now++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(i&amp;<span class="number">1</span>))<span class="comment">//必须是偶数才行，奇数的话有偶数个点（加0点），就不行。 </span></span><br><span class="line"><span class="built_in">up</span>(i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[l]==INF) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[l]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>单调队列优化dp<br>单调队列可以有两个操作：<br>1、插入一个新的元素，该元素从队尾开始向队首进行搜索，找到合适的位置插入之，如果该位置原本有元素，则替换它。<br>2、在过程中从队首删除不符合当前要求的元素。单调队列实现起来可简单，可复杂。简单的一个数组，一个head，一个tail指针就搞定。复杂的用双向链表实现。</p><p>用处：<br>1、保存最优解，次优解，ect。<br>2、利用单调队列对dp方程进行优化，可将O(n)复杂度降至O(1)。也就是说，将原本会超时的N维dp降优化至N-1维，以求通过。这也是我想记录的重点。</p><p>是不是任何DP都可以利用单调队列进行优化呢？答案是否定的。</p><p>记住！只有形如 dp[i]=max/min (f[k]) + g[i]  （k&lt;i &amp;&amp; g[i]是与k无关的变量）才能用到单调队列进行优化。（降维实质：把状态转移方程分为两部分：只与k有关，只与i有关。 与k有关的状态在前i-1次压入que，i有关的是此次状态转移所需的g[i]）。<br>优化的对象就是f[k]。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第四讲：字符串基础</title>
      <link href="/2019/07/25/string/"/>
      <url>/2019/07/25/string/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h1><h2 id="1-字符串匹配"><a href="#1-字符串匹配" class="headerlink" title="1.字符串匹配"></a>1.字符串匹配</h2><h3 id="1-暴力算法"><a href="#1-暴力算法" class="headerlink" title="1.暴力算法"></a>1.暴力算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[i + j] != b[j]) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (j == m) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-哈希"><a href="#2-哈希" class="headerlink" title="2.哈希"></a>2.哈希</h3><p>将string映射为int 每一个字符串代表一个数字 时间复杂度变为O(n+m)</p><p>转化方法可以采用</p><script type="math/tex; mode=display">f(s) = \sum{s[i]*b^i}(modM)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">hashs</span><span class="params">(<span class="type">char</span> s[])</span><span class="comment">//上述公式相当于把一个字符串看成一个b进制数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        ans=(ans*base+(ll)s[i])%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b与M应当是互质的（不然取余的时候直接约了）</p><p>在输入随机的情况下，这个求出的数在[0,M)上的值概率相等，所以单次比较重复的概率为</p><p>$\frac{1}{M}$   n次比较中出错的概率就为$1-(1-(1/M))^n$</p><p>当M&gt;&gt;n时 这个值接近$\frac{n}{M}$ </p><p>一般来说我们直接用ULL(unsigned long long类型)来储存Hash值，因为这个类型在$2^{64}$溢出时会自动对$2^{64}$取模</p><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给出几个由小写字母构成的单词，求它们最长的公共子串的长度。</p><p>任务</p><ul><li>从文件中读入单词</li><li>计算最长公共子串的长度</li><li>输出结果到文件</li></ul><p>输入</p><p>文件的第一行是整数 n，1&lt;=n&lt;=5，表示单词的数量。接下来n行每行一个单词，只由小写字母组成，单词的长度至少为1，最大为2000。</p><p>输出：</p><p>仅一行，一个整数，最长公共子串的长度。</p><p>样例输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abcb</span><br><span class="line">bca</span><br><span class="line">acbc</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>二分答案+哈希 或者 用后缀数组</p><p>哈希：（PS：map的[]是O(logn)的,所以这个过不了1e5的数据，如果n=2直接用vector就可以过1e5了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> ULL base = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">7</span>][maxn];</span><br><span class="line">map&lt;ULL, ULL&gt; ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">ans.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">strlen</span>(s[i]);<span class="comment">//该字符串长度</span></span><br><span class="line">ULL tt = <span class="number">0</span>, temp = <span class="number">1</span>;<span class="comment">//tt 当前进制数 temp 进制最高位 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; len; j++)&#123;</span><br><span class="line">tt = tt*base+(ULL)(s[i][j]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(j) temp=temp*base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans[tt]==i)&#123;</span><br><span class="line">ans[tt]++;</span><br><span class="line"><span class="keyword">if</span>(ans[tt]==n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = len; j &lt; t; j++)&#123;</span><br><span class="line">tt=tt*base+(ULL)(s[i][j]-<span class="string">&#x27;a&#x27;</span>)-temp*(ULL)(s[i][j-len]-<span class="string">&#x27;a&#x27;</span>)*base;</span><br><span class="line"><span class="keyword">if</span>(ans[tt]==i)&#123;</span><br><span class="line">ans[tt]++;</span><br><span class="line"><span class="keyword">if</span>(ans[tt]==n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;pow.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;pow.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="type">int</span> minl = maxn;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">strlen</span>(s[i]);</span><br><span class="line">minl = <span class="built_in">min</span>(t, minl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l= <span class="number">1</span>, r = minl, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">solve</span>(mid))&#123;</span><br><span class="line">ans = mid;</span><br><span class="line">l = mid<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-KMP"><a href="#3-KMP" class="headerlink" title="3.KMP"></a>3.KMP</h3><h4 id="前缀数组"><a href="#前缀数组" class="headerlink" title="前缀数组"></a>前缀数组</h4><p>一个字符串的真前缀是其前缀但不等于该字符串自身。</p><p>对于一个字符串s，其前缀函数为$\pi$，其中$\pi$[i]指即是s[0~i]的前缀又是该子串后缀的最长真前缀</p><p>abcaabcab的前缀函数为[0，0，0，1，1，2，3，4,  2]</p><p>aabaaab的前缀函数为[0，1，0，1，2，2，3]</p><h4 id="前缀数组最直观的求法-O-n-3"><a href="#前缀数组最直观的求法-O-n-3" class="headerlink" title="前缀数组最直观的求法 O($n^3$)"></a>前缀数组最直观的求法 O($n^3$)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; pi;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line">      <span class="keyword">if</span> (s[<span class="number">0</span> ~ k] == s[i - k + <span class="number">1</span> ~ k]) pi[i] = k;</span><br><span class="line">  <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>观察前面的前缀函数例子，发现前缀函数后一位有三种情况</p><h5 id="1-增加1-因为是最长真前缀，所以一定和之前一位只相差1"><a href="#1-增加1-因为是最长真前缀，所以一定和之前一位只相差1" class="headerlink" title="1.增加1(因为是最长真前缀，所以一定和之前一位只相差1)"></a>1.增加1(因为是最长真前缀，所以一定和之前一位只相差1)</h5><h5 id="2-保持不变"><a href="#2-保持不变" class="headerlink" title="2.保持不变"></a>2.保持不变</h5><h5 id="3-减少"><a href="#3-减少" class="headerlink" title="3.减少"></a>3.减少</h5><p>观察减小的例子 如果当前字符s[i]与s[$\pi$[i-1]+1]不同，就不能加一</p><p>这时候我们去判断“前缀函数的前缀函数”即$\pi$[$\pi$[i-1]-1]</p><p>如果这时匹配了，那就加一</p><p>具体证明此处不赘述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j]) j++;</span><br><span class="line">    pi[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$POJ    1961$</p><p>​    如果一个字符串 $S$ 是由一个字符串 $T$ 重复 $K$ 次形成的，则称 $T$ 为 $S$ 的循环元。使 $K$ 最大的字符串 $T$ 称为 $S$的最小循环元，此时的 $K$ 被称为最大的循环次数。</p><p>​    现在给定一个长度为 $N$  的字符串 $S$ ，对 $S$ 的每一个前缀 $S[1$~$i]$ ,如果它的最大循环次数大于 $1$ ，则输出该前缀的最小循环长度和最大循环次数。</p><p>Sample Input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">aaa</span><br><span class="line">12</span><br><span class="line">aabaabaabaab</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Test case #1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line"></span><br><span class="line">Test case #2</span><br><span class="line">2 2</span><br><span class="line">6 2</span><br><span class="line">9 3</span><br><span class="line">12 4</span><br></pre></td></tr></table></figure><p>​    $S[1$~ $i]$ 具有长度为了 $len$ &lt; $i$ 的循环元的充要条件为 $len$ 能整除 $i$ 并且 $S[len + 1$~ $i] =  S[1$~ $i - len]$ </p><p>​    证明：</p><p>​    必要性 有长度为 $len$ 的循环元，那么显然 $len$ 能整除 $i$ 并且 $S[len + 1$~ $i]$ =  $S[1$~ $i - len]$ 成立</p><p>​    充分性 $len$ 能整除 $i$ 并且 $S[len + 1$~ $i]$ =  $S[1$~ $i - len]$ 成立。首先 $S[len + 1$~ $i]$ 和  $S[1$~ $i - len]$ 的长度不小于$len$ 且是 $len$ 的倍数。$S[len + 1$~ $i]$ 和  $S[1$~ $i - len]$ 以 $len$ 为长度错位对齐，以$len$ 为间隔取对应字符有</p><p>$S[len + 1$~ $2*len] =  S[1$~ $len]$ ，以此类推得证。</p><p>$Codeforces - Anthem of Berland$</p><p>题意：给定一个包含？的字符串A，还有一个字符串B，问B最多可能在A中出现几次。</p><p>input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winlose???winl???w??win</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>DP+KMP</p><p>$dp[i]$ 表示 $0$ ~ $i$ 的字符串最多能出现几次 $B$</p><p>$cnt[i]$ 表示最后一次出现的以 $i$ 结尾 $B$  $0$ ~ $i$中出现 $B$ 的次数（$A[i-len$~$i] = B$ ）</p><p>求 $cnt[i]$ 可以用KMP</p><p>首先，不考虑最后一个B $cnt[i]$ 肯定大于等于 $cnt[i-lenB]$ 如果$i-lenB$ 前的某几个字符与 后面的字符也能凑成一个 $B$ 那么 $cnt[i]$ 就比 $cnt[i-lenB]$ 要大一 这样的情况就是求一下前缀数组的情况</p><p>例子 $A:abc|abcab$ $B:abcab$  </p><p>具体来说就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnt[i] = dp[i - lenB];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = nxt[lenB]; k != <span class="number">-1</span>; k = nxt[k]) &#123;</span><br><span class="line">cnt[i] = <span class="built_in">max</span>(cnt[i], cnt[i - (lenB - k)]);</span><br><span class="line">&#125;</span><br><span class="line">cnt[i]++;</span><br></pre></td></tr></table></figure><p>$codeforces$ $471D$ $MUH$ $and$ $Cube$ $Walls$ </p><p>给定两个数组表示形状,问第二个数组的形状能否在第一个数组中找到.若能找到,求出能找到几次</p><p><img src="https://cos.chdacm.cn//imgs/20210731164430.png" alt="3"></p><p>​    kmp,因为只需要形状相同,不需要考虑每个值的实际大小,只需要使得数组的前后差值相等,就能使得上边界构成的形状相同。<br>​    求出两个数组的相邻数差值构成的新数组,然后利用kmp求第二个差值数组在第一个差值数组中出现的次数,注意到若第二个数组就只有一个数,则在第一个数组任意位置都能构成相同的形状因此此时输出n即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pi[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn], c[maxn], b[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p_f</span><span class="params">(<span class="type">int</span>* s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">pi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j]) j++;</span><br><span class="line">    pi[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n, &amp;w);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">if</span>(i) c[i<span class="number">-1</span>] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; w; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"><span class="keyword">if</span>(i) d[i<span class="number">-1</span>] = b[i] - b[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(w==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">p_f</span>(d, w<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;c[i]!=d[j]) j = pi[j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(c[i] == d[j]) j++;</span><br><span class="line"><span class="keyword">if</span>(j==w<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d\n&quot;, i, pi[j-1]);</span></span><br><span class="line">j = pi[j<span class="number">-1</span>];</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-最小表示法"><a href="#2-最小表示法" class="headerlink" title="2.最小表示法"></a>2.最小表示法</h2><p>​    给定一个字符串 $S$ ， 如果我们不断把它的最后一个字符放到开头，最终会得到 $n$ 个字符串，称这 $n$ 个字符串是循环同构的。这些字符串中字典序最小的一个，称为字符串 $S$ 的最小表示。</p><p>​    用$B[i]$表示从 $i$ 开始的循环同构字符串，即 $S[i$~$n]+S[1$~$i-1]$。</p><p>​    首先，我们把这个字符串复制一份放到后面，记这个新的字符串为 $SS$ .</p><p>​    在对 $SS$ 比较的过程中如果在 $i + k$， $j + k$ 处发现不相等，假设 $SS[i+k] &gt; SS[j+k]$ ,那么我们除了得知 $B[i]$ 不是最小表示，同时$B[i+1]$~$B[i+k]$ 也都不是。指针后移即可。</p><h2 id="3-Trie（读作Try）"><a href="#3-Trie（读作Try）" class="headerlink" title="3.Trie（读作Try）"></a>3.Trie（读作Try）</h2><p><img src="https://cos.chdacm.cn//imgs/20210731164448.png" alt="trie1"></p><p> $trie[i][j] = k$， 编号为 $i$ 的节点第 $j$ 个孩子是编号为 $k$ 的节点， $i$ 与 $k$ 是建树时新插入的节点的编号</p><p>若都为大写或都为小写， $j$ 可取 $0-25$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;len; i++)&#123;</span><br><span class="line">        <span class="type">int</span> id = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[root][id]) <span class="comment">//没有从root到id的编号 新建标号</span></span><br><span class="line">            trie[root][id] = ++root;</span><br><span class="line">        root = trie[root][id];</span><br><span class="line">    &#125;</span><br><span class="line">    end[root] = <span class="number">1</span>;<span class="comment">//标记结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;s[i]; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(trie[root][x] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        root = trie[root][x];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> end[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$The$ $XOR$ $Largest$ $Pair$</p><p>​    给定 $N$ 个整数 $A_1,A_2,…,A_N$ 中选出两个进行异或运算，得到结果最大多少？</p><p>解：考虑一个数转化为二进制后，要使它与另一个数异或后值最大，那就是在每一个二进制位上取反</p><p>我们将每一个所给的数转化为32位的二进制数（补前导 $0$）然后建立字典树(低位在下)，对每个数，我们寻找其上述每位求反的数是否存在，如果不存在只能找与其相同的，那这一位上的值变为 $0$，这样可以找到与$Ai$异或后值最大的 $A_j$</p><p>$POJ 3764$</p><p>​    给定一棵 $N$ 个节点的树， 树上的每一条边都有一个权值。从树中选择两个点 $x$ 和 $y$ ，把从 $x$ 到 $y$ 的路径上的所有边权 $xor$ 起来，得到的结果最大是多少？</p><p>首先，我们可以求出每个点 $x$ 到根节点的路径上的所有边权 $xor$ 值 记为 $D[x]$ </p><p>题目所要求的值就等于 $D[x]xorD[y]$ 问题就变成了从 $D[1]$ ~ $D[N]$ 这 $N$ 个数中选两个数， $xor$ 的结果最大，就是前一道题。</p><h2 id="4-Manacher"><a href="#4-Manacher" class="headerlink" title="4.Manacher"></a>4.Manacher</h2><p>求回文子串</p><p>p数组保存以当前字符为对称轴的回文半径</p><p>因为有可能回文串长为偶数，所以对称轴不是字符而是字符之间的空隙</p><p>于是我们在每两个字符间插入一个不会出现的字符（$Ascill$为 $0$ 比如说）</p><p>bob -&gt; #b#o#b#</p><p>但是这样会出现新的问题</p><p>求回文串的时候会比较当前回文串前一个字符与后一个字符，这样就会访问到$s[-1]$ 这个位置导致越界</p><p>所以我们在开头再加入一个不会出现的且与之前插入的不同的字符（$Ascill$为 $1$ 比如说）</p><p>然后是求 $p[i]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[i] = mx &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中 $id$ 为当前所探索到的最右边那个回文串的对称轴位置</p><p>$mx$ 为最右端位置</p><p>如果 $mx &gt; i$, 则 $p[i] = min( p[2 * id - i] , mx - i )$</p><p>否则，$p[i] = 1$</p><p>当 $mx - i &gt; p[j]$ 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 $i$ 和 $j$ 对称，以$S[i]$为中心的回文子串必然包含在以$S[id]$为中心的回文子串中，所以必有 $p[i] = p[j]$，其中 $j = 2<em>id - 1$，因为 $j$ 到 $id$ 之间到距离等于 $id$ 到 $i$ 之间到距离，为 $i - id$，所以 $j = id - (i - id) = 2</em>id - i$</p><p><img src="https://cos.chdacm.cn//imgs/20210731164500.png" alt="图片1"></p><p>当 $p[j] &gt;= mx - i$<br>的时候，以$S[j]$为中心的回文子串不一定完全包含于以$S[id]$为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以$S[i]$为中心的回文子串，其向右至少会扩张到$mx$的位置，也就是说<br>$p[i] = mx - i$。至于$mx$之后的部分是否对称，只能老老实实去匹配了</p><p><img src="https://cos.chdacm.cn//imgs/20210731164506.png" alt="图片2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">string t = <span class="string">&quot;$#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        t += s[i];</span><br><span class="line">        t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, resLen = <span class="number">0</span>, resCenter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        p[i] = mx &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">            resLen = p[i];</span><br><span class="line">            resCenter = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>题意：求这样一个回文串S，S = A + B 且 A, B都是回文串。问最长S</strong></p><p>我们可以定义这么两个东西<br>1.:l[i]代表i位置所在回文串中的最右端的位置<br>2.:r[i]代表i位置所在回文串中的最左端的位置</p><p>一个从左到右遍历，一个从右到左，所以i所在的回文串不一定是同一个</p><p>我们可以算出来这个东西。<br>因此通过左右拼接就可以得到我们的双回文串了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"><span class="keyword">for</span>(;pos&lt;=i+p[i]<span class="number">-1</span>;pos++)</span><br><span class="line">l[pos]=i;<span class="comment">//概念和上面讲的一样 </span></span><br><span class="line">pos=len;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(;pos&gt;=i-p[i]<span class="number">+1</span>;pos--)</span><br><span class="line">r[pos]=i;<span class="comment">//概念同上面讲的一样 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">ans=<span class="built_in">max</span>(ans,<span class="built_in">abs</span>(l[i]-r[i])); </span><br></pre></td></tr></table></figure><h2 id="5-exkmp-Z函数"><a href="#5-exkmp-Z函数" class="headerlink" title="5.exkmp(Z函数)"></a>5.exkmp(Z函数)</h2><p>假设我们有一个长度为 $N$ 的字符串 $s$，该字符串的 <strong><em>Z函数</em></strong> 为一个长度为 $n$ 的数组，其中第 $i$ 个元素为满足从位置 $i$ 开始且为 $s$ 前缀的字符串的最大长度。</p><p>即， $z[i]$ 为 $s$ 和从 $i$ 开始的 $s$ 的后缀的最大公共前缀长度。</p><p>假设数组第一位为0</p><p>样例：</p><p>$Z(aaaaa) = [0,1,2,3,4]$</p><p>$Z(aaabaab) = [0,2,1,0,2,1,0]$</p><p>$Z(abacaba) = [0,0,1,0,3,0,1]$</p><h3 id="朴素算法（O-n-2-）"><a href="#朴素算法（O-n-2-）" class="headerlink" title="朴素算法（O($n^2$)）"></a>朴素算法（O($n^2$)）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z_function_trivial</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高效算法（线性）"><a href="#高效算法（线性）" class="headerlink" title="高效算法（线性）"></a>高效算法（线性）</h3><p>$z$ 数组的定义为取得最大的 $z[i]$ 使得 $s[0;z[i]-1] = s[i;i+z[i]-1]$</p><p>假设当前我们已经知道$s[0;r-l] = s[l;r]$ (；表示~)</p><p>可知$s[i-l;r-l] = s[i;r]$</p><p>然后可得$s[i-l;i-l+z[i-l]-1] = s[i;i+z[i-l]-1]$</p><p>那么 $z[i]$ 就至少等于 $z[i-l]$</p><p>当然还要注意，r后面的情况我们还不知道</p><p>所以$z[i] = min(z[i-1], r-i+1)$</p><p>然后再进行匹配 这样相当于让 $z[i]$ 赋了一个初值 </p><p>至于为什么这样子会把时间复杂度降为 $O（n）$ 有兴趣的话可以自行百度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) z[i] = <span class="built_in">min</span>(r - i + <span class="number">1</span>, z[i - l]);</span><br><span class="line">    <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在一个字符串s中找一个子串，这个子串要符合的条件有三点，第一可以说这个子串是s的前缀，第二也可以说这个子串是s的后缀，第三也可以说这个子串既不是s的前缀也不是s的后缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> z[maxn], n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">z_f</span><span class="params">(<span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) z[i] = <span class="built_in">min</span>(r - i + <span class="number">1</span>, z[i - l]);</span><br><span class="line">    <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">n = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">memset</span>(z, <span class="number">0</span>, <span class="built_in">sizeof</span>(z));</span><br><span class="line"><span class="built_in">z_f</span>(s);</span><br><span class="line"><span class="type">int</span> max1 = <span class="number">0</span>, maxp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(z[i]&gt;max1)&#123;</span><br><span class="line">max1 = z[i];maxp = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//printf(&quot;%d %d\n&quot;, max1, maxp);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(i+z[i]<span class="number">-1</span> == n<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(z[i]&lt;max1||(z[i]==max1&amp;&amp;maxp!=i))&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, i);</span></span><br><span class="line">        ans = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s+ans);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Just a legend\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="POJ2185"><a href="#POJ2185" class="headerlink" title="POJ2185"></a>POJ2185</h3><p>给你一个字符矩阵，求出它的最小覆盖子矩阵，即使得这个子矩阵的无限复制扩张之后的矩阵，能包含原来的矩阵。 即二维的最小覆盖子串。</p><p>一看这题，容易想出一种很直观的做法：求出每一行的最小覆盖子串长度，取所有行的最小覆盖子串长度的最小公倍数为宽；对列也同样操作求出高。由于POJ测试数据水了，所以过了。</p><p>但是，让我们来看一下下面这种情况</p><p>Input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 8</span><br><span class="line">ABCDEFAB</span><br><span class="line">AAAABAAA</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>第一行的最小覆盖子串长度为6，第二行为5 那么答案应该是60</p><p>但是第二行取6时 答案就为12</p><p>由于数据范围是R (1 &lt;= R &lt;= 10,000)  C (1 &lt;= C &lt;= 75)那么直接暴力枚举重复子串的长度c，每列逐一检查是否与当前枚举的重复子串相对应。因此求宽度这个部分的时间复杂度为$O(R*C^2)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_width</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[maxc];</span><br><span class="line">    <span class="type">int</span> f[maxc];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">1</span>; row &lt;= r; row++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cir = <span class="number">1</span>; cir &lt;= c; cir++) &#123;</span><br><span class="line">            <span class="built_in">strncat</span>(tmp, s[row] + cir - <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//取当前行前cir个字符</span></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">                cnt += (s[row][i] == tmp[i % cir]);<span class="comment">//判断是否是长度为cir的覆盖子串</span></span><br><span class="line">            f[cir] += (cnt == c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[i] == r) <span class="keyword">return</span> i;<span class="comment">//每一行都是长度为i的覆盖串</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定高度，把一行看成一个整体，行与行之间作KMP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> next[maxr];</span><br><span class="line">    <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span> next);</span><br><span class="line">    next[<span class="number">0</span>] = next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(s[i], s[k + <span class="number">1</span>]))</span><br><span class="line">            k = next[k];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s[i], s[k + <span class="number">1</span>])) ++k;</span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r - next[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第二讲：组合数学&amp;概率&amp;数学期望</title>
      <link href="/2019/07/19/cbmath&amp;dp/"/>
      <url>/2019/07/19/cbmath&amp;dp/</url>
      
        <content type="html"><![CDATA[<p>主讲人：韩耀东</p><p>时间：7.19</p><h1 id="组合数学-amp-概率期望DP"><a href="#组合数学-amp-概率期望DP" class="headerlink" title="组合数学 &amp; 概率期望DP"></a>组合数学 &amp; 概率期望DP</h1><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="1-排列组合"><a href="#1-排列组合" class="headerlink" title="1. 排列组合"></a>1. 排列组合</h3><h4 id="1-加法原理"><a href="#1-加法原理" class="headerlink" title="1. 加法原理"></a>1. 加法原理</h4><p>​    完成一列事的方法有 n 类，其中第 i 类方法包括$a_i$种不同的方法，且这些方法互不重合，则完成这件事共有 $a_1  + a_2 + \cdots + a_n$ 种不同的方法</p><h4 id="2-乘法原理"><a href="#2-乘法原理" class="headerlink" title="2. 乘法原理"></a>2. 乘法原理</h4><p>​    若完成一件事需要 n 个步骤，其中第 i 个步骤有 $a_i$ 种不同的完成方法，且这些步骤互不干扰，则完成这件事共有 $a+1 <em> a_2 </em> \cdots * a_n$ 种不同的方法</p><blockquote><p>两原理的区别：</p><p>一个与分类有关，一个与分步有关；加法原理是“分类完成”，乘法原理是“分步完成”</p></blockquote><h4 id="3-排列数"><a href="#3-排列数" class="headerlink" title="3. 排列数"></a>3. 排列数</h4><p>在 $n$ 个不同元素种，任取 $与均为自然数，下同m(m\leq n,m与n均为自然数，下同)$ 个元素按照一定的顺序排成一列，叫做从$n$个不同元素中取出$m$ 个元素的一个排列；产生排列的个数叫做从 $n$ 个不同元素中取出 $m$个元素的排列数，用符号 $A_n^m$ 来表示</p><p>​             <script type="math/tex">A_n^m = n(n-1)(n-2) \cdots (n-m+1) = \frac{n!}{(n - m)!}</script></p><blockquote><p>排列分为全排列和部分排列，全排列的m = n</p></blockquote><h4 id="4-组合数"><a href="#4-组合数" class="headerlink" title="4. 组合数"></a>4. 组合数</h4><p>从 n 个不同元素中，任取$m (m\leq n)$个元素组成一个集合，叫做从n 个不同元素中取出m 个元素的一个组合；从n个不同元素中取出$（m （m\leq n)$ 个元素的所有组合的个数，叫做从n 个不同元素中取出m 个元素的组合数。用符号$或者是C_n^m (或者是 (^m_n) )$表示</p><p>​                 <script type="math/tex">C_n^m = \frac{A_n^m}{m!} = \frac{n!}{m!(n - m)!}</script></p><h5 id="组合数性质"><a href="#组合数性质" class="headerlink" title="组合数性质"></a>组合数性质</h5><ol><li>$C_n^m = C_n^{n-m}$</li><li>$C<em>n^m = C</em>{n-1} ^ m + C_{n-1} ^{m-1}$ (可用杨辉三角推到)</li><li>$C_n^0 + C_n^1 + C_n^2 + C_n^3 + \cdots + C_n^n = 2^n$ </li><li>$\sum<em>{i=0}^m C_n^i C_m^{m-i} = C</em>{m+n}^m(n \geq m) $  分开取和一起取是一样的（也可以理解成先取和后取）</li></ol><h4 id="5-多重集的排列数"><a href="#5-多重集的排列数" class="headerlink" title="5. 多重集的排列数"></a>5. 多重集的排列数</h4><p>设集合 $S = {n_1\cdot a_1,n_2\cdot a_2,\cdots,n_k\cdot a_k}$ ,是由$n_1$ 个$a_1$，$n_2$个$a_2$$\cdots$ $n_k$ 个 $a_k$ 组成的多重集。S的全排列个数为：</p><p>​                                 <script type="math/tex">n! \over n_1!n_2!\cdots n_k!</script> </p><h4 id="6-多重集的组合数"><a href="#6-多重集的组合数" class="headerlink" title="6. 多重集的组合数"></a>6. 多重集的组合数</h4><p>n种不一样的球，每种球的个数是无限的，从中选k个出来组成一个多重集（不考虑元素的顺序），产生的不同多重集的数量为：</p><p>$C_{n+k-1} ^ {k-1}$ </p><p>如何证明？</p><p>设第 i 个元素选$x_i$ 个，问题转化为方程$x_1+x_2+\cdots+x_n = k$的非负整数解的个数。令$y_i = x_i + 1$ ,则答案为$y_1+y_2+\cdots y_n = k + n$ 的正整数解的个数。也就是说有$k+n$ 个 ”1“ 排成一排，问题等价于把这些“1” 分成 k 个部分，有多少种方法？</p><h4 id="7-不相邻的排列"><a href="#7-不相邻的排列" class="headerlink" title="7. 不相邻的排列"></a>7. 不相邻的排列</h4><p>$1\sim n$  这 n 个自然数中选k 个，这k 个数中任何两个数不相邻数的组合有 $C_{n-k+1}^k$种 </p><p>设取出来的k个数为：</p><p>$1 &lt; b_1 &lt; b_2 &lt; b_3 &lt; \cdots &lt; b_k \le n$ </p><p>要保证两数字没有相邻，那么两数相差至少间隔一</p><p>$1 \le b_1 &lt; b_2-1 &lt; b_3-2 &lt; b_4-3 &lt; \cdots &lt; b_k-k+1 \le n-k+1 $  </p><p>在这里，转换为了C系列，设$c[i] = b[i] - i + 1$ ，所以</p><p>$1 \le c_1 &lt; c_2 &lt; c_3 &lt; c_4 &lt; \cdots &lt; c_k \le n-k+1 $ </p><p>所以问题就变成：在n-k+1个元素种选中k 个组合数$C_{n-k+1}^k$</p><h4 id="8-错位排列"><a href="#8-错位排列" class="headerlink" title="8. 错位排列"></a>8. 错位排列</h4><p>胸口贴着编号为$1,2,\cdots,n$ 的 n 个球员分别住在编号为$1,2,\cdots ,n$ 的n个房间里面。现规定每个人住一个房间，自己的编号不能和房间的编号一样</p><p>设答案为 $d[n]$</p><p>只考虑第 n 个人，</p><p>假如n指定要和第 i 个人互换房间，那么其他 n - 2 个人怎么分不关他们的事情，这样的 i 有 n - 1 个，故这种情况对答案的贡献是$(n-1)$ 个 $d[n-2]$。</p><p>假如n只是要第 i 个人到他的房间，但他自己不去第 i 个房间，也就是说不是互换，那么该怎么思考呢？既然n不到第 i 个房间，那可以让n把自己胸口贴的标号换成 i ，假装自己是 i，然后错排$1\sim n$ 。这样他自己就一定不会呆在第 i 个房间了。所以有 n-1 个 d[n-1].</p><p>故答案为 $d[n] = (n-1)(d[n-1] + d[n-2]) (n\ge 3)$ </p><p>同时也有 $d[n] = n \times d[n-1]+ (-1)^n$</p><h4 id="9-圆排列"><a href="#9-圆排列" class="headerlink" title="9. 圆排列"></a>9. 圆排列</h4><p>n 个人全部来围成一圈为$Q_n^n$ ，其中已经排好的一圈，从不同位置断开，又变成不同的队列。所以：$Q_n^n \times n = A_n^n \rarr Q_n = (n-1)!$</p><p>由此可知部分圆排列为 $Q_n^r = {A_n^r \over r} = {n! \over r \times (n-r)!}$</p><h4 id="组合数求法"><a href="#组合数求法" class="headerlink" title="组合数求法"></a>组合数求法</h4><ol><li>递推公式$O(n^2)$ </li><li>定义（预处理阶乘）</li><li>数字比较大阶乘会爆的话就会取模。然后除法用逆元来算，卢卡斯可以更好的做这件事情</li></ol><h5 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h5><p>$C<em>n^k = C</em>{n\over p}^{k\over p} * C_{n\%p}^{k\%p} \pmod p$</p><p>洛谷P3807</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">ll n,m,p;</span><br><span class="line">ll j[N];</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a,ll b ,ll p)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (res * a)%p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((j[n] * <span class="built_in">pow</span>(j[m],p<span class="number">-2</span>,p))%p * <span class="built_in">pow</span>(j[n-m],p<span class="number">-2</span>,p)%p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n%p,m%p)*<span class="built_in">Lucas</span>(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    j[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">            j[i] = j[i<span class="number">-1</span>] * i % p;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">Lucas</span>(n+m,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-卡特兰数"><a href="#2-卡特兰数" class="headerlink" title="2. 卡特兰数"></a>2. 卡特兰数</h3><p>引子：给一个凸多边形，用n-3条不相交的对角线把它分成n-2个三角形，求不同的方法数目</p><ul><li>边$V_1V_n$在最终的剖分种一定会恰好属于某个三角形$V_1V_nV_k$ </li><li>两条边将多边形划分为了一个k边形和一个$n-k+1$边形</li></ul><p>故$f(n) = f(2)f(n-1) + f(3)f(n-2)+\cdots + f(n-1)f(2)$ </p><p>另一种思路：</p><p>考虑$V_1$ 的连线</p><p>$n(f(3)f(n-1) + f(4)f(n-2)+\cdots + f(n-1)f(3)$ 个部分</p><p>因为每个方案被计算了2n-6次，</p><p>$f(n) = (f(3)f(n-1) + f(4)f(n-2)+\cdots + f(n-1)f(3))\times n/(2n-6)$</p><p>上面两式合并可得：$f(n+1) = {4n-6\over n}f(n)$</p><p>上述这一种是紫书上面的推到方法，$f(1) = f(2) = 1$  </p><p>另一种例子</p><p>n 个 0， n 个1，排列m长度序列，满足任意前缀种0的个数不少于1的个数的序列的数量为$Cat<em>n = {C</em>{2n}^n\over n+1}$</p><p>若S不满足：任意前缀0的个数不小于1的个数</p><p>则至少存在一个最小的位置 $2*p+1\in [1,2n]$ 使得$s[1\sim 2p+1]$ 中有p个0，p+1个1</p><p>而把$s[2p+2\sim 2n]$中的所有数字取反后，包含n-p-1个0，n-p个1于是得到了n-1个0，n+1个1的序列</p><p>同理，令n-1个0，与n+1个1随意排成的序列，也必有一个最小的位置$2p’+1$，</p><p>使得$s’[1\sim2p’+1]$ 中有p’个0，p’+1个1</p><p>把s’剩下的一半取反，n个0，n个1排成的，存在一个前缀0比1多的序列</p><p>因此，以下两种序列构成一种双射</p><ol><li>由n个0，n个1构成的，存在一个前缀0比1多的序列</li><li>由n-1个0与n+1个1排成的序列</li></ol><p>根据组合数定义，后者有$C_{2n}^{n-1}$个</p><p>故$C<em>{2n}^n-C</em>{2n}^{n-1} = {C_{2n}^n\over n+1}$</p><p>$f(0) = f(1)  = 1$</p><p><strong>卡特兰数的其他例子</strong></p><ol><li>有 2n个人排成一行进入剧场。入场费 5 元。其中只有n 个人有一张 5 元钞票，另外 n人只有 10 元钞票，剧院无其它钞票，问有多少中方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？</li><li>一个栈（无穷大）的进栈序列为 n有多少个不同的出栈序列？</li><li>n个结点可够造多少个不同的二叉树？</li><li>一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？</li></ol><h3 id="3-斯特林数"><a href="#3-斯特林数" class="headerlink" title="3. 斯特林数"></a>3. 斯特林数</h3><h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><p>把n个不同的球分成r个非空循环排列的方法数</p><p>递推形式 : $s(n,r) = (n-1)s(n-1,r) + s(n-1,r-1),n&gt;r \ge 1$</p><p>考虑最后一个球，他可以单独构成一个非空循环排列，也可以插入到前面一个球的一侧。</p><p>若单独，则$s(n-1,r-1)$ ，若放在某个球的一侧，则$(n-1)s(n-1,r)$</p><h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><p>把n个不同的球放到r个盒子里，假设没有空盒，则放球方案数记作S(n,r)，称为第二类Stirling数</p><p>$S(n,r) = rS(n-1,r) + S(n-1,r-1),n&gt;r\ge 1$</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3625">http://acm.hdu.edu.cn/showproblem.php?pid=3625</a> </p><h3 id="4-康托展开"><a href="#4-康托展开" class="headerlink" title="4. 康托展开"></a>4. 康托展开</h3><p>求一个$1\sim n$的任意排列的排名</p><p>根据字典序排序，比如4的排列：[2,3,1,4] &lt; [2,3,4,1]，因为第3位出现不同，则[2,3,1,4]的排名在[ 2,3,4,1]前面。</p><p>给定一个排列，求它的排名。例子:[2,5,3,4,1]</p><ul><li>小于2 的数字为1，故有4!个排列在它前面</li><li>小于5的数字有1，2，3，4，但是2在前面用过了，所以有三个，故为3*3!</li><li>小于3的数字有1，2，2在前面用了，所以有一个，故为2！</li><li>…</li><li>答案为4! + 3*3! + 2! + 1 + 1 = 46，因为是计算排名，所以要多加一个1</li></ul><p>每次要用到当前有多少个小于它的数还没有出现，这里用树状数组统计比它小的数出现过的次数就行了。</p><p><strong>那如何通过给定一个排名来求排列呢？（即逆康托展开）</strong></p><p>如果我们知道一个排列的排名，就可以逆推出这个排列。因为4！是严格大于$3\times 3! + 2\times 2! + 1\times 1!$ 的，所以可以认为对于长度为5的排列，排名x除以4！向下取整就是有多少个数小于这个排列的第一位。</p><p>46-1 = 45</p><ul><li>$\lfloor{45\over 4!}\rfloor = 1$ ，有一个数小于它，所以第一位是2</li><li>45 - 4! = 21,$\lfloor{21\over 3!}\rfloor = 3$ ，有三个数小于它，去掉已经存在的2，这一位是5。</li><li>$21-3\times 3! = 3$  $\lfloor {3\over 2!}\rfloor = 1$，有一个数小于它，那么这一位就是3</li><li>…</li></ul><p>暴力$O(n^2)$，用线段树二分可以优化到$O(nlogn)$ </p><h3 id="5-容斥原理"><a href="#5-容斥原理" class="headerlink" title="5. 容斥原理"></a>5. 容斥原理</h3><p>$|A\cup B\cup C|=|A|+|B|+|C|-|A\cap B|-|B\cap C|-|C\cap A|+|A\cap B\cap C|$</p><p>设 U 中元素有 n 种不同的属性，而第 i 种属性称为 $P_i $, 拥有属性$P_i$ 的元素构成集合$S_i$，那么</p><script type="math/tex; mode=display">\begin{split} \left|\bigcup_{i=1}^{n}S_i\right|=&\sum_{i}|S_i|-\sum_{i<j}|S_i\cap S_j|+\sum_{i<j<k}|S_i\cap S_j\cap S_k|-\cdots\\ &+(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^{m}S_{a_i}\right|+\cdots+(-1)^{n-1}|S_1\cap\cdots\cap S_n| \end{split}</script><p> 即：</p><script type="math/tex; mode=display">\left|\bigcup_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^mS_{a_i}\right|</script><p>补集：</p><script type="math/tex; mode=display">\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|</script><h4 id="多重集的组合数（不定方程非负整数解计数）"><a href="#多重集的组合数（不定方程非负整数解计数）" class="headerlink" title="多重集的组合数（不定方程非负整数解计数）"></a>多重集的组合数（不定方程非负整数解计数）</h4><blockquote><p>给出不定方程$\Sigma_{i=1}^nx_i = m$ 和 n 个限制条件$x_i \leq b_i$，其中$m,b_i\leq N$,求方程的非负整数解的个数</p></blockquote><p>若没有$x<em>i \le b_i$的限制，那么答案是$C</em>{m+n-1}^{n-1}$ 证明用插板法</p><p>容斥模型：</p><ol><li><p>全集U ： 不定方程$\Sigma_{i=1}^nx_i = m$的非正整数解</p></li><li><p>元素：变量$x_i$</p></li><li><p>属性：$x_i$ 的属性即$x_i$满足的条件，即$x_i\leq b_i$的条件</p></li><li><p>目标：所有变量满足对应属性时集合的大小，即$|\bigcap_{i=1}^nS_i|$</p><script type="math/tex; mode=display">\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|</script><p>$|U|$可以用组合数计算，后半部分用容斥定理计算</p><p>$\overline{S_i}$ 的含义是表示至少包含$b_i+1$个$a_i$的多重集。</p><p>则$\overline{S<em>i}$的个数是：$C</em>{n+m-b_i-2}^{n-1}$ </p><p>进一地，$\overline{S<em>i}\overline{S_j}$ 为：$C</em>{n+m-b_i-b_j-3}^{n-1}$</p><p>由容斥定理</p><script type="math/tex; mode=display">\left|\bigcup_{i=1}^m\overline{S_i}\right| = \sum_{i=1}^mC_{n+m-b_i-2}^{n-1} - \sum_{1\leq i<j\leq m}C_{n+m-b_i-b_j-3}^{n-1}+\cdots\\    +(-1)^{m+1}C_{n+m-\sum_{i=1}^mn_i-(m-1)}^{n-1}</script><h5 id="例题：Devu-and-Flowers（CF451E）"><a href="#例题：Devu-and-Flowers（CF451E）" class="headerlink" title="例题：Devu and Flowers（CF451E）"></a>例题：Devu and Flowers（CF451E）</h5><p>Devu有N个盒子，第 i 个盒子中有$A_i$枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu要从这些盒子中选出M枝花组成一束，求共有多少种方案。若两束花每种颜色的花的颜色都相同，则认为这两束花是相同的方案。输出对$10^9+7$取模之后的结果即可。$1\leq N\leq20,1\le M\le 10^{14},0\leq A_i\leq 10^{12}$</p><ul><li>二进制枚举</li><li>N很小，M很小，计算组合数会爆ll</li><li>Lucas，乘法逆元</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">22</span>],j[<span class="number">22</span>],m,ans=<span class="number">0</span>;</span><br><span class="line">ll inv[<span class="number">22</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)res = (res * a)%mod;</span><br><span class="line">        a = a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll y,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> || y &lt; x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    y %= mod;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span> || x == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">        res = res * (y-i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//res = res * inv[x] % mod;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">        res = res * inv[i]%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    j[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//j[i] = j[i-1] * i % mod;</span></span><br><span class="line">        inv[i] = <span class="built_in">power</span>(i,mod<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x &lt; (<span class="number">1</span>&lt;&lt;n);x++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            ans = (ans + <span class="built_in">C</span>(n+m<span class="number">-1</span>,n<span class="number">-1</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll t = n + m;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    p ++ ;</span><br><span class="line">                    t -= a[i<span class="number">+1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            t -= p + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = (ans - <span class="built_in">C</span>(t,n<span class="number">-1</span>))%mod;</span><br><span class="line">            <span class="keyword">else</span> ans = (ans + <span class="built_in">C</span>(t,n<span class="number">-1</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="例题：HAOI2008-硬币购物"><a href="#例题：HAOI2008-硬币购物" class="headerlink" title="例题：HAOI2008 硬币购物"></a>例题：HAOI2008 硬币购物</h5><p><a href="https://www.luogu.org/problemnew/show/P1450">https://www.luogu.org/problemnew/show/P1450</a> </p><p>4种面值的硬币，第 i 种的面值是$C_i$。n次询问，每次询问给出每种硬币的数量$D_i$和一个价格S，问付款方式。$n\leq 10^3 ,S\leq 10^5$</p><p>如果用背包做的话，复杂度是O(4nS)，无法承受。</p><p>$\sum_{i=1}^4C_ix_i = S, x_i\leq D_i$的非负整数解的个数</p><p>采用同样的容斥方式，$x_i$的属性为$s_i\leq D_i$，套用容斥原理的公式</p><script type="math/tex; mode=display">\sum_{i=1}^4C_ix_i = S-\sum_{i=1}^kC_{a_i}(D_{a_i}+1)</script><p>S可由无限背包来打表求，后面的用容斥定理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll c[<span class="number">5</span>],d[<span class="number">5</span>],tot,s;</span><br><span class="line">ll f[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>,&amp;c[<span class="number">1</span>],&amp;c[<span class="number">2</span>],&amp;c[<span class="number">3</span>],&amp;c[<span class="number">4</span>],&amp;tot);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= c[j])&#123;</span><br><span class="line">                f[i] += f[i-c[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tot--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>,&amp;d[<span class="number">1</span>],&amp;d[<span class="number">2</span>],&amp;d[<span class="number">3</span>],&amp;d[<span class="number">4</span>],&amp;s);</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">            ll t = s,p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                    t -= (d[j<span class="number">+1</span>] + <span class="number">1</span>) * c[j<span class="number">+1</span>],p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p &amp; <span class="number">1</span>) res += f[t];</span><br><span class="line">                <span class="keyword">else</span> res -= f[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[s] - res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mobius函数"><a href="#Mobius函数" class="headerlink" title="Mobius函数"></a>Mobius函数</h4><p>$\mu$ 为莫比乌斯函数</p><script type="math/tex; mode=display">\mu(n)= \begin{cases} 1&n=1\\ 0&n\text{ 含有平方因子}\\ (-1)^k&k\text{ 为 }n\text{ 的本质不同质因子个数}\\ \end{cases}</script><p>通俗的讲，当n包含相等的质因子时，$\mu(N)=0$ 。当N的所有质因子各不相等时，若N有偶数个质因子，$\mu(N) = 1$，若N有奇数个质因子，$\mu(N)=-1$ 。</p><p>若只求一项Mobius函数，则分解质因数即可计算，若求 $1\sim N$的每一项Mobius函数，可以利用线性筛法来求mobius函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])p[++tot] = i,mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i * p[j] &lt;= n;++j)&#123;</span><br><span class="line">            flg[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                mu[i * p[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * p[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-抽屉原理（鸽巢原理）"><a href="#6-抽屉原理（鸽巢原理）" class="headerlink" title="6.抽屉原理（鸽巢原理）"></a>6.抽屉原理（鸽巢原理）</h3><p> 就比如说，你有 n+1 个苹果，想要放到 n 个抽屉里，那么必然会有至少一个抽屉里有两个（或以上）的苹果。</p><p>这个定理看起来比较显然，证明方法考虑反证法：假如所有抽屉都至多放了一个苹果，那么 n个抽屉至多只能放n个苹果，矛盾。</p><h2 id="概率-amp-数学期望"><a href="#概率-amp-数学期望" class="headerlink" title="概率&amp;数学期望"></a>概率&amp;数学期望</h2><h3 id="1-概率"><a href="#1-概率" class="headerlink" title="1. 概率"></a>1. 概率</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果在相同条件下，进行了n次试验，事件A发生了$N_A$次，那么$N_A \over n$被称为事件A发生的概率</p><h4 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h4><ul><li>非负性：对于一个事件A，有概率$P(A)\in [0,1]$</li><li>规范性：事件空间的概率值为1，$P(S) = 1$</li><li>容斥性：若$P(A+B) = P(A)+P(B)$，则 A 和 B 互为独立事件。</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><h5 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h5><p>若事件$A<em>1,A_2,\cdots ,A_n$构成一个完备的事件且都有正概率，即$且\forall i,j,A_i\cap A_j=\varnothing 且\sum</em>{i=1}^nA<em>i=1$，有$P(B) = \sum</em>{i=1}^nP(A_i)P(B|A_i))$</p><p>例子：参加比赛拿金概率0.1，拿银概率0.2，拿铜概率0.3，这三种情况下，你被妈妈表扬的概率是：1.0，0.8，0.6，那么你被妈妈表扬的总概率就是$0.1\times 1.0+0.2\times 0.8+0.3\times 0.6 = 0.44$  </p><h5 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h5><script type="math/tex; mode=display">P(B_i|A) = {P(B_i)*P(A|B_i)\over \sum_{j=1}^nP(B_j)P(A|B_j)}</script><h3 id="2-期望"><a href="#2-期望" class="headerlink" title="2.期望"></a>2.期望</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>在一定区间内变量取值为有限个，或数值可以一一列举出来的变量称为离散型随机变量。一个离散型随机变量的数学期望是在试验中每次可能的结果乘以其结果概率的总和。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><strong>全期望公式</strong> ：$E(Y) = E[E(Y|X)]$。可由全概率公式证明。</p><p><strong>线性性质</strong>  ：对于任意两个随机事件$x,y$（不要求相互独立），有$E(X+Y) = E(X) + E(Y)$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-麻球繁衍-UVA-11021"><a href="#1-麻球繁衍-UVA-11021" class="headerlink" title="1. 麻球繁衍(UVA-11021)"></a>1. 麻球繁衍(UVA-11021)</h3><p>有k只麻球，每只活一天就会死亡，临死之前可能会生出一些新的麻球。具体来说，生 i 个麻球的概率为$P_i$。给定m，求m天后所有麻球均死亡的概率。注意，不足m天时就已全部死亡的情况也算在内。</p><p>核心：递推，找出递推所依靠的东西</p><p>$f(i)$为一开始只有一个麻球的时候，在 i 天后所有麻球均死亡的概率。</p><p>则有：$f(i) = P<em>0 + P_1 <em>f(i-1) + P_2</em>[f(i-1)]^2 + \cdots + P</em>{n-1}*[f(i-1)]^{n-1}$ </p><p>因为每个麻球死亡是独立的。所以答案为$f(m)^k$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">double</span> f[N],p[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;p[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">double</span> t = <span class="number">1</span>;</span><br><span class="line">            f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                f[i] += t * p[j];</span><br><span class="line">                t *= f[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; f[i] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            res *= f[m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %.6f\n&quot;</span>,++cas,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-玩纸牌（UVA-11427）"><a href="#2-玩纸牌（UVA-11427）" class="headerlink" title="2. 玩纸牌（UVA-11427）"></a>2. 玩纸牌（UVA-11427）</h3><p>每天晚上你都玩纸牌游戏，如果第一次就赢了就高高兴兴地去睡觉，如果输了就继续玩。假设每盘游戏你获胜地概率都是p，且各盘游戏的输赢都是独立的。你是一个固执的完美主义者，因此会一直玩到当晚获胜局面的比例严格大于p时才停止，然后高高兴兴地去睡觉。当然，晚上的时间有限，最多只能玩n盘游戏，如果获胜比例一直不超过p的话，你只能垂头丧气地去睡觉，以后再也不玩纸牌了。你的游戏是计算出平均情况下，你会玩多少个晚上的纸牌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">double</span> d[N][N];<span class="comment">//i局获胜j局概率</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);<span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d %d&quot;</span>,&amp;a,&amp;b,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j &lt;= i &amp;&amp; j * b &lt;= a * i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                d[i][j] = d[i<span class="number">-1</span>][j<span class="number">-1</span>] *  a / b + d[i<span class="number">-1</span>][j] * (<span class="number">1.0</span> - a * <span class="number">1.0</span> / b);</span><br><span class="line">                <span class="keyword">else</span> d[i][j] = d[i<span class="number">-1</span>][j] * (<span class="number">1</span> - a * <span class="number">1.0</span> / b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> Q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)Q += d[n][i];</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Q &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,++cas,(<span class="type">int</span>)(<span class="number">1.0</span>/Q));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-得到1（UVA-11762"><a href="#3-得到1（UVA-11762" class="headerlink" title="3. 得到1（UVA 11762)"></a>3. 得到1（UVA 11762)</h3><p>给出一个整数N，每次可以在不超过N的素数中随机选择一个P6 ，如果P是N的约数，则把N变成N/P，否则N不变。问平均情况下需要多少次随机选择，才能把N变成1？比如N=3时答案为2，N=13时答案为6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">double</span> d[N],vis[N];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">int</span> p[N],v[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">primes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])p[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; p[j] * i &lt; N;j++)&#123;</span><br><span class="line">            v[p[j]*i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x])<span class="keyword">return</span> d[x];</span><br><span class="line">    vis[x] += <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p[i] &lt;= x;i++)&#123;</span><br><span class="line">        num ++;</span><br><span class="line">        <span class="keyword">if</span>(x % p[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            d[x] += <span class="built_in">dp</span>(x/p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;x &lt;&lt; &#x27; &#x27; &lt;&lt;num &lt;&lt; &#x27; &#x27; &lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">    d[x] += num;</span><br><span class="line">    d[x] /= cnt;</span><br><span class="line">    <span class="keyword">return</span> d[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">primes</span>();</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %.6f\n&quot;</span>,++cas,<span class="built_in">dp</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-决斗（UVA-1636）"><a href="#4-决斗（UVA-1636）" class="headerlink" title="4. 决斗（UVA-1636）"></a>4. 决斗（UVA-1636）</h3><p>​    首先在枪里装一些子弹，然后扣了一枪，发现没有子弹。你希望下一枪也没有子弹，是应该直接再扣一枪（输出SHOOT）呢，还是随即转一下再扣（输出ROTATE)？如果这两种策略下没有子弹的概率相等，输出EQUAL.</p><p>​    手枪里的子弹可以看成一个循环序列，开枪一次以后对准下一个位置。例如子弹序列为0011时，第一次开枪前一定在位置1或2（因为第一枪没有子弹），因此开枪之后位于位置2或3。如果此时开枪，有一半的概率没有子弹。序列长度为2~100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> a,b,len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        s[len] = s[<span class="number">0</span>];</span><br><span class="line">        a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                a++;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">+1</span>]==<span class="string">&#x27;0&#x27;</span>)b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s1 = b*len,s2 = a*a;</span><br><span class="line">        <span class="keyword">if</span>(s1&gt;s2)<span class="built_in">puts</span>(<span class="string">&quot;SHOOT&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1==s2)<span class="built_in">puts</span>(<span class="string">&quot;EQUAL&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;ROTATE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-奶牛和轿车-UVA-10491"><a href="#5-奶牛和轿车-UVA-10491" class="headerlink" title="5. 奶牛和轿车(UVA-10491)"></a>5. 奶牛和轿车(UVA-10491)</h3><p>在a+b扇门，a扇后面是牛，b扇后面是车。在你选择一扇门后，主持人为你打开另外c个有奶牛的门（$1\le a\le 10000, 1\le b \le 10000, 0\le c &lt; a$），输出此刻你选择换门之后赢得车的概率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> a,b,c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)&#123;</span><br><span class="line">        <span class="type">double</span> res = (a*b+b*b-b)/(a+b)/(a+b-c<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-条件概率-UVA-11181"><a href="#6-条件概率-UVA-11181" class="headerlink" title="6. 条件概率(UVA-11181)"></a>6. 条件概率(UVA-11181)</h3><p>有 n 个人准备去超市逛，其中第 i 个人买东西的概率是$P_i$。 逛完以后你得知有 r 个人买了东西。根据这一信息，请计算每个人实际买了东西的概率。输入 n ($1\le n \le 20$) 和 r ($0\le r \le n$), 输出每个人买东西的概率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> a[<span class="number">30</span>],sum,q[<span class="number">30</span>],v[<span class="number">30</span>],tot,cur;</span><br><span class="line"><span class="type">int</span> n,r;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n<span class="number">+1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot==r)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;cur&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i])v[i] += cur;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x] = <span class="number">1</span>;</span><br><span class="line">    tot++;</span><br><span class="line">    cur *= q[x];</span><br><span class="line">    <span class="built_in">dfs</span>(x<span class="number">+1</span>);</span><br><span class="line">    tot--;</span><br><span class="line">    cur /= q[x];</span><br><span class="line">    a[x] = <span class="number">0</span>;</span><br><span class="line">    cur *= (<span class="number">1</span>-q[x]);</span><br><span class="line">    <span class="built_in">dfs</span>(x<span class="number">+1</span>);</span><br><span class="line">    cur /= (<span class="number">1</span>-q[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;r==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        cur = <span class="number">1</span>;sum = <span class="number">0</span>;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;q[i];</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,++cas);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.6f\n&quot;</span>,v[i]/sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-纸牌游戏-UVA-1637"><a href="#7-纸牌游戏-UVA-1637" class="headerlink" title="7. 纸牌游戏(UVA-1637)"></a>7. 纸牌游戏(UVA-1637)</h3><p>36张牌分成9堆，每堆4张牌。每次可以拿走某两堆顶部的牌，但需要点数相同。如果有多种拿法则等概率的随机拿。例如，9堆顶部的牌分别为KS,KH,KD,9H,8S,8D,7C,7D,6H，则有5种拿法(KS,KH),(KS,KD),(KH,KD),(8S,8D),(7C,7D)，每种拿法的概率均为1/5。如果最后拿完所有牌则游戏成功。按顺序给出每堆的四张牌，求成功概率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> card[<span class="number">9</span>][<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">map&lt;vector&lt;<span class="type">int</span>&gt;,<span class="type">double</span>&gt; d;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">readcard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,card[i][j])!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cnt,<span class="type">int</span> c)</span>       <span class="comment">//返回的是cnt这种状态下成功的几率 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;                  <span class="comment">//已经成功了 </span></span><br><span class="line"><span class="keyword">if</span>(d.<span class="built_in">count</span>(cnt)!=<span class="number">0</span>) <span class="keyword">return</span> d[cnt];  <span class="comment">//表明此状态已经计算过了(记忆化搜索) </span></span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;                          <span class="comment">//记录决策数 </span></span><br><span class="line"><span class="type">double</span> sum=<span class="number">0</span>;                        </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++) <span class="keyword">if</span>(cnt[i])     <span class="comment">//第i堆牌的数量&gt;0 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;<span class="number">9</span>;j++) <span class="keyword">if</span>(cnt[j])   <span class="comment">//第i堆牌的数量&gt;0</span></span><br><span class="line"><span class="keyword">if</span>(card[i][cnt[i]<span class="number">-1</span>][<span class="number">0</span>]==card[j][cnt[j]<span class="number">-1</span>][<span class="number">0</span>])  <span class="comment">////第i堆牌的第一张和第j堆牌的第一张一样 </span></span><br><span class="line">&#123;</span><br><span class="line">tot++;</span><br><span class="line">cnt[i]--;cnt[j]--;</span><br><span class="line">sum+=<span class="built_in">dp</span>(cnt,c<span class="number">-2</span>);             <span class="comment">//sum计算所有此状态下成功的概率 </span></span><br><span class="line">cnt[i]++;cnt[j]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!tot) <span class="keyword">return</span> d[cnt]=<span class="number">0</span>;        <span class="comment">//这种状态下不可能成功 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> d[cnt]=sum/tot ;      <span class="comment">//这种状态下成功的几率均分为tot份 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">readcard</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">9</span>,<span class="number">4</span>)</span></span>;  <span class="comment">//表示状态;</span></span><br><span class="line">d.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,<span class="built_in">dp</span>(cnt,<span class="number">36</span>)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-过河-UVA-12230"><a href="#8-过河-UVA-12230" class="headerlink" title="8. 过河(UVA-12230)"></a>8. 过河(UVA-12230)</h3><p>​    你住在村庄A，每天需要过很多条河到另一个村庄B上班。B在A的右边，所有的河都在中间。幸运的是，每条河上都有匀速移动的自动船，因此每当到一条河的左岸时，只需等船过来，载着你过河，然后在右岸下船。你很瘦，因此上船之后船速不变。</p><p>​    从A到B，平均情况下需要多久时间？假设在出门时所有船的位置都是均匀随机分布的。如果位置不是在河的端点处，则朝向也是均匀随机。在陆地上行走的速度为1</p><p>​    给出AB之间河的个数，长度D，以及每条河的左端离A的距离p，长度L和移动速度v，输出A到B的数学期望。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,D;</span><br><span class="line"><span class="type">double</span> p,L,v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;D)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; D == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="type">double</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            cin&gt;&gt;p&gt;&gt;L&gt;&gt;v;</span><br><span class="line">            time += <span class="number">2.0</span> * L / v;</span><br><span class="line">            D -= L;</span><br><span class="line">        &#125;</span><br><span class="line">        time += D;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %.3f\n\n&quot;</span>,++cas,time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-糖果-UVA-1639"><a href="#9-糖果-UVA-1639" class="headerlink" title="9. 糖果(UVA-1639)"></a>9. 糖果(UVA-1639)</h3><p>有两个盒子各有 n ($n\le 2\times 10^5$)个糖，每天随机选一个（概率分别为p，1-p），然后吃一颗糖。直到有一天，打开盒子一看，没糖了！输入n，p，求此时另一个盒子里糖的个数的数学期望。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span><span class="number">+10</span>;</span><br><span class="line">db loglc[N],p;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">db <span class="title">logC</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loglc[n] - loglc[m] - loglc[n-m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    loglc[<span class="number">0</span>] = <span class="built_in">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        loglc[i] = loglc[i<span class="number">-1</span>] + <span class="built_in">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;p)&#123;</span><br><span class="line">        db res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            db v1 = <span class="built_in">logC</span>(<span class="number">2</span>*n-i,n) + (n<span class="number">+1</span>) * <span class="built_in">log</span>(p) + (n-i) * <span class="built_in">log</span>(<span class="number">1</span>-p);</span><br><span class="line">            db v2 = <span class="built_in">logC</span>(<span class="number">2</span>*n-i,n) + (n<span class="number">+1</span>) * <span class="built_in">log</span>(<span class="number">1</span>- p) + (n-i) * <span class="built_in">log</span>(p);</span><br><span class="line">            res += i * (<span class="built_in">exp</span>(v1) + <span class="built_in">exp</span>(v2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %.6Lf\n&quot;</span>,++cas,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-优惠券-UVA-10288"><a href="#10-优惠券-UVA-10288" class="headerlink" title="10. 优惠券(UVA-10288)"></a>10. 优惠券(UVA-10288)</h3><p>大街上到处在卖彩票，一元钱一张。购买撕开它上面的锡箔，你会看到一个漂亮的图案。图案有n种，如果你收集到所有 n ($n\le 33$)种彩票，就可以得大奖。请问，在平均情况下，需要买多少张彩票才能得到大奖呢？如 n = 5 时答案为137/12。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">35</span>],b[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creat</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> up = n,down = n - (i<span class="number">-1</span>);</span><br><span class="line">        b[i] = b[i<span class="number">-1</span>] * down + a[i<span class="number">-1</span>] * up;</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] * down;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> gcd = __gcd(a[i],b[i]);</span><br><span class="line">        a[i] /= gcd;</span><br><span class="line">        b[i] /= gcd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) x/=<span class="number">10</span>,res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;x)&#123;</span><br><span class="line">        <span class="built_in">creat</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(a[x] == <span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,b[x]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="built_in">count</span>(b[x] / a[x]);</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">max</span>(<span class="built_in">count</span>(b[x] % a[x]),<span class="built_in">count</span>(a[x]));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pre<span class="number">+1</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,b[x]%a[x]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,b[x] / a[x]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pre<span class="number">+1</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-危险的组合-UVA-580"><a href="#11-危险的组合-UVA-580" class="headerlink" title="11. 危险的组合(UVA-580)"></a>11. 危险的组合(UVA-580)</h3><p>​    有一些装有铀（U）和铅（L）得盒子，数量均足够多。要求把n($n\le 30$) 个盒子放在一行，但至少有3个U放在一起，有多少种方法？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll p2[<span class="number">35</span>];</span><br><span class="line">ll f[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;i++)p2[i] = p2[i<span class="number">-1</span>] * <span class="number">2ll</span>;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = f[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">3</span>;n&lt;=<span class="number">30</span>;n++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i &lt;= n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            f[n] += (p2[i<span class="number">-2</span>] - f[i<span class="number">-2</span>]) * p2[n-i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        f[n] += p2[n<span class="number">-3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-比赛名次-UVA-12034"><a href="#12-比赛名次-UVA-12034" class="headerlink" title="12. 比赛名次(UVA-12034)"></a>12. 比赛名次(UVA-12034)</h3><p>​    A，B两人赛马，最终名次有3种可能：并列第一；A第一B第二；B第一A第二。输入n($1\le n\le 1000$)，求n人赛马时最终名次的可能性的个数除以10056的余数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">10056</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            f[i] = (f[i] + C[i][j] * f[i-j] %mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T,n;cin&gt;&gt;T;</span><br><span class="line">    <span class="type">int</span> cas = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,++cas,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-杆子的排列-UVA-1638"><a href="#13-杆子的排列-UVA-1638" class="headerlink" title="13. 杆子的排列(UVA-1638)"></a>13. 杆子的排列(UVA-1638)</h3><p>​    有高为$1,2,3,\cdots n$的杆子各一根排成一行。从左边能看到 $l$ 根，从右边能看到$r$ 根，求有多少种可能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,l,r;</span><br><span class="line">ll d[<span class="number">22</span>][<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line">        d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        d[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                    d[k][i][j] = d[k<span class="number">-1</span>][i<span class="number">-1</span>][j] + d[k<span class="number">-1</span>][i][j<span class="number">-1</span>] + d[k<span class="number">-1</span>][i][j] * (k<span class="number">-2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,d[n][l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 概率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019暑期集训第一讲：博弈论</title>
      <link href="/2019/07/16/gameTheory/"/>
      <url>/2019/07/16/gameTheory/</url>
      
        <content type="html"><![CDATA[<p>主讲人：段英鹏<br>时间：7.17</p><h1 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h1><ul><li><h5 id="本次简单博弈论讲解六个知识点："><a href="#本次简单博弈论讲解六个知识点：" class="headerlink" title="本次简单博弈论讲解六个知识点："></a>本次简单博弈论讲解六个知识点：</h5><ul><li>1：bash博弈；2：nim博弈；3：威佐夫博弈；5：Fibonacci博弈；6：sg函数；</li></ul></li><li><h5 id="首先介绍博弈论问题有如下几个特点"><a href="#首先介绍博弈论问题有如下几个特点" class="headerlink" title="首先介绍博弈论问题有如下几个特点"></a>首先介绍博弈论问题有如下几个特点</h5><ul><li>1：博弈模型为两人轮流决策的博弈。并且两人都使用最优策略来取得胜利。<ul><li>两个玩家，都会采取最优的决策，那么如果存在一个局面为必胜局面，某玩家位于此局面。只要自己无失误，则必胜。那么同样又一个局面为必败局面，某玩家位于此局面。只要对手无失误，则必败。</li><li>那也就是说，针对这样的游戏，我们关注点应该在局面上。</li></ul></li><li>2：博弈是有限的。即无论两人如何决策，都会在有限步决出胜负。</li><li>3：博弈是公平的。即两人进行决策的规则相同。</li></ul></li><li><h5 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h5><ul><li>先手必胜状态：先手可以从这个状态走到某一个必败状态。</li><li>先手必败状态：先手走不到任何一个必败状态。</li><li>也就是说先手必胜状态，那么先手一定能采取某些操作，让后手面对必败态。如果是先手必败态，无论先手怎么操作，都无法让后手面对必败态。</li></ul></li></ul><h2 id="bash博弈"><a href="#bash博弈" class="headerlink" title="bash博弈"></a>bash博弈</h2><ul><li>假设一堆石子有n个，每次最多取m个，甲乙两个玩家轮流取石子，最后把石子取完的人获胜，保证甲乙每一步的决策都是最优的，请问给定n和m，问甲胜还是乙胜。<ul><li>不妨假设刚刚开始<code>n = m + 1</code>，那么后手必胜，有如下结论：<ul><li>令 <code>n = ( m + 1 ) * r + s</code> 其中<code>(r &gt; 1，0 &lt;= s &lt; m + 1)</code>。如果s=0的话，先手每次取k个，后手只要取(m+1-k)个即可，后手必赢。如果s!=0的话，先手者第一次取s个，后手第一次取k个，接下来先手只要取<code>(m + 1 - k)</code>个即可，先手必赢。</li><li>所以只需考虑 是否为0就可以判定结果。余为0，先手必败，反之必胜。</li></ul></li></ul></li><li>例题：<ul><li>hdu_2188</li><li>hdu_1846</li><li>hdu_1847</li></ul></li></ul><h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><ul><li><p>假设有n堆石子，每堆石子分别有$a_1, a_2,…,a_n$个,每次可以选择任意一堆且至少取1枚石子,<br>甲乙两个玩家轮流取石子, 最后把石子取完的人获胜, 保证甲乙每一步的决策都是最优的, 甲为先手操作, 问甲胜还是乙胜。</p></li><li><h5 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h5><ul><li>设若$a_1\land a_2\land …\land a_n$则先手必败, 反之必胜。 </li></ul></li><li><h5 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h5><ul><li><p>1):考虑极端情况, 当$a_1, a_2,a_3…a_n$全为0时, res = 0, 此时先手无法操作, 先手必败。</p></li><li><p>2):当$res = x ≠ 0$时,我们取$res$最高位$1$,设最高位$1$为第$k$位,则一定存在$a_i$第$k$位为$1$。对于此,我们可以反证, 若$a$中所有第$k$位全为$0$, 则$res$第$k$位也为$0$, 矛盾。</p></li><li><p>所以我们让$a_i\land x, 我们可以得出$$a_i\land x &lt; a_i $。那么我们完全可以从​$a_i$中拿走​$a_i\land x$, 即​$a_i  -a_i\land x&gt;0$, 最后剩下​$a_i  -(a_i  -a_i\land x) = a_i\land x$; </p></li><li><p>此时后手的局面为$res = a_1  \land a_2\land ,…,\land a_i\land x,…,\land a_n=x\land x=0$</p></li><li><p>即先手通过一定的操作让后手面对$res=0$的情况。</p></li><li><p>•3): 当$res = x = 0$且$a$不全为$0$时, 我们无法通过任何操作让下一个状态的$res$也为$0$。这一步的证明可以采用反证法。</p><p>•若存在$a_i $拿走一定的石子变为$a_i^′$且res不变。</p><p>•在目前状态$res= a_1\land a_2\land ,…,\land a_i\land ,…,\land a_n=0$设为①式。</p><p>•在下个状态$res= a_1\land a_2\land ,…,\land a_i^′\land ,…,\land a_n=0$设为②式。</p><p>•$①\land ② $= $0\land 0$  =&gt; $ a_i\land a_i^′  = 0$</p><p>•即$a_i= a_i^′$, 与假设矛盾。</p></li></ul></li><li><p>综上所述, 当$a$不全为$0$时, 任意一个$res != 0$的局面, 先手可以通过一定的操作让后手面对$res = 0$的局面。</p></li><li><p>对于任意一个$res = 0$的局面, 先手无法通过任何操作让后手面对$res = 0$的局面。</p></li><li><p>得出结论, 当$res = 0$时先手必败, 反之必胜。</p></li></ul><h2 id="Nim博弈拓展-台阶Nim"><a href="#Nim博弈拓展-台阶Nim" class="headerlink" title="Nim博弈拓展-台阶Nim"></a>Nim博弈拓展-台阶Nim</h2><ul><li><p>问题描述: 有一个$n$级台阶的楼梯, 每级台阶上有若干个石子, 其中第i级台阶上有$a_i$个石子$(i≥1)$。两位玩家路轮流操作, 每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶上(不能不拿)。</p></li><li><p>已经拿到地面的石子不能再拿, 最后无法进行操作的人视为失败。</p></li><li><p>问如果两人都采取最优策略, 先手是否必胜.</p></li><li><h5 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h5><ul><li>$res= a_1\land a_3\land a_5\land ,…,\land a_n=0$(当然这里的n是奇数)先手必败, 反之先手必胜。</li></ul></li><li><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5></li><li><p>1): 考虑极端情况, 当$a_1, a_3,…,a_n$全为0时, $res = 0$, 此时先手只能将偶数级台阶往下搬, 后手只需要将先手从偶数级台阶上搬下来的石子全部搬到下一级偶数级台阶, 先手必败。</p></li><li><p>2): 当$res = x ≠ 0$时, 通过经典Nim游戏的证明, 我们知道一定有一种方法搬一定的石子到下一级让后手面对res为0的局面。</p></li><li><p>3):当$res = x = 0$且$a$不全为$0$时, 我们无法通过任何操作让下一个状态的$res$也为$0$。</p></li><li><p>即对于$res$不为$0$的情况, 先手总能通过一定的操作让后手面对$res$为$0$的情况,。</p></li><li><p>然而$res$为$0$时, 先手无论做什么操作都无法让后手面对$res$为$0$的情况。</p></li><li><p>那么此刻我们就将题目转化为在奇数台阶上的经典Nim游戏。</p></li><li><h6 id="思考题"><a href="#思考题" class="headerlink" title="思考题:"></a>思考题:</h6></li><li><p>为什么不用$res= a_2\land a_4\land a_6\land ,…,\land a_n=0$(n为偶数)来判定胜负？</p><ul><li>因为当先手搬去一定的石子让后手面对$res=0$的情况, 后手可以搬去一号台阶的石子到地面让先手重新面对$res=0$的情况</li></ul></li><li><h5 id="例题"><a href="#例题" class="headerlink" title="例题:"></a>例题:</h5><ul><li><p>hdu_1850(经典Nim)</p></li><li><p>```c++</p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<bits stdc++.h></bits></h1><p>using namespace std;<br>const int maxn = 100 + 10;<br>int n, a[maxn], res;<br>int main()<br>{</p><pre><code>while(cin &gt;&gt; n)&#123;    if(!n) break;    res = 0;    for(int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];        res ^= a[i];    &#125;    if(res == 0) puts(&quot;0&quot;);    else    &#123;        int ans = 0;        for(int i = 1; i &lt;= n; i++)        &#123;            if((res ^ a[i]) &lt; a[i]) ans ++;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;&#125;return 0;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- hdu_1730(经典Nim)</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  #include&lt;bits/stdc++.h&gt;</span><br><span class="line">  using namespace std;</span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">      int n, m;</span><br><span class="line">      while(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">      &#123;</span><br><span class="line">          int res = 0;</span><br><span class="line">          for(int i = 1; i &lt;= n; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              int a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">              res = res ^ (abs(a - b) - 1);</span><br><span class="line">          &#125;</span><br><span class="line">          if(res == 0) puts(&quot;BAD LUCK!&quot;);</span><br><span class="line">          else puts(&quot;I WIN!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>poj_1704(台阶Nim)</p></li><li><p>```c++</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<iostream></iostream></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<cstdio></cstdio></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include"></a>include<algorithm></algorithm></h1><h1 id="include-4"><a href="#include-4" class="headerlink" title="include"></a>include<cstring></cstring></h1><p>using namespace std;<br>const int maxn = 1000 + 10;<br>int a[maxn], d[maxn];<br>int main()<br>{</p><pre><code>int T; cin &gt;&gt; T;while(T--)&#123;    int n; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    sort(a + 1, a + 1 + n);    for(int i = 1; i &lt;= n; i++)        d[i] = a[i] - a[i - 1] - 1;    int res = 0;    for(int i = n; i &gt; 0; i -= 2)        res ^= d[i];    if(res) puts(&quot;Georgia will win&quot;);    else puts(&quot;Bob will win&quot;);&#125;return 0;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- hdu_4315(台阶Nim)</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  #include&lt;bits/stdc++.h&gt;</span><br><span class="line">  using namespace std;</span><br><span class="line">  const int maxn = 1e3 + 10;</span><br><span class="line">  int a[maxn];</span><br><span class="line">  int n, k;</span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">      while(cin &gt;&gt; n &gt;&gt; k)</span><br><span class="line">      &#123;</span><br><span class="line">          memset(a, 0, sizeof a);</span><br><span class="line">          for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">          if(k == 1) puts(&quot;Alice&quot;);</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              int res = 0;</span><br><span class="line">              if(n &amp; 1)</span><br><span class="line">              &#123;</span><br><span class="line">                  if(k == 2) res ^= a[1] - 1;</span><br><span class="line">                  else res ^= a[1];</span><br><span class="line">                  for(int i = 3; i &lt;= n; i += 2)</span><br><span class="line">                      res ^= a[i] - a[i - 1] - 1;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  for(int i = 2; i &lt;= n; i += 2)</span><br><span class="line">                      res ^= a[i] - a[i - 1] - 1;</span><br><span class="line">              &#125;</span><br><span class="line">              if(res) puts(&quot;Alice&quot;);</span><br><span class="line">              else puts(&quot;Bob&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Wythoff-游戏-威佐夫博弈"><a href="#Wythoff-游戏-威佐夫博弈" class="headerlink" title="Wythoff 游戏 (威佐夫博弈)"></a>Wythoff 游戏 (威佐夫博弈)</h2><ul><li><p>两堆石子各有若干个, 两人轮流从一堆取至少一个石子或从两堆取同样多的物品, 最后一名取完石子者胜利。</p></li><li><h5 id="结论-2"><a href="#结论-2" class="headerlink" title="结论:"></a>结论:</h5><ul><li>当两堆石子各有$n$和$m$个且不妨设$n&lt;m$。</li><li>当$(m-n)  \frac{√5+1}{2}=n$时, 先手必败。</li></ul></li><li><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h5></li><li><p>•首先考虑最(zhao)极(gui)端(lv)的情况, (0, 0), (1, 2), (3, 5)局面为先手必败局面。而且这样的数字对被称为奇异局势。</p></li><li><p>奇异局势的定义如下：</p><ul><li>设数字对为$[a(i), b(i)]$</li><li>1:$ a(0) = b(0) = 0$; </li><li>2: $a(k)$是前面数字对中未出现的最小的自然数, 且$a(k)+k=b(k)$。</li></ul></li><li><p>接下来我们看奇异局势的几个性质:</p><ul><li><p>性质1: 任何自然数都包含在一个且仅有一个奇异局势中。</p></li><li><p>性质2: 任意操作都能将奇异局势转变为非奇异局势.</p></li><li><p>性质3: 采取适当的方法, 可将非奇异局势转变为奇异局势。</p><p>证明略</p></li></ul></li><li><h5 id="结论：奇异局势必败"><a href="#结论：奇异局势必败" class="headerlink" title="结论：奇异局势必败"></a>结论：奇异局势必败</h5><ul><li>接下来我们看详细证明：</li><li>首先要明白Betty定理: $\frac{1}{a}+\frac{1}{b}=1$,($a, b$为无理数), 则有集合$P{[at]}$和集合$Q{[bt]}$会不重复的覆盖掉所有正整数。($t$为任意正整数, $[]$运算为取整数运算)(Betty证明略)</li><li>奇异局势有如下命题：<ul><li>(1): $a(n+1)$是前$n$组必败态中出现的最小正整数；<ul><li>如果$a(n+1$)不是前$n$组未出现的必败态中最小的正整数，则可以$a(n+1)$走到$a$更小的状态, 与我们寻找必败态的方式矛盾。</li></ul></li><li>(2):$ a(k)=b(k)+k$<ul><li>归纳法:$ (0,0)$为必败态;若前k个必败态为$(a(k),b(k)+k)$, 证:下一个必败态为$(a(k+1),a(k+1)+k+1)$。</li><li>从$k+1$出发, 一共可能走向三类状态, 从左边拿一些, 从右边拿一些，从两边拿一样多的石子。<ul><li>情况1: $a$少了, 由命题$1$可知, 比$a$小的任意一个必败态都出现过, 所以后手可以从$b$中取一定量的石子让先手重新面临必败态。</li><li>情况2: 与情况1类似</li><li>情况3: 同时拿走一定的石子, 假设拿完之后变为$(a(m), a(m)+k+1)$, 后手只需拿走一定数量的石子让先手面对$(a(m), a(m) + m)$这样的局面。</li></ul></li><li>所以成立</li></ul></li></ul></li><li>接下来我们用Betty定理来求出a, b差值与a的关系</li><li>我们知道$a+n=b$</li><li>$at=[αt], bt=[βt]$</li><li>则有at+t=[(α+1)t] =[βt]</li><li>$\frac{1}{α+1}+\frac{1}{α}=1$推出$α^2-α-1=0$</li><li>解方程得$α=\frac{√5+1}{2}$</li><li>即我们找到了必败态的通式, 即$α∗(b-a)=a$</li></ul></li><li><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><ul><li><p>hdu_2177</p></li><li><p>```c++</p><h1 id="include-5"><a href="#include-5" class="headerlink" title="include"></a>include<bits stdc++.h></bits></h1><p>using namespace std;<br>int n, m;</p><p>bool check(int n, int m)<br>{</p><pre><code>int x = min(n, m), y = max(n, m);double c = (sqrt(5.00000) + 1) / 2;double d = (double)(y - x);if(x == int(c*d)) return 1; // 必败return 0;</code></pre><p>}</p><p>void work()<br>{</p><pre><code>if(n &gt; m) swap(n, m); // (n, m)//第一个模块 我们能一起减去让他成为必败态&#123;    int tem = m - n;    double c = (sqrt(5.00000) + 1) / 2;    int a = double(tem) * c;    int b = a + tem;    if(n - a == m - b) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;//第二个模块 我们求出当前n的奇异局势, 如果m比他大 拿走就行//如果m比他小我们求出(x, n) 然后拿走m&#123;    double c = (sqrt(5.00000) + 1) / 2;    int x = n;    double d = x / c;    int y = n + d;    if(m &gt; y) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;    else    &#123;        double x = double(n) * 2 / (sqrt(5.000000) + 1);        cout &lt;&lt; int(x) &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;    &#125;&#125;</code></pre><p>}</p><p>int main()<br>{</p><pre><code>while(cin &gt;&gt; n &gt;&gt; m)&#123;    if(!(n + m)) break;    if(check(n, m)) puts(&quot;0&quot;);    else    &#123;        puts(&quot;1&quot;);        work();    &#125;&#125;return 0;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">## 斐波那契博弈(Fibonacci Nim Game)</span><br><span class="line"></span><br><span class="line">- 一堆石子有$n$个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完。以后每次取的石子数不能超过上次取子数的$2$倍。取完者胜。给定$n$,问先手必胜还是必败。</span><br><span class="line"></span><br><span class="line">- ##### 结论：</span><br><span class="line"></span><br><span class="line">  - 当$n$为$fibonacci$数的时候,先手必败</span><br><span class="line"></span><br><span class="line">- ##### 证明：</span><br><span class="line"></span><br><span class="line">  - 采用归纳法证明:</span><br><span class="line"></span><br><span class="line">  - 首先: 将$n$记为$f(i)$；</span><br><span class="line"></span><br><span class="line">  - 我们考虑最极端的情况当$n=1$时, 先手无法全部取完, 必败; $n=2$时, 先手只能取一枚石子, 必败。同时对于任意一个$n$先手都不能取$n/3$以上的石子, 因为这样先手也将必败。</span><br><span class="line"></span><br><span class="line">  - 假设$i≤k$时, 结论成立, 当$i=k+1$时,$ f(i)=f(k)+f(k-1)$</span><br><span class="line"></span><br><span class="line">    首先我们明确, 对于$fibonacci$数列, 有如下几个不等式：</span><br><span class="line"></span><br><span class="line">    - $1: f(k-1)&lt;2f(k)&lt;f(k+1):$</span><br><span class="line">    - $2: 3f(k-1)&gt;f(k+1)$</span><br><span class="line">    - $3:4f(k-1)&lt;3f(k)$</span><br><span class="line">    - $4: 2f(k-1)&gt;f(k)$</span><br><span class="line"></span><br><span class="line">  - 我们可以将$f(i)$分解为$f(k)$和$f(k-1)$两堆石子。基于第一个不等式, 我们得知先手无法一次拿完所有的$f(k-1)$。同时基于假设, 在f(k-1)中先手必败, 则后手将取完所有石子余下$f(k)$个石子。</span><br><span class="line"></span><br><span class="line">  - 对于余下的$f(k)$个石子, 由不等式三可以得出先手无法全部拿光$f(k)$, 根据假设可知$f(k)$先手必败, 所以总局面先手必败。</span><br><span class="line"></span><br><span class="line">  - 当$n$不为$fibonacci$数时, 根据$Zeckendorf$定理(齐肯多夫定理)**(任意一个数字都可表示为若干个不连续的斐波那契数之和)**, 先手可取一定的石子让后手面对$fibonacci$数</span><br><span class="line"></span><br><span class="line">- 例题：</span><br><span class="line"></span><br><span class="line">  - hdu_2516</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    #include&lt;bits/stdc++.h&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    typedef long long ll;</span><br><span class="line">    unordered_map&lt;int, int&gt; mp;</span><br><span class="line">    ll f[50];</span><br><span class="line">    void fib()</span><br><span class="line">    &#123;</span><br><span class="line">        f[0] = f[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= 50; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">            mp[f[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        int n;fib();</span><br><span class="line">        while(cin &gt;&gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n == 0)break;</span><br><span class="line">            if(!mp[n]) puts(&quot;First win&quot;);</span><br><span class="line">            else puts(&quot;Second win&quot;); //如果是fibonacci数, 则先手必败</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li></li></ul></li></ul><h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><ul><li><h5 id="mex-运算"><a href="#mex-运算" class="headerlink" title="$mex$运算:"></a>$mex$运算:</h5><ul><li>定义$mex(S)$为不属于集合S的最小非负整数运算。</li><li>•举个栗子: $S={1, 2, 3}, mex(s) = 0$;</li></ul></li><li><h5 id="SG函数-1"><a href="#SG函数-1" class="headerlink" title="SG函数:"></a>SG函数:</h5><ul><li>•SG函数: 设对于每个节点x, 设从x出发有k条有向边分别到达节点$y_1 ,y_2,…,y_k$, 定义SG(x)函数为后继节点$y_1 ,y_2,…,y_k$的$SG$函数值构成的集合再执行$mex$运算的结果。</li><li>特别的, 整个有向图$G$的$SG$函数被定义为有向图起点$s$的$SG$函数值, 即$SG(G)=SG(s)$</li><li>有向图终点的$SG$函数为$0$。</li></ul></li><li><h5 id="结论-3"><a href="#结论-3" class="headerlink" title="结论:"></a>结论:</h5><ul><li>•先手必败, 则该局面对应$SG$函数$=0$。反之必胜。</li></ul></li><li><h5 id="简单证明："><a href="#简单证明：" class="headerlink" title="简单证明："></a>简单证明：</h5><ul><li>考虑极端情况: 若某个结点棋子不能移动, 即当前处于终点无法移动, 此时$SG$值为$0$, 对应必败状态。</li><li>若某个结点的后继节点的$SG=0$, 则在后继节点$mex$运算后该节点的值大于$0$ 这等价于一个局面后面存在必败局面, 则当前局面为必胜局面。</li><li>若某个节点所有后继节点的$SG≠0$, 在$mex$运算后, 该节点的$SG$值为$0$, 即某一个局面后继节点全部为必胜局面, 则当前局面为必败局面。</li></ul></li><li><h5 id="推广："><a href="#推广：" class="headerlink" title="推广："></a>推广：</h5><ul><li>当然我们有时候面对的不止是一个有向图上的博弈, 可能是多个图上的博弈。</li><li>•对于多个有向图: 令$res=SG(s_1 )\land SG(s_2 )\land … \land SG(s_n);$</li><li>若$res=0$, 则总局面必败。</li><li>若$res≠0$, 则总局面必胜。</li><li>证明与经典$Nim$游戏类似, 不在赘述。</li></ul></li><li><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><ul><li><p>hdu_1524</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, num;</span><br><span class="line"><span class="type">int</span> sg[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[maxn], ver[maxn], nex[maxn], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sg[x] != <span class="number">-1</span>) <span class="keyword">return</span> sg[x];</span><br><span class="line">    <span class="type">bool</span> vis[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = nex[i]) <span class="comment">// 扫描所有出边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = ver[i];</span><br><span class="line">        sg[y] = <span class="built_in">GetSg</span>(y);</span><br><span class="line">        vis[sg[y]] = <span class="number">1</span>; <span class="comment">//所有出边的sg函数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) <span class="keyword">return</span> sg[x] = i; <span class="comment">// mex运算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span> nex);</span><br><span class="line">    <span class="built_in">memset</span>(ver, <span class="number">0</span>, <span class="keyword">sizeof</span> ver);</span><br><span class="line">    <span class="built_in">memset</span>(sg, <span class="number">-1</span>, <span class="keyword">sizeof</span> sg);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; num;</span><br><span class="line">            <span class="keyword">while</span>(num--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                <span class="built_in">add</span>(i, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cin &gt;&gt; num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!num) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(num--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">                res ^= <span class="built_in">GetSg</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">&quot;WIN&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;LOSE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>hdu_1536</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e4 + 10;</span><br><span class="line">int s[maxn], sg[maxn];</span><br><span class="line">int k;</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    memset(sg, -1, sizeof(sg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetSg(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(sg[x] != -1) return sg[x];</span><br><span class="line">    bool vis[maxn]; memset(vis, 0, sizeof(vis));</span><br><span class="line">    for(int i = 1; i &lt;= k; i++)</span><br><span class="line">        if(x &gt;= s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            sg[x - s[i]] = GetSg(x - s[i]);</span><br><span class="line">            vis[sg[x - s[i]]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i = 0; ; i++)</span><br><span class="line">        if(!vis[i]) return sg[x] = i;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    while(cin &gt;&gt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        if(k == 0) break;</span><br><span class="line">        for(int i = 1; i &lt;= k; i++) cin &gt;&gt; s[i];</span><br><span class="line">        int num; cin &gt;&gt; num;</span><br><span class="line">        while(num--)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, res = 0; cin &gt;&gt; x;</span><br><span class="line">            for(int i = 1; i &lt;= x; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int y; cin &gt;&gt; y;</span><br><span class="line">                res ^= GetSg(y);</span><br><span class="line">            &#125;</span><br><span class="line">            if(res) cout &lt;&lt; &quot;W&quot;;</span><br><span class="line">            else cout &lt;&lt; &quot;L&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 CHD-ACM 暑期集训开始啦</title>
      <link href="/2019/07/14/summerCamp/"/>
      <url>/2019/07/14/summerCamp/</url>
      
        <content type="html"><![CDATA[<h2 id="课表"><a href="#课表" class="headerlink" title="课表"></a>课表</h2><p><img src="https://cos.chdacm.cn//imgs/20210731164527.png" alt="1"></p><p><img src="https://cos.chdacm.cn//imgs/20210731164536.png" alt="1"></p><p><img src="https://cos.chdacm.cn//imgs/20210731164540.png" alt="1"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="[注意事项]"></a>[注意事项]</h2><h3 id="一、日程相关"><a href="#一、日程相关" class="headerlink" title="一、日程相关"></a>一、日程相关</h3><p>1．明远二区大门开门时间</p><div class="table-container"><table><thead><tr><th style="text-align:left">时间段</th><th style="text-align:left">时间</th></tr></thead><tbody><tr><td style="text-align:left">早上</td><td style="text-align:left">8:00 - 9:00</td></tr><tr><td style="text-align:left">中午</td><td style="text-align:left">11:00 - 13:00</td></tr><tr><td style="text-align:left">下午</td><td style="text-align:left">17:30 - 18:00</td></tr></tbody></table></div><p>2．集训地点为2501，2506 （2506 教室7.15~8.6 可用）</p><h3 id="二、训练内容相关"><a href="#二、训练内容相关" class="headerlink" title="二、训练内容相关"></a>二、训练内容相关</h3><p>1.介于部分同学无法在15号开始集训，第一次课安排在17号，15，16号会安排两次比赛（3h）</p><p>2.杭电多校和牛客多校的比赛时间为（12:00~17:00），该成绩会为下半年打比赛名额选取做一定参考</p><p>3.一次课时间为 9:00~11:00（按具体情况加时，无比赛时可在下午3:00~5:00加时），按需求挂专题（挂题网址：<a href="https://vjudge.net/group/chd2019summerCamp）">https://vjudge.net/group/chd2019summerCamp）</a></p><p>4.2018学年的算法讲堂课件见爆肝群文件，每次挂的题目见<a href="https://vjudge.net/group/chdacm">https://vjudge.net/group/chdacm</a> </p><p>5.上面提到的牛客和杭电多校分别是牛客网和HDU组织的线上比赛，题目一般比区域赛题目略难，已报名的集训队队员参加。</p><h3 id="三、讲课相关"><a href="#三、讲课相关" class="headerlink" title="三、讲课相关"></a>三、讲课相关</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>专题</strong></th><th style="text-align:left"><strong>节数</strong></th><th style="text-align:left"><strong>授课人</strong></th></tr></thead><tbody><tr><td style="text-align:left">博弈论</td><td style="text-align:left">1</td><td style="text-align:left">段英鹏</td></tr><tr><td style="text-align:left">组合数学/概率期望DP</td><td style="text-align:left">1</td><td style="text-align:left">韩耀东</td></tr><tr><td style="text-align:left">图论</td><td style="text-align:left">4</td><td style="text-align:left">段英鹏 李蔚青</td></tr><tr><td style="text-align:left">字符串基础字符串进阶</td><td style="text-align:left">2</td><td style="text-align:left">方尧 陈南曦</td></tr><tr><td style="text-align:left">数论</td><td style="text-align:left">2</td><td style="text-align:left">王瑀治</td></tr><tr><td style="text-align:left">基础数据结构</td><td style="text-align:left">1</td><td style="text-align:left">孙翔</td></tr><tr><td style="text-align:left">高级数据结构</td><td style="text-align:left">3</td><td style="text-align:left">韩耀东 孙翔</td></tr><tr><td style="text-align:left">动态规划进阶</td><td style="text-align:left">3</td><td style="text-align:left">韩耀东 柯一滨</td></tr><tr><td style="text-align:left">计算几何</td><td style="text-align:left">1</td><td style="text-align:left">吴兴</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第十四讲 - DP进阶二</title>
      <link href="/2019/06/01/DP/"/>
      <url>/2019/06/01/DP/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 段英鹏</strong></p><p><strong>授课时间 : 6月1日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong>授课内容 : 状压DP 倍增DP 数据结构优化DP</strong></p><p><strong><a href="/cources/dp进阶.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 倍增优化DP </tag>
            
            <tag> 数据结构优化DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第十三讲 - DP进阶一</title>
      <link href="/2019/05/23/DP/"/>
      <url>/2019/05/23/DP/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 韩耀东</strong></p><p><strong>授课时间 : 5月23日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong>授课内容 : 区间DP 树形DP</strong></p><p><strong><a href="/cources/DP第一讲.pdf">点击下载课件</a></strong></p><h1 id="DP第一讲"><a href="#DP第一讲" class="headerlink" title="DP第一讲"></a>DP第一讲</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>三要素：”状态“ ”阶段“ ”决策“</p><p>三个基本条件：子问题重叠性，无后效性，最优子结构性质</p><p>把原问题视作若干个重叠子问题进行求解，每个子问题求解的过程就是一个“阶段”。</p><h3 id="LIS-最长上升子序列"><a href="#LIS-最长上升子序列" class="headerlink" title="LIS(最长上升子序列)"></a>LIS(最长上升子序列)</h3><p>$d[i] = max_{0\leq j &lt; i, a[j]&lt;a[i]}{d[j]+1}$</p><h3 id="LCS（最长公共子序列）"><a href="#LCS（最长公共子序列）" class="headerlink" title="LCS（最长公共子序列）"></a>LCS（最长公共子序列）</h3><script type="math/tex; mode=display">d[i,j] = max\begin{cases}d[i-1][j]  & \\d[i][j-1] & \\d[i-1][j-1] + 1 & \text{if a[i] = b[i]}\\\end{cases}</script><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><script type="math/tex; mode=display">d[i][j] = a[i][j] + max\begin{cases}d[i-1][j] &\\d[i-1][j-1] & \text{if j>1}\\\end{cases}</script><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0/1背包"></a>0/1背包</h3><p>问题模型：给定N个物品，其中第 i 个物品的体积为$V_i$ 价值为$W_i$ 。有一容积为M的背包，要求选择其中一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。 </p><p>阶段：已经处理的物品数</p><p>状态：$d[i][j]$ 表示从前 i 个物品中选出了总体积为 j 的物品放入背包，物品的最大价值和</p><script type="math/tex; mode=display">d[i][j] = max\begin{cases}d[i-1][j] & \\d[i-1][j-V_i]+W_i & \text{if j $\ge$ $V_i$} \\\end{cases}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d); <span class="comment">// -INF</span></span><br><span class="line">d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        d[i][j] = d[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">        d[i][j] = <span class="built_in">max</span>(d[i][j], d[i<span class="number">-1</span>][j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为状态转移时, 第 i 层结果只受 i-1 层影响，所以只需要两层数组就可以解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[<span class="number">2</span>][MAX_VAL<span class="number">+1</span>];</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        d[i &amp; <span class="number">1</span>][j] = d[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">        d[i &amp; <span class="number">1</span>][j] = <span class="built_in">max</span>(d[i &amp; <span class="number">1</span>][j], d[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一维数组优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[MAX_VAL<span class="number">+1</span>];</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j],f[j-v[j]] + w[i]);</span><br></pre></td></tr></table></figure><h4 id="1-团队分组（Uva-1627）"><a href="#1-团队分组（Uva-1627）" class="headerlink" title="1. 团队分组（Uva-1627）"></a>1. 团队分组（Uva-1627）</h4><p>有n($n\le 100$)个人，把他们分成非空的两组，使得每个人都被分到一组，且同组中的人相互认识。要求两组的成员人数尽量接近。多解时输出任意方案，无解时输出No Solution。</p><p>例如：1认识2，3，5；2认识1，3，4，5；3认识1，2，5；4认识1，2，3；5认识1，2，3，4</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>问题模型：给定N种物品，其中第 i 种物品的体积为$V_i$ 价值为$W_i$，每种都有无限个 。有一容积为M的背包，要求选择其中一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(d,<span class="number">0xcf</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">        d[j] = <span class="built_in">max</span>(d[j],d[j-v[i]] + w[i]);</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>问题模型：给定N种物品，其中第 i 种物品的体积为$V_i$ 价值为$W_i$，每种有$C_i$个 。有一容积为M的背包，要求选择其中一些物品放入背包，使得物品总体积不超过M的前提下，物品的价值总和最大。 </p><ul><li>直接拆分成0/1背包也能做</li><li>二进制拆分为0/1背包，每种物品为 $logC_i$个</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Good</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Good&gt; goods;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">            s -= k;</span><br><span class="line">            goods.<span class="built_in">push_back</span>(&#123;v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)goods.<span class="built_in">push_back</span>(&#123;v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> good:goods)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=good.v;j--)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-good.v] + good.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列优化背包"><a href="#单调队列优化背包" class="headerlink" title="单调队列优化背包"></a>单调队列优化背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m,f[N],g[N],q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;v,&amp;w,&amp;s);</span><br><span class="line">        <span class="built_in">memcpy</span>(g,f,<span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; v;j ++)&#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=m;k+=v)&#123;</span><br><span class="line">                f[k] = g[k];</span><br><span class="line">                <span class="keyword">if</span>(l &lt;= r &amp;&amp; k-s*v &gt; q[l])l++;</span><br><span class="line">                <span class="keyword">if</span>(l &lt;= r)f[k] = <span class="built_in">max</span>(f[k],g[q[l]] + (k-q[l])/v*w);</span><br><span class="line">                <span class="keyword">while</span>(l &lt;= r &amp;&amp; g[q[r]] - (q[r]-j)/v*w &lt;= g[k]-(k-j)/v*w) r--;</span><br><span class="line">                q[++r] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,v,w,f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s);</span><br><span class="line">        <span class="type">int</span> t = i&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)f[j][t] = f[j][t^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;w);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=m;k&gt;=v;k--)</span><br><span class="line">                f[k][t] = <span class="built_in">max</span>(f[k][t],f[k-v][t^<span class="number">1</span>] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m][n&amp;<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h3><p><a href="https://www.luogu.org/problemnew/show/P1064">https://www.luogu.org/problemnew/show/P1064</a></p><h3 id="背包求方案数"><a href="#背包求方案数" class="headerlink" title="背包求方案数"></a>背包求方案数</h3><h3 id="背包求具体方案"><a href="#背包求具体方案" class="headerlink" title="背包求具体方案"></a>背包求具体方案</h3><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>有N堆石子排成一排，其中第 i 堆石子的重量为 $A_i$ 。每次可以选择其中相邻的两堆石子合并成一堆，形成的新石子堆的重量以及消耗的体力都是两堆石子的重量之和。求把全部N堆石子合成一堆最少需要消耗多少体力。$1\le N\le 300$</p><ul><li>$d[l][r]$ 表示把最初的第 l 堆到第 r 堆石子合并成一堆，需要消耗多少的体力</li><li>$d[l][r] = min<em>{l\le k &lt; r} {d[l][k] + d[k+1][r]} + \Sigma</em>{i=l}^r A_i$</li></ul><p>[注] : 计算<code>d[l][r]</code>时，区间<code>[l][r]</code>中所有长度小于len = r-l+1 的子区间的答案都必须求出。否则无法向<code>d[l][r]</code>转移。这也就是告诉我们，可以用区间的长度作为阶段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    d[i][i] = <span class="number">0</span>;sum[i] = sum[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>;len &lt;= n;len ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n-len<span class="number">+1</span>;l++)&#123;</span><br><span class="line">        <span class="type">int</span> r = l+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)</span><br><span class="line">            d[l][r] = <span class="built_in">min</span>(d[l][r],d[l][k]+d[k<span class="number">+1</span>][r]);</span><br><span class="line">        d[l][r] += sum[r] - sum[l<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h4><p>一棵树上面的每个结点都带有一个颜色(用字母表示)，然后给定这棵树dfs之后的颜色序列，求树的结构的可能。</p><p>例如 ABABABA 有五种可能。</p><ul><li>d[l,r]表示该区间的可能的树结构的数量。那么必有$s[l] = s[r]$ 。所以从左到右找 k ($s[l] = s[k] \&amp;\&amp; s[l+1] == s[k-1]$) 这样就有 $d[l+1][k-1]$ 为第一颗子树的可能结构数。至于$[k,r]$ 之间如何组合，递归子问题求解。</li><li>由此可知该题用记忆化搜索写会比较好写，当然递推也可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">303</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">303</span>][<span class="number">303</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[l][r] != <span class="number">-1</span>)<span class="keyword">return</span> d[l][r];</span><br><span class="line">    d[l][r] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=l<span class="number">+2</span>;k&lt;=r;k++)</span><br><span class="line">        <span class="keyword">if</span>(s[l] == s[k] &amp;&amp; s[l<span class="number">+1</span>] == s[k<span class="number">-1</span>])&#123;</span><br><span class="line">            d[l][r] = (d[l][r] + (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">solve</span>(l<span class="number">+1</span>,k<span class="number">-1</span>) * <span class="built_in">solve</span>(k,r)%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> d[l][r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(<span class="number">1</span>,<span class="built_in">strlen</span>(s<span class="number">+1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>阶段：节点从深到浅（子树从小到大）的顺序作为DP的阶段</p><p>状态：第一维为节点编号。第二维根据题目会有所不同</p><p>决策：在递归子树，解决了子树问题之后，回溯时从子结点向本节点进行转移</p><p>树形DP即树上的动态规划问题</p><h4 id="引入——树的最大独立集"><a href="#引入——树的最大独立集" class="headerlink" title="引入——树的最大独立集"></a>引入——树的最大独立集</h4><blockquote><p>对于一棵n个结点的无根树，选出尽量多的结点，使得任何两个结点均不相邻（称为最大独立集），然后输入n-1条无向边，输出一个最大独立集（如果有多解，输出一解）</p></blockquote><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>用$d_i$ 来表示以 i 为根节点的子树的最大独立集大小</p><p>考虑当前结点 i ，如果选择 i ，则 i 的儿子全部不能选，问题转化为求出 i 的孙子d值之和。如果不选 i ，则转换为了求 i 的儿子的d值之和</p><p>所以现在有两种做法</p><ul><li>计算 i 的 d值时，需要知道它的儿子和孙子的 d值和，</li><li>计算 i 的儿子或者孙子的 d 值时，用刷表法将贡献计算到结点 i 中</li></ul><p>其实二维数组就解决了这个问题。</p><h4 id="1-关于树——遗留的几个问题"><a href="#1-关于树——遗留的几个问题" class="headerlink" title="1. 关于树——遗留的几个问题"></a>1. 关于树——遗留的几个问题</h4><h5 id="1-gt-树的重心"><a href="#1-gt-树的重心" class="headerlink" title="1&gt; 树的重心"></a>1&gt; 树的重心</h5><blockquote><p>对于一棵 n 个结点的无根树，找到一个点，使得把树变成以该节点为根的有根树时，最大子树的结点树最小。换句话说，删除这个点后最大联通块（一定是树）的结点树最小。</p></blockquote><ul><li>d[i] 表示以 i 为根的子树的结点个数。</li></ul><h5 id="2-gt-树的直径"><a href="#2-gt-树的直径" class="headerlink" title="2&gt; 树的直径"></a>2&gt; 树的直径</h5><blockquote><p>对于一棵 n 个结点的无根树，找到一条最长路径，换句话说，要找到两个点，使得他们的距离最远</p></blockquote><ul><li>d[i]表示 i 的子树中，距离结点 i 到叶子的最大距离。</li><li>转移：d[i] = max(d[j]) + 1;</li><li>将子结点的d[j]都求出后，排个序选前两大，更新答案。</li><li>有没有不排序的做法？</li></ul><h4 id="1-没有上司的舞会"><a href="#1-没有上司的舞会" class="headerlink" title="1.没有上司的舞会"></a>1.没有上司的舞会</h4><p>给定一棵树，每个结点都有一个权值。要求从中选取一些点，这些点两两之间没有连边，并且使得权值和最大。</p><ul><li><code>d[x][0]</code>表示以x为根的子树中不选x的最大权值和</li><li><code>d[x][1]</code>表示以x为根的子树中选择x的最大权值和</li></ul><p>转移时我们考虑 当前结点x</p><ul><li>不选择x，即更新<code>d[x][0]</code><ul><li>$d[x][0]  = \Sigma_{s\in Son(x)}max(d[s][0],d[s][1])$</li></ul></li><li>选择x，即更新<code>d[x][1]</code><ul><li>$d[x][1] = a[x] + \Sigma_{s\in Son(x)}d[s][0] $</li></ul></li></ul><p>【注】: 对于树，我们一般用vector来存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; son[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">10010</span>][<span class="number">2</span>],v[<span class="number">10010</span>],h[<span class="number">10010</span>],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">d[x][<span class="number">1</span>] = a[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y = son[x][i];</span><br><span class="line"><span class="built_in">dp</span>(y);</span><br><span class="line">d[x][<span class="number">0</span>] += <span class="built_in">max</span>(d[y][<span class="number">0</span>],d[y][<span class="number">1</span>]);</span><br><span class="line">d[x][<span class="number">1</span>] += d[y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    son[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">    root = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(root);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(d[root][<span class="number">0</span>],d[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加一点点难度的例题：Hali-Bula的晚会（uva1220）</p><p>好了，看了简单题，那我们稍微加一点点难度</p><h4 id="2-校赛C题LaTale"><a href="#2-校赛C题LaTale" class="headerlink" title="2.校赛C题LaTale"></a>2.校赛C题<a href="hrps://ac.nowcoder.com/acm/contest/897/C">LaTale</a></h4><p>题目：</p><p>​    Legend goes that in the heart of ocean, exists a gorgeous island called LaTale, which has n cities. Specially, there is only one way between every two cities. </p><p>​      In other words, n cities construct a tree connected by n-1 edges. Each of the edges has a weight w. </p><p>​    Define d(u, v) the length between city u and city v. Under the condition of u differing from v, please answer how many pairs(u, v) in which d(u, v) can be divisible by 3.      Pair(u,v) and pair(v,u) are considered the same. </p><blockquote><p>简化题意：</p><p>给定一棵树，每条边上面都有一个权值。定义$d[u][v]$为从u到v的距离，求满足$d[u][v]\%3 = 0$  的 pair(u,v)的数量</p></blockquote><p>按照上面的题意，可以想到</p><ul><li><code>d[x][0]</code>表示x为根的子树中，距x长度模3等于0 的结点的数量。以此类推$d[x][1],d[x][2]$</li></ul><p>考虑如何转移？</p><p>转移很简单</p><p>$d[x][0] = \Sigma_{s\in Son(x)} (d[s][(3-edge[x][s]\%3)]+1)$ ,其他相同</p><p>但是该怎么计算答案呢？</p><p>根据<code>d[x][0]</code> ,我们只能知道x的子树中，到x距离模三为0的节点数，但是子结点与子结点并没有考虑完整。</p><blockquote><p>x如果有大于等于两颗子树，那么第一颗子树与第二颗子树的点对就完全没有考虑</p></blockquote><p>最暴力的做法就是从x的子树中枚举两个子树，然后算答案。</p><p>但是仔细想想，两个子树要想有联系，必须经过x才可以</p><p><img src="/.com//Users\ADMINI~1\AppData\Local\Temp\1558427976902.png" alt="1558427976902"></p><p>假设现在计算到了 x 的子结点 y，递归完y之后，我们得到了<code>d[y][0],d[y][1],d[y][2]</code></p><p>然后<code>d[x][0],d[x][1],d[x][2]</code>都还保存了左侧绿圈内的点的答案。所以现在是计算 y 子树跟绿圈内的点的大好时机。设z为<code>edge[x][y]</code> ，那么<code>(a+b+z)%3==0</code>时，<code>d[x][a] * d[y][b]</code>就是一组对答案的贡献。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> head[N],ver[N*<span class="number">2</span>],edge[N*<span class="number">2</span>],nxt[N*<span class="number">2</span>],tot,n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y;</span><br><span class="line">    edge[tot] = z;</span><br><span class="line">    nxt[tot] = head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[x][<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="type">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="type">int</span> z = edge[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">3</span>;a++)&#123;</span><br><span class="line">            <span class="type">int</span> b = (<span class="number">3</span>-z-a<span class="number">+3</span>)%<span class="number">3</span>;</span><br><span class="line">            res += d[x][a] * d[y][b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">3</span>;a++)d[x][(a+z)%<span class="number">3</span>] += d[y][a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = d[i][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            head[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            z%=<span class="number">3</span>;</span><br><span class="line">            <span class="built_in">add</span>(x,y,z);</span><br><span class="line">            <span class="built_in">add</span>(y,x,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-完美的服务-uva-1218"><a href="#3-完美的服务-uva-1218" class="headerlink" title="3.完美的服务(uva-1218)"></a>3.完美的服务(uva-1218)</h3><p>题意：有n($n\le 10000$)台机器形成树状结构。要求在其中一些机器上安装服务器，使得每台不是服务器的计算机恰好和一台服务器计算机相邻。求服务器的最少数量。</p><ul><li>$d(u,0)$表示u是服务器，则每个子结点可以是服务器也可以不是</li><li>$d(u,1)$表示u不是服务器，但u的父亲是服务器，这意味着u的所有子结点都不是服务器</li><li>$d(u,2)$表示u和u的父亲都不是服务器，这意味着u恰好有一个儿子是服务器</li></ul><p>转移：</p><ul><li>$d(u,0) = sum{min(d(v,0),d(v,1))} + 1$ </li><li>$d(u,1) = sum(d(v,2))$</li><li>$d(u,2) = min(d(u,1) - d(v,2) + d(v,0))$</li></ul><h4 id="4-保卫Zonk-uva-12093"><a href="#4-保卫Zonk-uva-12093" class="headerlink" title="4.保卫Zonk(uva-12093)"></a>4.保卫Zonk(uva-12093)</h4><p>题意：给定一个有n($n\le 10000$)个结点的无根树，有两种装置A和B，每种都有无限多个。</p><ul><li>在某个节点X使用A装置需要花费C1($C1\leq 1000$)的花费，并且此时与结点X相连的边都被覆盖</li><li>在某个结点X使用B装置需要花费C2($C2\leq 1000$)的花费，并且此时与结点X相连的边以及与结点X相连的点相连的边都被覆盖</li></ul><p>首先想到 </p><ul><li>d[0] 表示x不装</li><li>d[1] 表示x装A</li><li>d[2] 表示x装B</li></ul><p>怎么转移？d[0] x不装，x与子结点所连的边该有x的fa处理还是该由子结点处理？所以还需要细化状态</p><ul><li>d[0] 表示x不装，与子结点的边由子结点处理（x的fa不装B）</li><li>d[1] 表示x装A，（好像等同于子结点或fa装B，总之有一个B就完事了）</li><li>d[2] 表示x装B</li><li>d[3] 表示x不装，与子结点的边由fa装B处理(那么d[1]里面只需要处理一个子结点装B就好了)</li></ul><p>转移</p><ul><li>$d[x][0] += min(d[v][1],d[v][2])$</li><li>$d[x][1] += min(d[v][0],d[v][1],d[v][2])$ 最后还需考虑是给x装A好还是给一个子结点装B好</li><li>$d[x][2] = C2 + \Sigma_{v\in son(x)}min(d[v][0],d[v][1],d[v][2],d[v][3])$</li><li>$d[x][3] = \Sigma_{v\in son(x)}min(d[v][0],d[v][1],d[v][2])$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,C1,C2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(a,<span class="built_in">min</span>(b,c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(a,b),<span class="built_in">min</span>(c,d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = inf;<span class="comment">//差价</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> y = g[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        d[x][<span class="number">0</span>] += <span class="built_in">min</span>(d[y][<span class="number">1</span>],d[y][<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> vval = <span class="built_in">min</span>(d[y][<span class="number">0</span>],d[y][<span class="number">1</span>],d[y][<span class="number">2</span>]);</span><br><span class="line">        val = <span class="built_in">min</span>(val,d[y][<span class="number">2</span>] - vval);</span><br><span class="line">        d[x][<span class="number">1</span>] += vval;</span><br><span class="line">        d[x][<span class="number">2</span>] += <span class="built_in">min</span>(vval,d[y][<span class="number">3</span>]);</span><br><span class="line">        d[x][<span class="number">3</span>] += vval;</span><br><span class="line">    &#125;</span><br><span class="line">    d[x][<span class="number">2</span>] += C2;</span><br><span class="line">    d[x][<span class="number">1</span>] += <span class="built_in">min</span>(C1,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;C1,&amp;C2) &amp;&amp; (n+C1+C2))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = d[i][<span class="number">2</span>] = d[i][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            g[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(d[<span class="number">1</span>][<span class="number">0</span>],d[<span class="number">1</span>][<span class="number">1</span>],d[<span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-防止街灯（UVA-10859）"><a href="#4-防止街灯（UVA-10859）" class="headerlink" title="4.防止街灯（UVA-10859）"></a>4.防止街灯（UVA-10859）</h4><p>给你一个 n 个点m条边的无向无环图，在尽量少的结点上放灯，使得所有边都被照亮。每盏灯将照亮以它为一个端点的所有边。在灯的总数最小的前提下，被两盏灯同时照亮的边数应尽量大</p><ul><li>无向无环图是一个森林，即多棵树</li><li>被两盏灯同时照亮的边数尽量大，也就是使得恰好被一盏灯照亮的边数c应该尽量小，设放置的灯数为a，那么设一个指标$x = Ma+c$ ，其中M是一个很大的正整数，a = x/M,c = x%M.一般来说，M是一个比c的最大理论值与最小理论值之差还要大的数字。这样使得两个a不同，不管c差多少，都是a取决定性作用。这个题里面M = 2000</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> vis[N],d[N][<span class="number">2</span>],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    d[x][<span class="number">1</span>] += <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> y = v[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y,x);</span><br><span class="line">        d[x][<span class="number">0</span>] += d[y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        d[x][<span class="number">1</span>] += <span class="built_in">min</span>(d[y][<span class="number">1</span>],d[y][<span class="number">0</span>]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T,a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            v[i].<span class="built_in">clear</span>();</span><br><span class="line">            d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            v[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">            v[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                <span class="built_in">dp</span>(i,<span class="number">-1</span>);</span><br><span class="line">                res += <span class="built_in">min</span>(d[i][<span class="number">0</span>], d[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,res/<span class="number">2000</span>,m-res%<span class="number">2000</span>,res%<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 区间DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第十二讲 - 并查集等</title>
      <link href="/2019/05/18/BIT/"/>
      <url>/2019/05/18/BIT/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 方尧</strong></p><p><strong>授课时间 : 5月18日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong>授课内容 : 并查集 树状数组 线段树</strong></p><p><strong><a href="/cources/并树线.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第十一讲 - 组合计数等</title>
      <link href="/2019/05/04/Probability/"/>
      <url>/2019/05/04/Probability/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 陈南曦</strong></p><p><strong>授课时间 : 5月4日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong>授课内容 : 组合计数，容斥，概率dp，博弈</strong></p><p><strong><a href="/cources/组合计数容斥概率期望.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 组合计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第十讲 - 数论初步</title>
      <link href="/2019/04/27/numberTheory/"/>
      <url>/2019/04/27/numberTheory/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 韩耀东</strong></p><p><strong>授课时间 : 4月27日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong>授课内容 : 数论初步：质数，约数，同余(筛法，exgcd，欧拉函数，欧拉定理，中国剩余定理)</strong></p><p><strong><a href="/cources/数论初步.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第九讲 - KMP&amp;马拉车&amp;Trie</title>
      <link href="/2019/04/11/kmp&amp;exkmp/"/>
      <url>/2019/04/11/kmp&amp;exkmp/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 方尧</strong></p><p><strong>授课时间 : 4月11日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong><a href="/cources/4.11字符串.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> Manacher </tag>
            
            <tag> KMP </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第九讲 - 单调栈&amp;单调队列&amp;链表&amp;哈希</title>
      <link href="/2019/03/23/stack&amp;queue&amp;hash/"/>
      <url>/2019/03/23/stack&amp;queue&amp;hash/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 陈南曦</strong></p><p><strong>授课时间 : 3月23日 19:00</strong></p><p><strong>授课地点 : wx3304</strong></p><p><strong><a href="/cources/3-23课件（单调队列，单调栈，链表，哈希）.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 单调栈 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-团体程序设计天梯赛 - 校内排位赛报名</title>
      <link href="/2019/03/05/qualifying/"/>
      <url>/2019/03/05/qualifying/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.wjx.top/jq/35335024.aspx">报名链接</a></p><p>时间：3月9日14：00-17：00<br>地点：wx3203，wx3202</p><p>需要自备电脑，不可以携带任何纸质资料（草稿纸自备），请诚信参赛。</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2018-新生赛</title>
      <link href="/2018/12/06/NewGame/"/>
      <url>/2018/12/06/NewGame/</url>
      
        <content type="html"><![CDATA[<h2 id="新生赛报名"><a href="#新生赛报名" class="headerlink" title="新生赛报名"></a>新生赛报名</h2><p><a href="https://www.chaojibiaoge.com/index.php/U/url/pjqrg6l2">报名链接</a><br>进入链接填写信息即可报名成功<br>奖品后续再补吧……<br>目前暂时只接纳长安大学的学生报名 考虑本校人数后 再安排外校人数的报名容量</p><h2 id="新生赛通知-12-06更新"><a href="#新生赛通知-12-06更新" class="headerlink" title="新生赛通知(12-06更新)"></a>新生赛通知(12-06更新)</h2><p>时间安排：12月9日（周日）</p><div class="table-container"><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">地点</th><th style="text-align:left">事宜</th></tr></thead><tbody><tr><td style="text-align:left">9:00—10:00</td><td style="text-align:left">WM2201</td><td style="text-align:left">告诉大家比赛环境和注意事项</td></tr><tr><td style="text-align:left">10:00—11:00</td><td style="text-align:left">比赛机房</td><td style="text-align:left">热身赛</td></tr><tr><td style="text-align:left">12:30—16:30</td><td style="text-align:left">比赛机房</td><td style="text-align:left">正式赛</td></tr><tr><td style="text-align:left">19:00—21:00</td><td style="text-align:left">WH1101</td><td style="text-align:left">颁奖&amp;讲题</td></tr></tbody></table></div><p>题目讲解及颁奖比赛题目为10~12道中文题，比赛可以带任何的纸质资料，但不得使用电子设备。</p><p>奖品设置：一血（最快解题奖）、最佳女生、前十名均有奖品。</p><p>下面是一个新生赛的格式练习。题目不多就一道，再下面的网址是答案。希望报名比赛的同学可以提前写一下。<br><a href="https://vjudge.net/contest/274626#problem">https://vjudge.net/contest/274626#problem</a><br><a href="https://paste.ubuntu.com/p/pkbv6TFyFx/">https://paste.ubuntu.com/p/pkbv6TFyFx/</a></p><p>最后祝大家体验愉快，取得理想的成绩!</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 长安大学新生赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第八讲 - DP</title>
      <link href="/2018/11/16/DP/"/>
      <url>/2018/11/16/DP/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 陈南曦</strong></p><p><strong>授课时间 : 11月16日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><p><strong><a href="/cources/动态规划与记忆化搜索.pptx">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第七讲 - DFS&amp;BFS</title>
      <link href="/2018/11/09/search/"/>
      <url>/2018/11/09/search/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 张耕田</strong></p><p><strong>授课时间 : 11月08日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><p><strong><a href="/cources/搜索入门.ppt">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第六讲 - STL&amp;二分</title>
      <link href="/2018/11/02/STL&amp;%E4%BA%8C%E5%88%86/"/>
      <url>/2018/11/02/STL&amp;%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 成嘉豪</strong></p><p><strong>授课时间 : 11月02日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><blockquote><p>课件丢失不好意思哟，我们会尽快填补</p></blockquote><p><strong><a href="/cources/STL基础用法(pdf">点击下载补充课件</a>.pdf)</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 二分 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第五讲 - 枚举&amp;贪心</title>
      <link href="/2018/10/26/Enum&amp;greedy/"/>
      <url>/2018/10/26/Enum&amp;greedy/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 孙翔</strong></p><p><strong>授课时间 : 10月26日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><p><strong><a href="/cources/ACM-枚举贪心.ppt">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第四讲 - 基础数论</title>
      <link href="/2018/10/19/numberTheory/"/>
      <url>/2018/10/19/numberTheory/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 柯一滨</strong></p><p><strong>授课时间 : 10月19日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><p><a href="/cources/ACM-基础数论.ppt">点击下载课件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 基础数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第三讲 - C语言入门3</title>
      <link href="/2018/10/11/C_third/"/>
      <url>/2018/10/11/C_third/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 罗瑾昀</strong></p><p><strong>授课时间 : 10月12日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><p><strong><a href="/cources/ACM-C语言入门-3.pdf">点击下载课件</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第二讲 - C语言入门2</title>
      <link href="/2018/09/29/C_second/"/>
      <url>/2018/09/29/C_second/</url>
      
        <content type="html"><![CDATA[<p><strong>授课人 : 吴兴</strong></p><p><strong>授课时间 : 9月30日 19:00</strong></p><p><strong>授课地点 : wx3303</strong></p><p><a href="/cources/ACM-C语言入门-2.pdf">点击下载课件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法讲堂第一讲 - C语言入门1</title>
      <link href="/2018/09/21/C_first/"/>
      <url>/2018/09/21/C_first/</url>
      
        <content type="html"><![CDATA[<p><a href="/cources/ACM-C语言入门-1.pdf">点击下载课件</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社团活动介绍</title>
      <link href="/2018/07/28/%E7%A4%BE%E5%9B%A2%E6%B4%BB%E5%8A%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/07/28/%E7%A4%BE%E5%9B%A2%E6%B4%BB%E5%8A%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>文档目录<br><a href="/2014/04/02/cauu/">What’s ACM</a><br><a href="/2018/07/28/社团活动介绍/">协会活动介绍</a><br><a href="/2018/07/28/入门指南/">入门指南</a><br><a href="/faq">常见问题解答FAQ</a></p></div><h2 id="算法讲堂"><a href="#算法讲堂" class="headerlink" title="算法讲堂"></a>算法讲堂</h2><p>为提高同学们的思维能力，对数学、编程、算法的兴趣以及团队合作能力协会，协会学期内每周末固定开展算法讲课。课后会挂出相应练习题目并在协会博客更新讲课资料。</p><p>在每年九月纳新阶段，协会开展C语言入门课程，具体形式是，在教室通过投影进行现场代码编写并直接讲解，不会有枯燥的空概念，还会加入一些集训队成员平时积累的编程经验。</p><p>在接下来的十月到十二月，协会算法课会循序渐进开展基础算法的讲解，讲课内容包括贪心算法，搜索基础，动态规划基础，背包问题，通过这一阶段的算法学习，使同学对算法有初步理解，并对算法产生浓厚兴趣。</p><p>协会在每学年下学期开展进阶算法课程，课程内容为ACM-ICPC比赛中需要应用的应赛知识点，包括更多形式的动态规划，数据结构基础，树状数组线段树，数论基础，图论基础，字符串算法。讲课内容深入浅出，并给出经典例题，引导同学思考，同时现场编程更好的帮助同学理解算法的应用。</p><p>协会的算法课适合对象广泛，不论是有志于参加各类算法竞赛的同学还是只是对算法感兴趣的同学，都能够从协会开设的算法课中获益良多。</p><p>2020年春季由于疫情的原因，开展了线上的算法讲堂，每周一下发学习资料，周日举办一场5小时的比赛，比赛结束会下发题解，并进行直播讲解。</p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/20210728222823.png" alt="算法讲堂"></p><p><img src="https://cos.chdacm.cn//imgs/clip_image002.jpg" alt="算法讲堂"></p><p><img src="https://cos.chdacm.cn//imgs/clip_image003.jpg" alt="算法讲堂"> </p><p><img src="https://cos.chdacm.cn//imgs/clip_image006.jpg" alt="春季学期每周末的线上训练"></p>          </div><h2 id="迎新杯ACM程序设计竞赛"><a href="#迎新杯ACM程序设计竞赛" class="headerlink" title="迎新杯ACM程序设计竞赛"></a>迎新杯ACM程序设计竞赛</h2><p>本社团自14年起开始举办迎新杯程序设计竞赛，每年的迎新杯都是本社团初步选拔集训队成员的重要指标。比赛是个人赛的形式，中文题面，题目范围较为基础，适合刚学习C语言与ACM的新同学。</p><p>每年的题目均为我校自主命题，同时本社团成员还负责了布置场地，配置机房比赛环境，判题，发放气球，以及各项赛后工作。</p><p>自15年起我校开始邀请外校前来一同参加迎新杯比赛，本社团又负责了联络外校领队，安排志愿者等各项工作。</p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/20210728222744.jpg" alt="裁判同学正在调试环境"> </p><p><img src="https://cos.chdacm.cn//imgs/20210728222904.jpg" alt="参赛同学"></p><p><img src="https://cos.chdacm.cn//imgs/20210728222907.jpg" alt="参赛同学"> </p><p><img src="https://cos.chdacm.cn//imgs/20210728222911.jpg" alt="比赛教室"></p>          </div><h2 id="ACM-ICPC国际大学生程序设计竞赛"><a href="#ACM-ICPC国际大学生程序设计竞赛" class="headerlink" title="ACM-ICPC国际大学生程序设计竞赛"></a>ACM-ICPC国际大学生程序设计竞赛</h2><p>2014年，本社团ACM集训队代表参加了亚洲区域赛北京赛区、西安赛区。</p><p>2015年，ACM集训队成员参加了上海赛区邀请赛，并且获得铜牌。同年，本社团派出多支队伍前往西北工业大学参加陕西省省赛。15年下学期，集训队成功晋级亚洲区域赛上海赛区现场赛，并取得银牌。</p><p>2016年5月我校承办陕西省省赛，集训队获得一金一银的好成绩。16年下学期，集训队取得四场亚洲区域赛名额，共派出五支队伍，均获得铜牌。</p><p>2017年下学期，集训队取得了五场亚洲区域赛名额，获得了一金一银三铜的成绩，我校也成为了陕西省继西电、西交、西工大之后的又一所金牌学校。</p><p>2018年下学期，集训队取得了六场亚洲区域赛名额，获得了两枚银牌铜牌若干。</p><p>2019年下学期，集训队取得了七场亚洲区域赛名额，获得了一枚银牌，铜牌若干。</p><h2 id="CCPC中国大学生程序设计竞赛"><a href="#CCPC中国大学生程序设计竞赛" class="headerlink" title="CCPC中国大学生程序设计竞赛"></a>CCPC中国大学生程序设计竞赛</h2><p>中国大学生程序设计竞赛（China Collegiate Programming Contest，简称CCPC）是由中国大学生程序设计竞赛协会主办的面向世界大学生的国际性年度赛事，旨在激励当代大学生运用计算机编程技术和技能来解决实际问题，激发其学习算法和程序设计的兴趣，培养其团队合作意识、创新能力和挑战精神。</p><p>中国大学生程序设计竞赛协会是由中国各高校程序设计竞赛教练组成的社会团体，于2014年筹备成立。协会常务理事会成员具有丰富的赛事组织和指导经验，很多人从1996年开始就担任教练和赛事组织工作，不仅指导学生在程序设计竞赛中多次获得全球总冠军以及数十枚金银铜奖，而且都有承办全球或亚洲地区程序设计国际比赛的成功经历。</p><p>2015年9月集训队前往南洋理工大学参加首届CCPC中国大学生程序设计竞赛，夺得铜牌。</p><p>2016年本社团集训队多支队伍又参加了CCPC长春站、杭州站、合肥站以及总决赛，获得了两枚铜牌。</p><p>2017年本社团集训队参加了CCPC杭州站，获得了一枚金牌。</p><p>2018年参加了秦皇岛与桂林赛区，获得了两枚铜牌。</p><p>2019年参加秦皇岛赛区，获得铜牌</p><h2 id="CCCC中国高校计算机大赛团队天梯赛（GPLT）"><a href="#CCCC中国高校计算机大赛团队天梯赛（GPLT）" class="headerlink" title="CCCC中国高校计算机大赛团队天梯赛（GPLT）"></a>CCCC中国高校计算机大赛团队天梯赛（GPLT）</h2><p>为促进高校计算机课程教学内容和教学方法改革，强化学生创新意识，提升学生计算机问题求解水平，增强计算机应用能力，培养团队合作精神，提高大学生的综合素质，促进校际交流，丰富校园学术气氛，教育部高等学校计算机类专业教学指导委员会、教育部高等学校软件工程专业教学指导委员会、教育部高等学校大学计算机课程教学指导委员会、全国高等学校计算机教育研究会决定联合主办“中国高校计算机大赛（China Collegiate Computing Contest，简称C4，CCCC）”。“中国高校计算机大赛”每年举办一届，设四个竞赛模块，分别是团体程序设计天梯赛、大数据挑战赛、移动应用创新赛和网络技术挑战赛。</p><p>16年暑期，集训队成员去往西工大参加全国高校计算机大赛团队天梯赛，获得全国团队二等奖。</p><p>2017年3月，集训队三支队伍前往西工大参加全国高校计算机大赛团队天梯赛（西北赛区），获得西北赛区团队二等奖一项、团队三等奖一项以及西北赛区高校三等奖。</p><p>2018年3月，集训队参加第三届前往西工大参加全国高校计算机大赛团队天梯赛，获得全国团队二等奖、陕西省团队省特等奖、陕西省团队二等奖、陕西省团队三等奖以及陕西省高校二等奖。</p><p>2019年三月，集训队参加第四届全国高校计算机大赛团队天梯赛，获得全国团队二等奖、陕西省团队省一等奖、陕西省团队三等奖以及陕西省高校二等奖。</p><p>2020年由于疫情原因，GPLT推迟在线上举办。</p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/20210728224216.jpg" alt="2018CCCC团队天梯赛（西北工业大学）"></p><p><img src="https://cos.chdacm.cn//imgs/20210728224220.jpg" alt="2019CCCC团队天梯赛（西安电子科技大学）"></p>          </div><h2 id="集训队暑期集训"><a href="#集训队暑期集训" class="headerlink" title="集训队暑期集训"></a>集训队暑期集训</h2><p>为备战下半年亚洲区域赛，协会在暑假期间会组织暑期集训。</p><p>暑期集训的对象面向全校所有对算法和算法竞赛感兴趣的同学;集训内容将由协会集训队成员布置学习任务，并安排一定的算法讲课；暑期集训持续时间为学期结束起至下学期开学前，建议参与集训时间不少于3周，可自由选择一周放假休息调整状态；暑期集训地点在明远二区机房。</p><p>此外，协会集训队的队员会额外增加训练强度，每周由集训队队长挂题进行三人组队赛练习。同时，集训队队员每周会参与由杭电ACM承办的暑期多校联合训练比赛。</p><p>2017年暑假由于没有成功申请到机房，暑期集训安排在了明远1208。由于天气太过炎热，队员们主要在宿舍训练，完成每日相应的训练量。</p><p>2018年，暑假依旧炎热，暑假集训安排在了明远2501，队员们每天不仅与难题拼搏，还和炎热的天气，五楼进行斗争。</p><p>2019年，暑假依旧炎热，暑假集训安排在了明远2501，队员们每天不仅与难题拼搏，还和炎热的天气进行斗争。</p><p>往届暑期集训通知：<a href="/2019/07/14/summerCamp/">2019 CHD-ACM 暑期集训开始啦 | 长安大学ACM协会</a></p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/20210728223446.jpg" alt="暑假集训 (1)">  </p><p><img src="https://cos.chdacm.cn//imgs/20210728223442.png" alt="image-20210728223441547"></p>          </div><h2 id="长安大学ACM程序设计竞赛校赛"><a href="#长安大学ACM程序设计竞赛校赛" class="headerlink" title="长安大学ACM程序设计竞赛校赛"></a>长安大学ACM程序设计竞赛校赛</h2><p>本社团每年4月份都会举办长安大学ACM程序设计竞赛校赛，与迎新杯相比不同的是，校赛通常都是组队赛，英文题目，且比赛时间是标准的5小时，力求做到和正式比赛相似。校赛题目也是集训队成员自主命题，涉及范围较广。而且校赛的规模更大，校内外的参赛选手都更多。我校每年都将校赛作为选拔省赛参赛队伍的机会，同时我们也希望能给外校在省赛之前提供一次较为正式的组队比赛练习的机会。</p><p>2016年我校承办了陕西省ACM程序设计竞赛，故没有举办校赛。本社团在省赛期间做了大量准备工作，包括前期的宣传海报、队牌、参赛服装、参赛证图案设计以及定制；省赛官网准备；命题部分由集训队成员完成，部分由集训队成员联系权威出题人完成；比赛场地布置；校内宣传；比赛环境、服务器配置；比赛时判题，发放气球；赛后滚榜，赛题讲解等等。</p><p>2020年由于疫情原因未举办校赛。</p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/20210728223821.jpg" alt="省赛"></p><p><img src="https://cos.chdacm.cn//imgs/20210728223826.jpg" alt="省赛"></p><p><img src="https://cos.chdacm.cn//imgs/20210728223832.jpg" alt="省赛"></p><p><img src="https://cos.chdacm.cn//imgs/20210728223839.jpg" alt="省赛"> </p><p><img src="https://cos.chdacm.cn//imgs/20210728225358.png" alt="校赛"></p><p><img src="https://cos.chdacm.cn//imgs/20210728225407.png" alt="校赛"></p>          </div> <h2 id="陕西省其他高校ACM校赛"><a href="#陕西省其他高校ACM校赛" class="headerlink" title="陕西省其他高校ACM校赛"></a>陕西省其他高校ACM校赛</h2><p>本社团还积极带领成员参加陕西省其他友好高校的校赛，互相交流、切磋，一起进步。</p><p>在陕西省高校中，西北工业大学与西安电子科技大学群众基础较好，校赛规模较大且已经有多次举办比赛的经验。我校已经多次参加西安交通大学、西北工业大学和西安电子科技大学等高校校赛，并且从中学到了许多，也增进了校际友谊。各学校之间保持友好往来并交流经验，促进陕西ACM圈共同进步。</p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/20210728224034.jpg" alt="QQ图片20170421133103"> <img src="https://cos.chdacm.cn//imgs/20210728224039.jpg" alt="QQ图片20170421133431"></p><p><img src="https://cos.chdacm.cn//imgs/20210728224042.jpg" alt="QQ图片20170421133942"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> FAQ </category>
          
          <category> 入门指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门指南</title>
      <link href="/2018/07/28/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/07/28/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>文档目录<br><a href="/2014/04/02/cauu/">What’s ACM</a><br><a href="/2018/07/28/社团活动介绍/">协会活动介绍</a><br><a href="/2018/07/28/入门指南/">入门指南</a><br><a href="/faq">常见问题解答FAQ</a></p></div><p>在互联网时代，最缺的就不是资源。随着IT行业逐渐热门起来，网上随处都可以找到所谓“编程入门”资源。劣质的资源混在其中，这加大了我们的筛选成本，导致我们在学习正式的编程知识之前，需要花费大量的时间精力来筛选资源。</p><p>本文档建立的初心在于帮助新手或正在入门编程但还很迷茫的同学收集优质的资源，以及给出优秀前辈们总结的学习经验。</p><p>本文按照程序设计语言入门、算法入门的步骤来推荐资料。资料主要分为书籍、视频、学习网站等类别。</p><hr><h2 id="入门C-C-语言"><a href="#入门C-C-语言" class="headerlink" title="入门C/C++语言"></a>入门C/C++语言</h2><p>开始学习算法竞赛之前，你首先需要具备的能力是会<del>使用电脑</del> 一门编程语言。</p><p>如果你曾经学习过 Python、Java等程序设计语言，但是恰好没有学习过C或者C++，不用慌，没关系，你的编程基础会使你更快的掌握C/C++。同理，如果你学习过C/C++，那么在学习其他语言的时候也会更加轻松。</p><p>有同学可能会问：</p><p>$Q:$ 如果我只学过C（或者C++），还需要学C++（C）么？</p><p>$A$：需要，在入门阶段，这两者的差距较小，在后面的算法学习中这两者都会有应用。但要注意，算法竞赛不要求掌握过多的C++面向对象知识，同时也不需要纠结C语言中某些落后版本的规定（比如VC++6.0中的C98）。</p><p>接下来介绍一些初入门编程语言的学习资料：</p><ol><li><p>书籍：</p><ul><li>初入门：C语言从入门到精通、C++从入门到精通、刘汝佳《算法竞赛入门经典（第2版）》（前面部分章节）</li><li>精通：C primer plus、C++ primer plus（非必须掌握）</li></ul></li><li><p>网络文档教程</p><p> <a href="http://c.biancheng.net/cpp/">C语言中文网(文档型)</a> （讲解很详细，有例子，笔者强推）</p><p> <a href="http://www.runoob.com/cprogramming/c-tutorial.html">菜鸟教程(文档型)</a> </p></li><li><p>推荐视频</p><p> <a href="https://www.bilibili.com/video/BV19W411B7w1?from=search&amp;seid=76026721929323562">中国大学MOOC浙大翁凯</a>（火了很多年的慕课课程，如果B站链接失效，请告知QQ群内管理员）</p></li><li><p>在线编码教学：</p><p> <a href="https://www.imooc.com/learn/249">程序员慕课</a> （笔者入门时使用的网站，闯关式学习）</p></li><li><p><a href="https://www.acwing.com/activity/content/21/">语法基础课 - AcWing</a> （付费，Acwing全家桶系列之一，如果有条件可以考虑）</p></li></ol><p>也许上面的资料就足够眼花缭乱，但是建议同学们在学习时要多重复，可以先随便选一个资料去入门，并配合 <a class="btn-beautify button--animated blue outline" href="https://oj.chdacm.cn/problem_list.php" title="CHDOJ题单"><span>CHDOJ题单</span></a> 进行练习，如果有细节问题，可以在参考其他资料。</p><p>另外，不要寄希望于只看一次就学会它，它值得你在之后不断的重复学习。</p><hr><h2 id="Online-Judge-的使用方法"><a href="#Online-Judge-的使用方法" class="headerlink" title="Online Judge 的使用方法"></a>Online Judge 的使用方法</h2><p>Online Judge 系统（简称 OJ ）是一个在线的判题系统。用户可以在线提交程序多种程序（如C、C++、 Pascal）源代码 ，系统对源代码进行编译和执行，并通过预先设计的测试数据来检验程序源代码的正确性。</p><p>简单来讲，它可以验证你的代码是否正确。如果OJ返回了 <mark class="hl-label green">Accepted</mark> ，那么恭喜你，你的程序通过了测试。</p><p>他是我们学习编程的有力工具。</p><ul><li><p>Accepted : 程序通过!</p></li><li><p>Pending : 系统忙，你的答案在排队等待.</p></li><li><p>Pending Rejudge: 因为数据更新或其他原因，系统将重新判你的答案.</p></li><li>Compiling : 正在编译.</li><li>Running &amp; Judging: 正在运行和判断.</li><li>Presentation Error : 答案基本正确，但是格式不对。</li><li>Wrong Answer : 答案不对，仅仅通过样例数据的测试并不一定是正确答案，一定还有你没想到的地方.</li><li>Time Limit Exceeded : 运行超出时间限制，检查下是否有死循环，或者应该有更快的计算方法。</li><li>Memory Limit Exceeded : 超出内存限制，数据可能需要压缩，检查内存是否有泄露。</li><li>Output Limit Exceeded : 输出超过限制，你的输出比正确答案长了两倍.</li><li>Runtime Error : 运行时错误，非法的内存访问，数组越界，指针漂移，调用禁用的系统函数。请点击后获得详细输出。</li><li>Compile Error: 编译错误，请点击后获得编译器的详细输出。</li></ul><p>而只有AC(Accepted)，这道题才算完全通过。凡是出现PE，WA，TLE，MLE，RE，CE，都要做出调整，否则此题不算通过。</p><p>至此，你可以通过以下练习来更加深入的了解OJ的使用： <a href="https://oj.chdacm.cn/problemset.php?search=A%2BB+%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0">A+B练习</a></p><hr><h2 id="启程算法之旅"><a href="#启程算法之旅" class="headerlink" title="启程算法之旅"></a>启程算法之旅</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ol><li><p>入门</p><ul><li>啊哈磊《啊哈算法》<ul><li>启蒙书，只适合用来入门</li></ul></li><li>巫泽俊 《挑战程序设计竞赛（第2版）》</li><li>刘汝佳《算法竞赛入门经典（第2版）》<ul><li>适合搭配其他书使用，该书并不适合单纯入门，但是书中有些讲解非常凝练精干，适合后期攻克专题时使用。</li></ul></li><li><p>陈小玉《算法训练营 入门篇》</p><ul><li>21 年新出的书，内容很全并且图很多（图多更好理解，入门者的福音）</li></ul><div class="justified-gallery"><p><img src="https://img14.360buyimg.com/n0/jfs/t5863/201/1981195052/596029/d1380115/592bf169N864816a5.jpg" alt="啊哈算法"></p><p><img src="https://img14.360buyimg.com/n0/jfs/t8827/272/823848141/156060/d9e40784/59afa995Na246151b.jpg" alt="挑战程序设计"></p><p><img src="https://img14.360buyimg.com/n0/jfs/t3094/190/374119444/247947/7452f50a/57b3d5c4Ne4ab29bf.jpg" alt="算法竞赛入门经典"></p><p><img src="https://img14.360buyimg.com/n0/jfs/t1/178585/9/11964/187200/60dc21faE04c06d3c/8144512cce432565.jpg" alt="算法训练营"></p>          </div></li></ul></li></ol><ol><li><p>进阶</p><ul><li><p>李煜东 《算法竞赛 进阶指南》（笔者进阶时使用的主力书）</p></li><li><p>刘汝佳《算法竞赛 入门经典 训练指南》</p></li><li><p>陈小玉《算法训练营 提高篇》</p><ul><li>同样是 2021 年新书，图很多</li></ul><div class="justified-gallery"><p><img src="https://img14.360buyimg.com/n0/jfs/t1/149663/24/14878/116348/5fb4c3cbE262e566d/30a82e6273902411.jpg" alt="算法竞赛 进阶指南"><br><img src="https://img14.360buyimg.com/n0/jfs/t1/168621/19/16629/93225/606bca2fE88e3b55c/e4c2092e3c7d412c.jpg" alt="算法竞赛入门经典"><br><img src="https://img14.360buyimg.com/n0/jfs/t1/37618/34/16160/155214/60ae4942E90e55ddc/a20021b4e96e124c.jpg" alt="算法训练营"></p>          </div></li></ul></li></ol><p>最后，是笔者收集的一些算法的电子书，可以自行下载。</p><p>链接：<a href="https://pan.baidu.com/s/1jJvlICk2-EPMPTDIn6IyFA">百度网盘</a> 密码：yyew</p><p><img src="https://i.loli.net/2021/07/26/qn27NZPg3BGfpFe.png" alt="图片5.png"></p><h3 id="推荐网站："><a href="#推荐网站：" class="headerlink" title="推荐网站："></a>推荐网站：</h3><ol><li><p><a href="https://oj.chdacm.cn/">CHDOJ</a> 由长安大学ACM协会维护运营，有适合初学编程语言以及算法入门的练习题，以及长安大学历年新生赛和校赛的题目。<img src="https://cos.chdacm.cn//imgs/20210729082807.png" alt="CHDOJ 2021-07-26 下午5.38"></p></li><li><p><a href="https://www.luogu.com.cn">洛谷OJ</a> 主要面向OI选手（中学生信息竞赛)。有着非常友好的界面以及丰富的国内外OI题库。<img src="https://cos.chdacm.cn//imgs/20210729082820.png" alt></p></li><li><p><a href="https://vjudge.net">Virtual Judge</a> 并非真实的OJ，它并不提供评测服务，只是将你提交的代码送到各个OJ评测，然后抓取评测结果返回给你。也是CHDACM协会以及集训队训练的主要平台之一。<img src="https://cos.chdacm.cn//imgs/20210729082825.png" alt></p></li><li><a href="https://codeforces.com">CF (Code Forces)</a> 俄罗斯OJ，始于2010年，一直以来都是非常热门的OJ，几乎每周都会有比赛，适合全阶段选手练习。<img src="https://cos.chdacm.cn//imgs/20210729082830.png" alt></li><li><a href="https://www.acwing.com/">Acwing</a> NOI金牌保送北大选手闫雪灿创办的OJ。有极为优质的学习资源（包含付费），社区也很完善，你可以在上面找到志同道合的伙伴。</li><li>题库丰富的学校运营OJ<ul><li><a href="http://acm.hdu.edu.cn/">HDU</a>（杭电运营）</li><li><a href="http://poj.org/">POJ</a>（北大运营）</li><li><a href="https://zoj.pintia.cn/home/news">ZOJ</a>（浙大运营）</li></ul></li></ol><div class="note info simple"><p>更多学习资源请参考：<a href="https://oi-wiki.org/contest/resources/">学习资源 - OI Wiki (oi-wiki.org)</a></p><p>另外，我们也推荐同学们去知乎、博客园、CSDN等程序员较为活跃的社区，从那里你或许可以找到有用的经验知识。</p></div><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>也许你们曾经听过，最好的学习方法是讲给别人听，不断地重复将会使你的理解更加深刻，记忆更加牢固。因此，非常推荐当同学们有所收获时，将其记录下来，如果可以，尝试凝练一下语言，提炼一下知识点和易错点，发表到博客上，可以帮助在算法学习路上的其他人。</p><p>这里是一些学长们的博客，供大家参考：<a class="btn-beautify button--animated " href="/links" title="友情链接"><span>友情链接</span></a></p><p>最后，笔者想说：</p><p>或许你是一个新人，面对英文网站时瑟瑟发抖，在群里大佬们侃侃而谈时默默窥屏，想要入门但又不知如何起步，遇到困难也找不到人求助，经过一番内心针扎后也不敢点开私聊框向大佬发起询问，害怕得不到回应或者被嫌弃。</p><p>我曾经也是这样的，由于高中到大学的转变，不再有人催促着自己学习，尽管非常想踏进算法的大门，但却被现实狠狠的打击。是的，算法竞赛门槛很高，绝大部分的内容大学课堂上并不会涉及，ICPC更是被称为计算机界的奥林匹克竞赛，难度可想而知。</p><p>也许在未来，你会受到很多挫折，每天背着沉重的电脑奔波在图书馆自习室，一个难题磕了一整个下午也不会，十几到几十次的提交，红橙相伴永不见绿。你会怀疑自己为什么别人十分钟可以AC的题自己五个小时也做不出，你会抱怨为什么队友整天都在搞别的从不来训练。那么我们究竟是为了什么，要下决心去参加算法竞赛？</p><p>也许，只是为了热爱。</p><p>也许你已经知道了ACM在IT界的光环，它可以帮助你在拿奖学金、保研、考研以及找工作时有一定优势，但是如果目的仅仅是这些，那ACM的性价比将会非常的低。因为有更多的竞赛以及手段，可以达到这个目的。</p><p>我在2019年秦皇岛冬令营时，第一天的比赛非常难，罚坐五小时只做出来一个题，当全场同学都在抱怨时，qls（北师大ACM退役选手，冬令营赛题出题人）在群里告诫大家：”题可以不会做，思考不能停”。题做不出来很难受，但是竞技比赛，魅力在于拼搏的过程，只有经历过这种感受，才能体会 <mark class="hl-label green">Accepted</mark>  的快乐。</p><p>在之后的比赛中，排名由最初的130多进步到32。（Div2 共有150支左右的队伍）</p><div class="justified-gallery"><p><img src="https://cos.chdacm.cn//imgs/image-20210728180215466.png" alt="冬令营比赛时仅通过的一题"></p><p><img src="https://cos.chdacm.cn//imgs/image-20210728180542087.png" alt="冬令营Day2至Day7比赛排名变化"></p>          </div><p>”1%的时间用来学习，99%的时间用来刷题“，wls（上交退役选手，多次举办公益Camp）这样讲。新知识的学习只会占一小部分，大部分的时间用来练习。</p><p>也可能有人会反驳，这不是妥妥的刷题机器吗？当参加算法竞赛成为你获得利益的一种手段时，确实是这样。竞技比赛不同于普通的考试，就像奥运会一样，运动员不停的训练不仅仅是为了奖牌，而是为了展现一种精神。</p><p>最后，希望入门指南能够在你的算法编程学习旅程上提供一点帮助。如果你还想了解更多，可以再看看协会创始人——李韡学长（2012级）毕业时写下的<a href="/2016/08/30/learn_from_club/">入门指南</a></p><p>噗，忘记自我介绍了，我是17级信息学院计科专业的韩耀东，大一升大二的暑假开始入门ACM，在学习ACM的旅途中经历过很多困难，也遇到过惊喜，希望我写的这一篇入门指南可以帮助到大家。</p><p><img src="https://i.loli.net/2021/07/26/OkLrASNqobwvesj.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> FAQ </category>
          
          <category> 入门指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017萌新看这里！！</title>
      <link href="/2017/09/07/welcome_fresher/"/>
      <url>/2017/09/07/welcome_fresher/</url>
      
        <content type="html"><![CDATA[<h1 id="A协纳新啦！啦！！啦！！！"><a href="#A协纳新啦！啦！！啦！！！" class="headerlink" title="A协纳新啦！啦！！啦！！！"></a>A协纳新啦！啦！！啦！！！</h1><p><strong>长安大学ACM-ICPC协会纳新啦！期待你的加入！！！</strong></p><p>新一届的纳新工作又开始啦，我们还准备了有趣的题目和小礼品哦！<br>不管你是哪个学院，不管你是哪个专业<br>喜欢算法，喜欢挑战的萌新们<br>还等什么，赶快加入我们吧！！    </p><hr><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a><a href="http://chdacm.github.io/pages/faq/">FAQ</a></h2><p>$Q:$ 什么是 $ACM \; ICPC$ 吖？<br>$A:$ 这是国际大学生程序设计竞赛的简称啦~<br>也就是说，如果你水平足够的话是可以参加每年一次的世界总决赛的(orz…)。</p><hr><p>$Q:$ 那A协是干嘛的吖？<br>$A:$ 我们是一群喜欢算法的萌新。<br>啊，不对，泥萌才是萌新！我们只是算法爱好者~<br>那泥萌喜欢算法嘛&amp;_&amp;喜欢就加入我们吧！  </p><hr><p>$Q:$ 什么是C语言？什么是算法？什么是程序设计？<br>$A:$ 你需要看<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">这个</a>嘛，还有<a href="http://www.jianshu.com/p/7feeac080171">这个</a>。<br>或许看一道题目你能更清晰的了解ACM-ICPC，<a href="http://poj.org/problem?id=3372">点这里</a>。</p><hr><p>$Q:$ 比赛形式是什么样的吖？<br>$A:$ 正式比赛中，是最多三个人一支队伍，共同使用一台电脑，解决约十道题目。可以携带任何纸质资料，题目为英文描述。在提交某道题目的答案后几分钟内即可出现是否通过此题目的结果。</p><h2 id="关于培训"><a href="#关于培训" class="headerlink" title="关于培训"></a>关于培训</h2><p>在上学期，我们会有C语言培训课。所以，不必担心你不会C语言！<br>数学不好，也没有关系。我们会在上学期和下学期开展算法课。<br>只要你喜欢编程，热爱算法，我们都是欢迎的！  </p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/jj472354ccb05e4f29f287c144af2589d10455a37f.jpg" alt="yx"></p><h2 id="举办的活动"><a href="#举办的活动" class="headerlink" title="举办的活动"></a>举办的活动</h2><p>一般来说，每学期会有一次。<br>在上学期会有针对校内新生的迎新赛(会有奖状学分哦）。</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp1.jpg" alt="jz"></p><p>在下学期会有校赛（组队形式，会有奖状学分哦），而且会邀请其他学校的道友一起来玩！</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/IMG_20160521_170226.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/7202027.png" alt="img"></p><p>好吧，培训课勉强拿来凑数啦！ 哈哈   </p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/201907.png" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/2245.png" alt="img"></p><p>在2016年，我们主办了第四届陕西省ACM程序设计竞赛，那是整个陕西省ACM水平腾飞的一个起点。也许在不久的将来，我们还会举办亚洲区域赛。</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/SSS1463977558597.jpg" alt="img"></p><h2 id="参加的活动"><a href="#参加的活动" class="headerlink" title="参加的活动"></a>参加的活动</h2><p>我们能参加的活动很多的吖！不仅仅是我们自己举办的活动！<br>我们参加过西交、西电、西工大、陕师大的校赛、参加省赛、每年还有一个CCCC天梯挑战赛……当然，我们还有最重要的活动，ACM-ICPC亚洲区域赛，在亚洲区域赛上获奖是每个ACMER的愿望。</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp3.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/s7204105.png" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp2.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp4.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/IMG_20131019_121622.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/sk.jpg" alt="img"></p><p>想知道我们近几年的成绩吗？<a href="http://chdacm.club/2016/11/13/chdjxd/">请戳这里</a></p><p>有没有很心动？那就快来加入我们吧！</p><h2 id="纳新对象"><a href="#纳新对象" class="headerlink" title="纳新对象"></a>纳新对象</h2><p>主要针对大一新生，就是那种”我爱学习，无法自拔”的新生哟！<br>在百团大战当天找到我们的位置就OK啦～<br>对于大二三的喜欢算法、希望代表学校参加各类算法比赛的请加入萌新群向群主咨询<br>(如果是什么都不会的请参考上一行)。  </p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>QQ:</p><ul><li><p>长大A协正式群: <strong><a href="http://jq.qq.com/?_wv=1027&amp;k=2KogR3q">88837395点击加入</a></strong></p></li><li><p>长大A协萌新群: <strong><a href="https://jq.qq.com/?_wv=1027&amp;k=5QnlMs6">658850543点击加入</a></strong></p></li></ul><p>～正式群禁水哟～</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 迎新 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>北方大学多校联合训练第十一场（长安大学）简要题解</title>
      <link href="/2017/05/14/2017-5-14-solution/"/>
      <url>/2017/05/14/2017-5-14-solution/</url>
      
        <content type="html"><![CDATA[<h1 id="北方大学多校联合训练第十一场（长安大学）简要题解"><a href="#北方大学多校联合训练第十一场（长安大学）简要题解" class="headerlink" title="北方大学多校联合训练第十一场（长安大学）简要题解"></a>北方大学多校联合训练第十一场（长安大学）简要题解</h1><hr><h2 id="A-Palindrome"><a href="#A-Palindrome" class="headerlink" title="A.Palindrome"></a>A.Palindrome</h2><p>先把相邻的同字母段合并，跑一遍马拉车，注意只有长度和字母均相等才继续扩展。统计答案的时候再考虑两侧可能还有一段字母相同但是长度不同，取两边长度较小者。  </p><h2 id="B-Triangles"><a href="#B-Triangles" class="headerlink" title="B.Triangles"></a>B.Triangles</h2><p>小于三个点的情况答案为零。考虑三个点的情况，由于三点不共线，必然构成一个三角形。现加入第四个点，若其在原三角形外部，则称其为外点，可以新构造$1$个三角形；若其在原三角形内部，则称其为内点，可以新构造$3$个三角形。故要尽可能让更多的点成为内点。假设这$n$个点的凸包上有$m$个点，这$m$个点必然只能是外点，将凸包剖分成$m - 2$个三角形后，剩余$n - m$个点均为内点，答案即为$3n - 2m - 2$。  </p><h2 id="C-XOR-Queries"><a href="#C-XOR-Queries" class="headerlink" title="C.XOR Queries"></a>C.XOR Queries</h2><p>若询问固定$[L, R]$，那么可以用字典树维护$[L, R]$之间所有数的二进制表示，每次询问$(A, B)$只要在树上统计一遍即可。那么对于不同的$[L, R]$，可以用线段树或者类似的离线分治将询问区间分成$log$个然后在每个字典树上分别统计再求和。莫队维护字典树转移应该也可以通过本题。  </p><h2 id="D-Annual-Party"><a href="#D-Annual-Party" class="headerlink" title="D.Annual Party"></a>D.Annual Party</h2><ul><li>若题目为树上单组询问，只要维护子树中关键点个数以及关键点到根的距离之和$dp$两遍即可。  </li><li>若题目为树上多组询问，由于$\sum k \leq 100000$，每次建虚树$dp$即可。  </li><li>若题目为环套树上单组询问，先把环抠出来，环上每个点作为根按照树上版本做，第二次$dp$之前对于每个根需要统计其他树上所有关键点到它的距离，注意到环上存在一个分界点，分界点一侧的根从环左侧到当前根比较近，另一侧则从环右侧到当前根比较近，而遍历根的时候这个分界点也是单调的，故滑窗在环上扫一遍即可。  </li><li>那么对于本题环套树上多组询问，可以类似的用虚树方法，环上每个根下的子树按树上版本做，环上只保留子树中有关键点的根，环上其余的边压缩掉，环上的处理同上，由于这样最多仅增加了$\sum k$个点，故复杂度和上面是一样的。  </li></ul><h2 id="E-Modules"><a href="#E-Modules" class="headerlink" title="E.Modules"></a>E.Modules</h2><p>显然安置完所有模块形成以主板为根的树，即为一个非常耿直的最大树形图问题。建图先考虑每个模块若无加成则可以直接连在主板上，再考虑加成给$m$对模块连边。  </p><h2 id="F-Expectation"><a href="#F-Expectation" class="headerlink" title="F.Expectation"></a>F.Expectation</h2><p>定义$f[x]$为满足$L \leq a, b \leq R$且$a \bigoplus b = x$的有序对$(a, b)$数目，那么第$i$个位置填数$j$带来的贡献为：  </p><script type="math/tex; mode=display">(f[2j] + f[2j+1]) \cdot \frac{1}{R - L + 1} \cdot \frac{i - 1}{R - L + 1} \cdot \frac{N - i}{R - L + 1}</script><p>单个$f[x]$可以用数位$dp$在$O(log(x))$时间求出，直接求每个$f[x]$再统计一遍答案就可以通过本题了，但是稍微整理一下就发现答案是：  </p><script type="math/tex; mode=display">\frac{1}{(R - L + 1)^3} \cdot \sum_{i = 1}^{N} (i - 1) \cdot (N - i) \cdot \sum_{j = L}^{R}(f[2j] + f[2j+1])</script><p>前面可以$O(1)$求，最后一项关于$f$的和式一次数位$dp$就可以$O(log(R))$求出。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长安大学第二届ACM程序设计竞赛校赛简要题解</title>
      <link href="/2017/04/24/2017-4-24-solution/"/>
      <url>/2017/04/24/2017-4-24-solution/</url>
      
        <content type="html"><![CDATA[<h1 id="长安大学第二届ACM程序设计竞赛校赛简要题解"><a href="#长安大学第二届ACM程序设计竞赛校赛简要题解" class="headerlink" title="长安大学第二届ACM程序设计竞赛校赛简要题解"></a>长安大学第二届ACM程序设计竞赛校赛简要题解</h1><hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>1.出现了密码条打错，网络故障，全程开外网，现场缺乏管理，配置不好用等等问题，沿袭了一直以来校赛出状况的传统，真心感谢各位能够谅解。<br>2.特别感谢西邮袁子涵和张浩然，帮我们解决了$PC^2$的种种问题，并帮忙渡过了正赛开场时最艰难的时候。  </p><h2 id="A-Count-Circles"><a href="#A-Count-Circles" class="headerlink" title="A.Count Circles"></a>A.Count Circles</h2><p>简单统计一下即可，一些写法需要特判$0$的情况。  </p><h2 id="B-Boys-and-Girls"><a href="#B-Boys-and-Girls" class="headerlink" title="B.Boys and Girls"></a>B.Boys and Girls</h2><p>注意到同性之间的交换位置没有意义，故初始序列和最终序列相比，同性之间的相对位置是不发生变化的。即是说如果初始序列是$B<em>{1}…B</em>{2}…B<em>{3}……B</em>{n}$，省略号处表示有若干个$G$，那么最终序列是$B<em>{1}GB</em>{2}GB<em>{3}G…B</em>{n}G$或者$GB<em>{1}GB</em>{2}GB<em>{3}…GB</em>{n}$,那么最少交换次数就是每个$B$从初始位置移动到最终位置需要的步数之和，分别计算$BGBG…$和$GBGB…$的答案取小者即可。  </p><h2 id="C-Roses"><a href="#C-Roses" class="headerlink" title="C.Roses"></a>C.Roses</h2><p>枚举一个圆，对没有被此圆覆盖的点求最小圆覆盖，复杂度为$O（n^4）$。  </p><h2 id="D-Arrays"><a href="#D-Arrays" class="headerlink" title="D.Arrays"></a>D.Arrays</h2><p>离线询问，将点按$A$，询问按$x$排序后，问题变成了带修改的求$[L， R]$区间内$B$大于等于$y$的数目，这个问题可以用树套树解决。  </p><h2 id="E-Colorful-Ribbon"><a href="#E-Colorful-Ribbon" class="headerlink" title="E.Colorful Ribbon"></a>E.Colorful Ribbon</h2><p>考虑$dp[i]$表示前$i$个字符的合法方案数，枚举上一个断点，那么$dp[i] = \sum _{k = p} ^ {i - 1} dp[k]$, 其中$p$代表上一个断点能取的位置中最靠前的一个，容易发现$p$是单调递增的，因此只要维护$p$和$dp$的前缀和以及每个字母上一次出现的位置就能$O（n）$解决。  </p><h2 id="F-XOR-mean"><a href="#F-XOR-mean" class="headerlink" title="F.XOR-mean"></a>F.XOR-mean</h2><p>考虑分块，块长为$C$，对于当前块，统计：  </p><p>1.$i$，$j$，$k$均属于当前块  </p><p>2.$i$，$j$属于当前块，$k$属于后一块  </p><p>3.$i$属于前一块，$j$，$k$属于当前块  </p><p>4.$i$属于前一块，$j$属于当前块，$k$属于后一块  </p><p>这样是不重不漏的，前三种情况可以暴力，第四种情况 $ fwt $，总复杂度<script type="math/tex">O(NC + \frac{N}{C}  \lvert A \rvert log(\lvert A \rvert))</script>.  </p><h2 id="G-K-partite-Graph"><a href="#G-K-partite-Graph" class="headerlink" title="G.K-partite Graph"></a>G.K-partite Graph</h2><p>检查补图是否是$k$个完全图即可。  </p><h2 id="H-Boxes"><a href="#H-Boxes" class="headerlink" title="H.Boxes"></a>H.Boxes</h2><p>比较的耿直费用流，边用$（flow， cost）$表示：  </p><p>源点到每个格子$（a， 0）$，  </p><p>每个格子到汇点$（h， 0）$，  </p><p>每个格子到相邻格子$（INF， 1）$。  </p><h2 id="I-Annual-Party"><a href="#I-Annual-Party" class="headerlink" title="I.Annual Party"></a>I.Annual Party</h2><p>单次询问可以维护子树中关键点数目和关键点到根距离之和两次树$dp$解决，由于$\sum k \leq 100000$，建虚树处理每次询问。  </p><h2 id="J-Repeated-String"><a href="#J-Repeated-String" class="headerlink" title="J.Repeated String"></a>J.Repeated String</h2><p>容易观察到每一位的字母对答案的影响是独立的，只要统计这一位每个字母出现了几次，再枚举这一位填什么字母即可求得最小值，复杂度$O（26nm）$。  </p><h2 id="K-Brackets"><a href="#K-Brackets" class="headerlink" title="K.Brackets"></a>K.Brackets</h2><p>按照题中所给的条件，第$x$对括号内可以包含至少$y - x$对括号，至多$n - x$对括号。假设要统计第$x$对括号内包含$k$对括号的方案数，我们可以假想把第$x$对括号与其内部包含的所有括号压缩成单对括号，那么令$f[i][j]$表示由$i$对括号组成，第$j$对括号紧贴（即第$j$对括号中间不含其他括号）的方案数，答案为$f[n-k][x] \cdot Catalan(k)$。  </p><p>同样利用压缩的思想，考虑由所有合法括号序列减去不符合要求的情况，容易得到递推关系：  </p><script type="math/tex; mode=display">f[i][j] = Catalan(i) - \sum_{k = 1}^{i-j}f[i-k][j] \cdot Catalan(k)</script><p>直接做预处理$f$的复杂度是$O(n^3)$，也可以用分治$fft$加速，单组询问$O(n)$。  </p><p>难以发现但可以证明，事实上$f[i][j] = \sum _{k = 1} ^{j} Catalan(i-k) \cdot Catalan(k-1)$，可以$O(n^2)$预处理。  </p><p>场上过的都是用$dp[i][j]$表示$i$个左括号和$j$个右括号的合法前缀数，把序列按$x$左侧，$x$与$y$之间，$y$右侧分成三段，每组询问$O(n^2)$枚举其中两段的右括号数目统计方案数。  </p><h2 id="L-QAQ-Number"><a href="#L-QAQ-Number" class="headerlink" title="L.QAQ Number"></a>L.QAQ Number</h2><p>数据范围内所有的$QAQ$数总共只有$540$个，打表。  </p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 长安大学校赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长安大学ACM协会讲课记录之『基础数据结构—并查集』</title>
      <link href="/2016/12/10/bcj/"/>
      <url>/2016/12/10/bcj/</url>
      
        <content type="html"><![CDATA[<h2 id="讲课之前"><a href="#讲课之前" class="headerlink" title="讲课之前"></a>讲课之前</h2><p>&#8195;我们不妨先考虑下傻瓜式合并，加入我们开一个数组表示某一个集合，那么在集合合并的时候，需要把每一个元素移动至对应集合，合并复杂度O(n),查找复杂度O(n)。<br>我们能优化合并么？当然可以，用链表或者STL的list。  </p><p>由于不支持随机存取，那么查找的复杂度还是O(n)。怎么优化查找，那就用并查集了  </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#8195;并查集顾名思义就是有“合并集合”和“查找集合”两种操作的关于数据结构的一种算法。  </p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> par[x] = <span class="built_in">find</span>(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="合并："><a href="#合并：" class="headerlink" title="合并："></a>合并：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(rank[x]&lt;rank[y])</span><br><span class="line">    &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判同："><a href="#判同：" class="headerlink" title="判同："></a>判同：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>&#8195;复杂度很玄，算法导论有证明。路径压缩好写，但是大多数人不写启发式合并，可能会被卡。。  </p><h2 id="裸并查套路"><a href="#裸并查套路" class="headerlink" title="裸并查套路"></a>裸并查套路</h2><p>&#8195;并查集大约有以下特征但不局限于此。  </p><ul><li><p>维护区域信息  <code>KRUSKAL</code>最小生成树算法，无向图的环，无向图连通分量，线段覆盖，区域联通等  </p></li><li><p>维护关系  拆点，<code>lCA</code>，虚拟图，等价类等  </p></li><li><p>破坏关系  拆边，逆向并查集等//正难则反  </p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>L1</strong></p><p><code>TOJ2469 Friends</code></p><p>题目描述：有n个人，m对朋友关系，朋友关系对称且可传递，求有几个朋友圈。  </p><p>分析：事实上是求一个无向图的连通分量数，并查集轻松搞定。  </p><p><code>TOJ3294 Building Blcok</code></p><p>题目描述：一开始有n个Block，分别放置在地面上，有P个操作，操作有两种类型：  </p><p>M a b如果a,b没有在一个Block组里，把包含a Block的Block组放在包含b的Block组之上。  </p><p>C a 输出有多少个Block被压在了a之下。  </p><p>类似题目 排队询问间隔  </p><h3 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h3><p>scau 1138 代码等式 //题目链接实在搞不到  </p><p><strong>Description</strong> </p><p>&#8195;一个代码等式就是形如 $ x<em>{1}x</em>{2} \dot x<em>{i} = y</em>{1}y<em>{2} \dot y</em>{j} $ ，这里$ x<em>{i} $和 $ y</em>{j} $是二进制的数字（0或1）或者是一个变量（如英语中的小写字母）。每一个变量都是一个有固定长度的二进制代码。  </p><p>例如：  </p><p>a,b,c,d,e是变且它们的长度分别是4,2,4,4,2。考虑等式：1bad1 = acbe ，这个等式共有16组解。现要求任给一个等式，计算一共有多少组解。（变量最多26个，长度和不超过10000）  </p><p>输入格式  </p><p>&#8195;第一行数N为变量个数；第二行N个数，为每个变量的位数；第三行为一个等式  </p><p>输出格式  </p><p>&#8195;输出解的个数，无解输出0  </p><p>输入样例  </p><blockquote><p>5<br>4 2 4 4 2<br>1bad1=acbe</p></blockquote><p>输出样例  </p><blockquote><p>16</p></blockquote><p> <a href="http://codevs.cn/problem/2597/">code[vs] 2597 团伙</a>  </p><p><strong>描述</strong> </p><p>&#8195;1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是A的朋友的朋友是A的朋友；A的敌人的敌人也是A的朋友。   </p><p>&#8195;两个强盗是同一伙的当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你至多有多少个强盗团伙。  </p><p><strong>输入格式</strong></p><p>&#8195;输入的第一行为N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。第二行M(1&lt;=M&lt;=5000)，表示信息条数。以下M行，每行可能是F p q或是E p q，分别表示p和q是朋友，或是敌人。假设输入不会产生矛盾  </p><p><strong>输出格式</strong></p><p>&#8195;输出只有一行，表示最大可能的团伙数。  </p><blockquote><p>朋友很好处理。<br>很明显一点，一个人的敌人一定是一个集合。<br>设e[x] 为x的敌人集合，如果出现p,q是敌人 那么就把e[p]与q合并 e[q]与p合并<br>合并次数为T  那么ans为N-T<br>改变询问内容 变为维护关系<br>维护区域</p></blockquote><p>可以搞一些BFS求联通水域//<br>线段覆盖问题//</p><blockquote><p>维护关系  </p></blockquote><p>POJ 食物链 把团伙关系加强版</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长安大学第三届“迎新杯”程序设计竞赛题解</title>
      <link href="/2016/12/06/CHDU3_rt/"/>
      <url>/2016/12/06/CHDU3_rt/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先感谢各位dalao前来参赛，感谢各位领队帮忙判题发球。  </p><p>比赛之前我们做了不少准备，为的是能做好命题和评测以及招待外宾的工作，不知道各位是否还觉得满意呢。  </p><p>很高兴这次比赛没有出什么大问题，尽管有熟悉的<code>ESA</code>，熟悉的烂鼠标，以及热身最后崩了一小下。同时赛后我们发现打印的题面并不是最新版本的，但是数据并没有问题，这可能导致一些选手白白花时间多考虑了一些细节上的问题，深表歉意。  </p><p>我们强行续了一把OJ，尽管它还不是很稳定，目前只放了这次迎新杯的题目，欢迎选手补题，没来现场的也可以在OJ上小玩一下。  </p><p>题面链接：<a href="/cources/file/rs.pdf">戳这里看热身赛题面</a><br>题面链接：<a href="/cources/file/zs.pdf">戳这里看正式赛题面</a><br>比赛链接：<a href="http://112.74.33.53/contests/">点击进入,需要先注册</a><br>终榜链接：<a href="/cources/file/chd3zb.html">戳这里膜大佬</a></p><p>最后，希望各大院校今后都能加强交流与友好往来，祝陕西省的ACM越来越好。  </p><h2 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a>热身赛</h2><h3 id="难度分布"><a href="#难度分布" class="headerlink" title="难度分布"></a>难度分布</h3><p>热身赛主要让选手熟悉环境与PC^2的使用方法，一共设置了四道题目。其中第一道为测试提交的题，另外三道大概是随便暴力题或比较近期的一些原题简化。由于是热身赛所以难度上也没有去把控，导致有萌新绝望卡题，也有dalao光速AK。  </p><h3 id="A-欢迎来到彩虹岛-签到"><a href="#A-欢迎来到彩虹岛-签到" class="headerlink" title="A.欢迎来到彩虹岛 签到"></a>A.欢迎来到彩虹岛 <code>签到</code></h3><p>题意：输出“Welcome to CHD”  </p><p>解析：本题为测试提交题，Hint中写了AC代码。  </p><p>吐槽：judge真的收到了好多奇怪的东西……  </p><h3 id="B-粉刷篱笆-模拟-暴力"><a href="#B-粉刷篱笆-模拟-暴力" class="headerlink" title="B.粉刷篱笆 模拟 暴力"></a>B.粉刷篱笆 <code>模拟</code> <code>暴力</code></h3><p>题意：n段篱笆，初始为原木色，m次操作，$[l<em>{i},r</em>{i}],color_{i}$，表示把区间的篱笆染成该颜色，问篱笆最后有几种颜色。  </p><p>解析：模拟染色过程，用一个数组维护篱笆的颜色，每次染色操作暴力扫染色区间修改颜色，最后扫一遍统计多少种不同颜色，复杂度O(nm)。  </p><h3 id="C-拯救小伙伴-博弈"><a href="#C-拯救小伙伴-博弈" class="headerlink" title="C.拯救小伙伴 博弈"></a>C.拯救小伙伴 <code>博弈</code></h3><p>题意：给一个二进制串，每次操作选择一个“1”，将其自身及其左边所有数字进行0/1反转，无法操作者输，问谁胜。  </p><p>解析：注意到每次操作最左边的数字必然会被翻转，而结束时最左边的数字必然是0，故若初始时最左边的数字是0，则到游戏结束时必然翻了偶数次，即后手胜，反之则先手胜。  </p><p>吐槽：比较近的原题简化……  </p><h3 id="D-魔法少女的数学题-数学"><a href="#D-魔法少女的数学题-数学" class="headerlink" title="D.魔法少女的数学题 数学"></a>D.魔法少女的数学题 <code>数学</code></h3><p>题意：给一个正整数k，问存在多少二元组(p, q)使得$p \cdot q = k$且gcd（p， q） = 1。<br>解析：对于k的每个素因子$Prime<em>{i}$，它不能同时是p,q的因子，否则不满足pq互质，故只有$Prime</em>{i}$是p的因子或者$Prime_{i}$是q的因子这2种情况，如果k有n个不同的素因子，那么答案就是$2^n$。统计不同素因子个数暴力O($\sqrt k$)分解即可。  </p><p>吐槽：依然比较近的原题简化……  </p><h2 id="正式赛"><a href="#正式赛" class="headerlink" title="正式赛"></a>正式赛</h2><h3 id="难度分布-1"><a href="#难度分布-1" class="headerlink" title="难度分布"></a>难度分布</h3><p>由于去年题目难度分布不合适，给一些学校的萌新造成了心理阴影，今年花了很长时间来确定题目难度分布，同时想把题面讲的更清楚更有趣些。从结果来看除了G题描述上坑到了不少人，其他题目与我们的期望差不多。  </p><p>考虑到来参加比赛的选手水平差距较大，有刚上手的萌新，也有在Regional拿了许多牌的dalao，我们今年增加题目数量至12题，让萌新能有题做，dalao也不会觉得很无趣。  </p><p>其中A，B，C三题的定位是简单题，希望大部分人都能出，考虑到题数较多，萌新不太会找水题，于是特意放在了最前面，但似乎造成了题目是难度递增的假象。  </p><p>我们认为在这样的个人赛中，CF风的题目是比较合适的，对于新人来说难度与码量不会太大，需要稍微想一些trick，于是便有了DE。结果确实卡了不少人，尤其是E题甚至卡到了dalao，裁判组甚至一度陷入了怀疑数据出错的状态。  </p><p>为了丰富内容，我们又增加了一个中学知识足以解决的几何F，一个暴力的回文串H，以及一个容易猜结论的构造L。我们认为这几个题目都是不需要前置知识，只要肯想肯算，有一定码力都能出。最后F的出题量比我们预期少很多，而猜出L的人很多。  </p><p>由于我们之前给自己学校的新人讲过一些算法，于是我们决定出少量套路题给努力做练习的同学，于是有了I题二分与J题BFS，事实证明我们的小朋友果然没有做题呢。: )  </p><p>最后G题是一个数学递推，K题是一个无趣的LCA，纯粹是怕dalao太快AK闲着无聊，后来发现前面的trick耽误了选手太多时间，而且4小时12题确实是太多了……  </p><p>以上是我们出题时的想法，而最后的Board也不算难看，对于一些不合理的地方，我们今后会吸取经验并改正。  </p><h3 id="A-捍卫彩虹岛-签到"><a href="#A-捍卫彩虹岛-签到" class="headerlink" title="A. 捍卫彩虹岛 签到"></a>A. 捍卫彩虹岛 <code>签到</code></h3><p>题意：给8个整数$Lv<em>{i}$，输出$\left \lfloor \frac{\sum</em>{i = 1}^{8}Lv_{i}}{8}  \right \rfloor$。  </p><p>解析：int直接就向下取整了。  </p><h3 id="B-恐高的单身老柴犬-暴力"><a href="#B-恐高的单身老柴犬-暴力" class="headerlink" title="B.恐高的单身老柴犬 暴力"></a>B.恐高的单身老柴犬 <code>暴力</code></h3><p>题意：给n级台阶的绝对高度$h_{i}$（递增），以及一个容许高度x，一个人可以走到小于等于x的最高位置，然后用道具飞到楼梯顶端，问飞行最小高度。  </p><p>解析：扫到小于等于x的最大高度，与最后一级台阶高度做差即可。  </p><p>吐槽：数据中没有x大于最后一级台阶的情况……有人以为楼梯是相对高差……  </p><h3 id="C-彩虹岛电车-暴力"><a href="#C-彩虹岛电车-暴力" class="headerlink" title="C.彩虹岛电车 暴力"></a>C.彩虹岛电车 <code>暴力</code></h3><p>题意：给长度为n的数列a[]，问(a[l] + a[r])%5=0的二元组(l, r)对数，其中l$\leq$r。  </p><p>解析：O（$n^2$）扫一遍即可。  </p><h3 id="D-卡片游戏-贪心"><a href="#D-卡片游戏-贪心" class="headerlink" title="D.卡片游戏 贪心"></a>D.卡片游戏 <code>贪心</code></h3><p>题意：n张大写字母卡片选k张，使得$\sum<em>{i = 1}^{k} f</em>{i}$最大，其中$f_{i}$为k张卡中与第i张卡片字母相同的卡片数目。  </p><p>解析：统计每个字母的卡片数目，贪心从卡片数目最多的字母开始取k张即可。  </p><p>吐槽：萌新多是卡排序，不会sort、qsort，然而字母数少可以暴力排。  </p><h3 id="E-无尽拼图-坑人"><a href="#E-无尽拼图-坑人" class="headerlink" title="E.无尽拼图 坑人"></a>E.无尽拼图 <code>坑人</code></h3><p>题意：给一个部分缺失的整数矩阵，问是否存在一种填数方案使得该矩阵是矩阵$a_{ij} = i + j - 1（i， j \geq 1）$的子矩阵。  </p><p>解析：若全部为0则必然可以；否则找到第一个非零位置，即可填完所有数，并检查是否是$a_{ij} = i + j - 1（i， j \geq 1）$的子矩阵。坑点在于填完数的矩阵中是不能有0与负数的。  </p><p>吐槽：毒瘤出题人：“我觉得这道题是出的最好的。”  </p><h3 id="F-通往彩虹岛的石头门-几何"><a href="#F-通往彩虹岛的石头门-几何" class="headerlink" title="F.通往彩虹岛的石头门 几何"></a>F.通往彩虹岛的石头门 <code>几何</code></h3><p>题意：两个宽W高H的矩形重叠放置，其中一个绕形心顺时针旋转$\alpha$角，问旋转后两个矩形的重叠面积。  </p><p>解析：为了避免过多的分类，我们可以先去除一些情况。  </p><blockquote><ul><li>对于H&gt;W的情况，我们可以将两个矩形旋转90度，即交换W和H，不影响旋转后的相交面积，因此之后仅讨论H$\leq$W的情况。  </li><li>对于$\alpha &gt; 90^{\circ}$的情况，考虑轴对称，可以将$\alpha$转变为$180^{\circ} - \alpha$，故之后只需要考虑$\alpha \leq 90^{\circ}$的情况。  </li></ul></blockquote><p>为了方便叙述，我们令$\beta = arctan(\frac{H}{W})$，即$\beta$为矩形对角线与长边的夹角。  </p><p>在考虑完上述两点之后，仍然有两种情况需要讨论：  </p><blockquote><ul><li>$\alpha &gt; 2 \beta$，这种情况较为容易，此时相交部分为一平行四边形，面积即为底乘高，结果即为$\frac{H^{2}}{\sin\alpha}$。  </li><li>$\alpha \leq 2\beta$，即题目附图的情况，按下图设变量解二元一次方程组：  </li></ul></blockquote><script type="math/tex; mode=display">\left\{\begin{aligned}\frac{y}{\tan\alpha} + \frac{y}{\sin\alpha} + x & =  W \\\frac{x}{\tan\alpha} + \frac{x}{\sin\alpha} + y & =  H \end{aligned}\right.</script><p>解完方程用矩形减去三角形面积即可。  </p><p><img src="/.com//file/chd3zb.html" alt="Door"></p><h3 id="G-兔兔的纠纷-数学-题意杀"><a href="#G-兔兔的纠纷-数学-题意杀" class="headerlink" title="G.兔兔的纠纷 数学 题意杀"></a>G.兔兔的纠纷 <code>数学</code> <code>题意杀</code></h3><p>题意：记斐波那契数列为f[],其中f[0]=f<a href="/cources/file/rs.pdf">1</a>=1,对于i&gt;1有f[i]=f[i-1]+f[i-2]。已知在第k年，年龄为i的兔子数目为2f[k-i]，若两只兔子年龄和为k，会发生一次纠纷。T次询问，第k年兔子间共发生多少次纠纷（$T, k \leq 200000$）。  </p><p>解析：记$g[k] = \sum_{i = 0}^{k} f[i] \cdot f[k-i]$，则答案即为：  </p><script type="math/tex; mode=display">ans[k] =\left\{\begin{aligned}2g[k] & , & odd \\2g[k] - f[k/2] & , &even \end{aligned}\right.</script><p>问题转化为求$g[]$数组，  </p><script type="math/tex; mode=display">g[k] - g[k-1] = \sum_{i = 0}^{k-1} f[i] \cdot (f[k-i] - f[k-1-i]) + f[k]\\= \sum_{i = 0}^{k-2} f[i] \cdot f[k-2-i] + f[k]\\= g[k-2] + f[k]</script><p>即$g[k] = g[k-1] + g[k-2] + f[k]$，先预处理递推$f[]$再递推$g[]$即可，时间复杂度$O(T+k)$。  </p><p>吐槽：全没看到只生两年……斐波那契数列不叫兔子数列吗？  </p><h3 id="H-七彩原石-回文串-暴力"><a href="#H-七彩原石-回文串-暴力" class="headerlink" title="H.七彩原石 回文串 暴力"></a>H.七彩原石 <code>回文串</code> <code>暴力</code></h3><p>题意：求压缩串的最长回文子串。  </p><p>解析：类似于求普通串最长回文子串的枚举回文中心并向左右扩展的方法，在扩展的时候分三种情况：  </p><blockquote><ul><li>颜色相同，且长度相同，继续向两边扩展。  </li><li>颜色相同，但长度不同，两端取min切断，并停止扩展。  </li><li>颜色不相同，直接停止扩展。  </li></ul></blockquote><p>单组时间复杂度$O(n^2)$。  </p><p>吐槽：命题的时候想了要不要卡$O(n^3)$的做法，但是发现比$O(n^2)$还难写，大家也可以想想马拉车什么的怎么写。  </p><h3 id="I-机器人小队-二分"><a href="#I-机器人小队-二分" class="headerlink" title="I.机器人小队 二分"></a>I.机器人小队 <code>二分</code></h3><p>题意：将一个长度为n的序列划分成连续且非空的m段，设第$i$段的和为$S_i$，求使得max{$S_i$}最小的划分方案，多种情况时要求越靠前的段数字尽量少。  </p><p>解析：先求解最小的max{$S_i$}，可以假设max{$S_i$}$\leq x$，来判断这种情况是否成立：对于一个x，我们可以求出在每段和不超过x的情况下所需要的最少划分数k，如果k＞m，肯定不成立，反之成立。显然x与k满足单调性，故可以用二分求解最小的x。  </p><p>之后考虑方案输出，只需从后往前依次给每一段放总和小于等于max{$S_i$}的数即可，但需要注意的是每一段非空这一条件。  </p><p>吐槽：输出略鬼畜，场上似乎出现了PE判WA的情况，致歉。  </p><h3 id="J-藏宝图-BFS-RoyYuan"><a href="#J-藏宝图-BFS-RoyYuan" class="headerlink" title="J.藏宝图 BFS RoyYuan"></a>J.藏宝图 <code>BFS</code> <code>RoyYuan</code></h3><p>题意：给一个有障碍的$m \times n$迷宫，起点S，终点T，地图上障碍每间隔k秒会打开一次，问S能否到达T以及所需最短时间。  </p><p>解析：普通的迷宫题直接用二维状态(x, y)表示位置来BFS即可。本题不同的是，障碍每隔k秒会开一次，故需多标记一维时间状态。对于同一个点(x,y)来说，t秒和t+k秒表示的状态是相同的，所以新加的维度只需要k的大小就足够，转移的时候按时间的不同讨论能否经过障碍即可。当然也可以从分层图角度来理解。  </p><p>吐槽：不能因为RoyYuan超可爱就欺负他呀。  </p><h3 id="K-书人-LCA"><a href="#K-书人-LCA" class="headerlink" title="K.书人 LCA"></a>K.书人 <code>LCA</code></h3><p>题意：一个栈支持三种操作：  </p><blockquote><ul><li>1 push（x）   </li><li>2 pop（）   </li><li>3 退回第t次操作结束后的版本  </li></ul></blockquote><p>对于每个操作3回答本次操作最少可以看成是由多少次操作1/2组成的。  </p><p>解析：栈要可持久，建树即可：维护一个当前位置指针pos，push把pos移向儿子（没有这个儿子则需加叶子），pop把pos移向父亲。先做完所有操作把树建完，每个操作3询问的即为树上距离，故离线LCA即可。  </p><p>吐槽：因为是先想好做法再套题，所以可能会被什么简单做法艹掉，欢迎dalao讨论。  </p><h3 id="L-大魔王的魔咒-构造-猜结论"><a href="#L-大魔王的魔咒-构造-猜结论" class="headerlink" title="L.大魔王的魔咒 构造 猜结论"></a>L.大魔王的魔咒 <code>构造</code> <code>猜结论</code></h3><p>题意：给L个左括号与R个右括号，构造一个串使得合法括号子串最多，输出个数。  </p><p>解析：显然括号要成对，故取x = min（L,R）对括号即可，多余的没有用处。最优的构造方案为（）（）（）……即x对括号并排放，答案即为$\frac{x \cdot (x + 1)}{2}$。  </p><blockquote><p>证明：<br>1.合法括号子串的上界是$\frac{x \cdot (x + 1)}{2}$<br>    合法括号子串的长度必然是偶数，对于长度为2x的串，将其长度为偶数的子串一共有$x^2$个，可以将其分为三类：  </p><ul><li>左端点l为奇数，且右端点为2x，有$x$个。  </li><li>左端点l为奇数，且右端点不为2x，有$\frac{x \cdot (x-1)}{2}$个。  </li><li>左端点l为偶数，有$\frac{x \cdot (x-1)}{2}$个。<br>注意到对于一个子串[l, r]如果它是合法括号序列，则其最左端必然是“（”，最右端必然是“）”，故[l+1, r+1]必然不是合法括号序列。在上述的3类子串中，第2类与第3类可以建立一个[l, r] $\leftrightarrow $[l+1, r+1]的双射关系。也即是说，只要第2类中有一个子串是合法括号序列，对应的第3类中有一个子串必然不是合法括号序列，故这两类中的合法括号序列之和不会超过$\frac{x \cdot (x-1)}{2}$，因此所有合法括号序列总和不会超过$\frac{x \cdot (x+1)}{2}$<br>2.存在一种构造使得合法括号子串数目为$\frac{x \cdot (x+1)}{2}$。  </li></ul></blockquote><p>显然并排放（）（）（）（）……即是。  </p><p>证毕。  </p><p>吐槽：欢迎其他证明，可以思考对应的子序列的问题。  </p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 长安大学校赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长安大学第三届ACM程序设计竞赛通知  『重要』</title>
      <link href="/2016/11/16/Third/"/>
      <url>/2016/11/16/Third/</url>
      
        <content type="html"><![CDATA[<p>不知不觉已经开学近三个月了，<code>C++</code>你学会了多少呢？或许你学过其他编程语言（这简直不能更好了），想不想和同学同场竞技，敢不敢和西安市最优秀的大一萌新一较高下？是时候约一场比赛了！  </p><h2 id="赛事"><a href="#赛事" class="headerlink" title="赛事"></a>赛事</h2><p>长安大学第三届ACM程序设计竞赛  </p><h2 id="竞赛规则"><a href="#竞赛规则" class="headerlink" title="竞赛规则"></a>竞赛规则</h2><p>使用一台电脑编写代码（<code>C++</code>、<code>Java</code>等）解决给出的问题。<br>以解出的题目数量为排名标准，题目数量相同的以比赛用时为排名标准（用时越短排名越靠前）。<br>每到题目第一个解出的同学会得到一只一血气球哦～之后解出该题的同学会得到和此题相对应的颜色的气球。  </p><h2 id="题目范围"><a href="#题目范围" class="headerlink" title="题目范围"></a>题目范围</h2><p>题目数量为10~12道。<br>题目类型包含但不限于以下内容：签到题，暴力，贪心，简单的数学推导题目，递推和二分，考思维的题，考验代码能力的模拟题。  </p><h2 id="日程表"><a href="#日程表" class="headerlink" title="日程表"></a>日程表</h2><p>2016年12月4日在长安大学渭水校区举办.  </p><div class="table-container"><table><thead><tr><th>时间</th><th>事项</th><th>地点</th></tr></thead><tbody><tr><td>9:30-10:00</td><td>热身赛进场，比赛环境介绍</td><td>明远二区</td></tr><tr><td>10:00-11:00</td><td>热身赛</td><td>明远二区</td></tr><tr><td>12:00-16:00</td><td>正式赛</td><td>明远二区</td></tr><tr><td>19:00-20:30</td><td>颁奖及讲题</td><td>WX3304</td></tr></tbody></table></div><h2 id="参赛对象"><a href="#参赛对象" class="headerlink" title="参赛对象"></a>参赛对象</h2><ul><li>长安大学大一同学均可参加  </li><li>长安大学大二非集训队同学  </li><li>陕西省其他高校的同学   </li></ul><h2 id="报名方式"><a href="#报名方式" class="headerlink" title="报名方式"></a>报名方式</h2><p>报名时间截止到2016年11月30日，请尽早报名.  </p><p>陕西其他高校同学请各校领队统计报名信息（总人数和各位同学的ID，领队的联系方式）发送到chdacm@outlook.com或者<strong>联系王智敏同学</strong>『QQ:962557346』  </p><p>本校同学请下载附件中的报名表，发送到邮箱: 27995708@qq.com  </p><p>我们将会在12月1日回复收到的报名邮件，如果没有收到回复请联系房邓斐同学.  </p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>长安大学ACM协会大一新生群：218561319<br>长安大学ACM协会邮箱： chdacm@outlook.com<br>长安大学ACM协会官方主页：<a href="http://chdacm.cn">chdacm.cn</a>  </p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="http://chdacm.github.io/file/长安大学第三届新生赛报名表.xls">点击这里下载报名表</a>  </p><p><img src="http://p1.bpimg.com/1949/81b56e438fc6836e.png" alt="宣传单"></p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 长安大学校赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM-ICPC及算法示例说明</title>
      <link href="/2016/08/31/about_acm_icpc/"/>
      <url>/2016/08/31/about_acm_icpc/</url>
      
        <content type="html"><![CDATA[<h1 id="竞赛规则"><a href="#竞赛规则" class="headerlink" title="竞赛规则"></a>竞赛规则</h1><hr><p><strong>ACM-ICPC</strong>是团队形式的比赛，每队由至多<strong>3名队员</strong>组成。队员必须是来自<strong>本校研一及以下</strong>的学生，同时需要注意每位选手最多可以参加<strong>2次全球总决赛和5次区域赛</strong>，每个赛季最多参加<strong>2次区域赛</strong>。</p><p>比赛期间，每队使用<strong>1台电脑</strong>，需要在<strong>5个小时</strong>内使用<strong>C、C++或Java</strong>中的一种，编写程序解决<strong>7到13个问题</strong>，题目均为英文题面。近年来，随着选手水平的提高，区域赛题目数量有增多的趋势。</p><hr><h3 id="题目规格"><a href="#题目规格" class="headerlink" title="题目规格"></a>题目规格</h3><p>以一道例题来讲解常规的ACM赛题组成部分：</p><blockquote><p>A + B Problem   <strong>题目标题</strong><br>Time Limit: 2000/1000 MS (Java/Others) <strong>运行时间限制</strong><br>Memory Limit: 65536/32768 K (Java/Others) <strong>内存空间限制</strong><br>Problem Description <strong>问题描述</strong><br>Calculate A + B.<br>Input <strong>输入格式</strong><br>Each line will contain two integers A and B. Process to end of file.<br>Output <strong>输出格式</strong><br>For each case, output A + B in one line.<br>Sample Input <strong>测试样例</strong><br>1 1<br>Sample Output<br>2  </p></blockquote><p>需要注意的是：</p><ul><li>只有当你的程序能在<strong>规定的运行时间</strong>内，<strong>申请使用的内存空间不超过限制</strong>，并且按照<strong>正确的输入输出格式</strong>，<strong>正确通过所有的测试数据</strong>，你的程序才会被认为<strong>正确通过</strong>。</li><li>通常C/C++与Java会有不同的时间空间限制。<strong>在正规的比赛中，有时并不会给出明确的时间空间限制数值。</strong></li><li>其中样例仅仅是为了明确题意与格式给出的一个例子，并不是全部的测试数据，也即是说<strong>即便你的程序能够成功通过样例，也不一定能通过所有的测试数据。</strong></li></ul><p>选手在程序完成之后提交裁判运行，运行的结果会判定为正确或错误两种并及时通知参赛队。当你向裁判提交你的程序时，通常有以下几种返回结果：</p><hr><h3 id="程序正确-Yes-："><a href="#程序正确-Yes-：" class="headerlink" title="程序正确(Yes)："></a>程序正确(Yes)：</h3><ul><li>Accepted. —-通过！(AC)</li></ul><hr><h3 id="程序错误-No-："><a href="#程序错误-No-：" class="headerlink" title="程序错误(No)："></a>程序错误(No)：</h3><ul><li>Wrong Answer. —-答案错误。(WA)  </li><li>Runtime Error. —-程序运行出错，意外终止等。(RE)  </li><li>Time Limit Exceeded. —-超时。程序没在规定时间内得到答案。(TLE)  </li><li>Presentation Error. —-格式错。程序没按规定的格式输出答案。(PE)  </li><li>Memory Limit Exceeded. —-超内存。程序使用的内存空间超限。(MLE)  </li><li>Compile Error. —-编译错。程序编译不通过。(CE)  </li></ul><hr><h3 id="评判标准"><a href="#评判标准" class="headerlink" title="评判标准"></a>评判标准</h3><p>当裁判认定某只队伍在正确通过一题后，组织者将在其位置上升起一只代表该题颜色的气球。有些赛区会准备一些特殊的“<strong>FIRST PROBLEM SOLVED</strong>”(俗称<strong>FB</strong>,<strong>First Blood</strong>)气球，奖励给每道题目第一个通过它的队伍。</p><p>比赛的排名依据每个队伍通过的<strong>题目数量</strong>，对于通过题数相同的队伍，将比较他们的<strong>总用时</strong>。<br>每道试题的用时指的是从竞赛开始到试题解答被判定为正确为止所用的时间，但需要额外注意的是，其间每一次提交运行结果被判错误的话，将被增加20分钟的罚时。每队的总用时为该参赛队所有正确解答的试题用时之和，<strong>未正确解答的试题罚时不会被计入总用时</strong>。</p><blockquote><p>例如：A、B两队都正确完成两道题目，其中A队提交这两题的时间分别是比赛开始后 1:00 和 2:45 ，B队为 1:20 和 2:00 ，但B队有一题提交了2次。这样A队的总用时为 1:00 + 2:45 = 3:45 而B队为 1:20 + 2:00 + 0:20 (罚时) = 3:40 ，所以B队以总用时少而获胜。<br><strong>再次强调，未通过的题目不会被算入罚时</strong>。</p></blockquote><p>比赛的前四个小时，选手可以通过榜单看到实时排名。<strong>最后一小时封榜</strong>，无法看到排名变化，但现场选手仍可以通过气球数了解赛场上的大体情况，最终榜单在比赛结束后才会公布。</p><p>ACM比赛重点考察选手的算法和程序设计能力，因而不会涉及实际工程中常用的系统编程，多线程编程等内容。特别需要注意的是，选手可携带任何非电子类资料，包括书籍和打印出来的程序等。通常ACM选手会预先准备好某些可能会用到的代码打印下来带入赛场，俗称模板。</p><p>就获奖情况而言，一般的区域赛会分别按10%，20%，30%的比例颁发金，银，铜奖，即一般情况（120队伍）有12支队伍获金牌，24支队伍获银牌，36支队伍获铜牌，其余为优胜奖。同时对于所有达成“<strong>FIRST PROBLEM SOLVED</strong>”成就的队伍，会颁发特别的FB奖。为了鼓励女选手参赛，有的赛区特别设立了最佳女队奖，颁发给成绩最佳的女队(三名选手均为女性)。</p>]]></content>
      
      
      <categories>
          
          <category> FAQ </category>
          
          <category> 入门指南 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2016萌新看这里！！</title>
      <link href="/2016/08/30/welcome_fresher/"/>
      <url>/2016/08/30/welcome_fresher/</url>
      
        <content type="html"><![CDATA[<h1 id="A协纳新啦！啦！！啦！！！"><a href="#A协纳新啦！啦！！啦！！！" class="headerlink" title="A协纳新啦！啦！！啦！！！"></a>A协纳新啦！啦！！啦！！！</h1><p><strong>长安大学ACM-ICPC协会纳新啦！期待你的加入！！！</strong></p><p>新一届的纳新工作又开始啦，我们还准备了有趣的题目和小礼品哦！<br>不管你是哪个学院，不管你是哪个专业<br>喜欢算法，喜欢挑战的萌新们<br>还等什么，赶快加入我们吧！！</p><hr><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a><a href="http://chdacm.club/pages/faq/">FAQ</a></h2><p>$Q:$ 什么是 $ACM \; ICPC$ 吖？<br>$A:$ 这是国际大学生程序设计竞赛的简称啦~<br>也就是说，如果你水平足够的话是可以参加每年一次的世界总决赛的(orz…)。</p><hr><p>$Q:$ 那A协是干嘛的吖？<br>$A:$ 我们是一群喜欢算法的萌新。<br>啊，不对，泥萌才是萌新！我们只是算法爱好者~<br>那泥萌喜欢算法嘛&amp;_&amp;喜欢就加入我们吧！  </p><hr><p>$Q:$ 什么是C语言？什么是算法？什么是程序设计？<br>$A:$ 你需要看<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">这个</a>嘛，还有<a href="http://www.jianshu.com/p/7feeac080171">这个</a>。<br>或许看一道题目你能更清晰的了解ACM-ICPC，<a href="http://poj.org/problem?id=3372">点这里</a>。</p><hr><p>$Q:$ 比赛形式是什么样的吖？<br>$A:$ 正式比赛中，是最多三个人一支队伍，共同使用一台电脑，解决约十道题目。可以携带任何纸质资料，题目为英文描述。在提交某道题目的答案后几分钟内即可出现是否通过此题目的结果。</p><h2 id="关于培训"><a href="#关于培训" class="headerlink" title="关于培训"></a>关于培训</h2><p>在上学期，我们会有C语言培训课。所以，不必担心你不会C语言！<br>数学不好，也没有关系。我们会在上学期和下学期开展算法课。<br>只要你喜欢编程，热爱算法，我们都是欢迎的！  </p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/jj472354ccb05e4f29f287c144af2589d10455a37f.jpg" alt="yx"></p><h2 id="举办的活动"><a href="#举办的活动" class="headerlink" title="举办的活动"></a>举办的活动</h2><p>一般来说，每学期会有一次。<br>在上学期会有针对校内新生的迎新赛(会有奖状学分哦）。</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp1.jpg" alt="jz"></p><p>在下学期会有校赛（组队形式，会有奖状学分哦），而且会邀请其他学校的道友一起来玩！</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/IMG_20160521_170226.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/7202027.png" alt="img"></p><p>好吧，培训课勉强拿来凑数啦！ 哈哈   </p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/201907.png" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/2245.png" alt="img"></p><p>哦，我们上学期举办了陕西省省赛(会有奖状学分哦)呢，来了好多<strong>DALAO</strong>。</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/SSS1463977558597.jpg" alt="img"></p><h2 id="参加的活动"><a href="#参加的活动" class="headerlink" title="参加的活动"></a>参加的活动</h2><p>我们能参加的活动很多的吖！不仅仅是我们自己举办的活动！<br>我们参加过西电、西工大、陕师大的校赛、参加省赛、暑假还参加了一个CCCC的比赛、很久之前参加了一个三星举办的”发钱的比赛”(每个学校分别评奖，奖金颇多）。。。</p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp3.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/s7204105.png" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp2.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/tp4.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/IMG_20131019_121622.jpg" alt="img"></p><p><img src="http://7xi3e9.com1.z0.glb.clouddn.com/sk.jpg" alt="img"></p><p>啊，对了，出去比赛是不需要花钱的，今年我们获得了参加CCPC(中国大学生程序设计竞赛，与国际大学生程序设计竞赛ICPC类似）长春、合肥、杭州赛区的名额。<br>我们相信，有了你们的加入，以后CHD_ACMer必然能在ACM这个国际赛事中大放光彩！ </p><h2 id="纳新对象"><a href="#纳新对象" class="headerlink" title="纳新对象"></a>纳新对象</h2><p>主要针对大一新生，就是那种”我爱学习，无法自拔”的新生哟！<br>在百团大战当天找到我们的位置就OK啦～<br>对于大二三的喜欢算法、希望代表学校参加各类算法比赛的请加入萌新群向群主咨询<br>(如果是什么都不会的请参考上一行)。  </p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>QQ:</p><ul><li><p>长大A协正式群: <strong><a href="http://jq.qq.com/?_wv=1027&amp;k=2KogR3q">88837395点击加入</a></strong></p></li><li><p>长大A协萌新群: <strong><a href="http://jq.qq.com/?_wv=1027&amp;k=2GOAThh">218561319点击加入</a></strong></p></li></ul><p>～正式群禁水哟～</p><hr><p>我们的博客以后就搬到这里啦！<br>通知也在本网站发布。<br>我们的主页是: <a href="http://chdacm.cn/">chdacm.cn</a></p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 迎新 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2016/08/30/learn_from_club/"/>
      <url>/2016/08/30/learn_from_club/</url>
      
        <content type="html"><![CDATA[<h4 id="由于审核未通过，此页内容删除"><a href="#由于审核未通过，此页内容删除" class="headerlink" title="由于审核未通过，此页内容删除"></a>由于审核未通过，此页内容删除</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ACM-ICPC集训队纳新说明</title>
      <link href="/2016/07/10/acmer_join_us/"/>
      <url>/2016/07/10/acmer_join_us/</url>
      
        <content type="html"><![CDATA[<p>长安大学ACM-ICPC集训队每年两次纳新，分别在每学期开学时。秋季学期主要针对大二的同学，春季学期主要针对大一的同学。除了条件一外，还需要分别满足条件二、三才可能会被接纳。  </p><h2 id="加入条件一"><a href="#加入条件一" class="headerlink" title="加入条件一"></a>加入条件一</h2><ul><li>人品要好，不弄虚作假，尊重老师和队友，和其他队员能融洽相处  </li><li>愿意无条件服从集训队的训练安排、组队安排、参赛安排以及其他统一的安排  </li><li>有毅力，愿意花时间进行相关的训练，而不是患得患失  </li></ul><h2 id="加入条件二（对大一）"><a href="#加入条件二（对大一）" class="headerlink" title="加入条件二（对大一）"></a>加入条件二（对大一）</h2><ul><li>在各类<code>OJ</code>做题超过 <code>130</code> 题的大一同学，妹纸的题量略少一点也无妨</li><li>在<code>cf</code>至少有五次比赛记录，且至少连续三场 rating 大于1450</li><li>在新生赛中成绩优异者、日常训练完成度高者</li></ul><h2 id="加入条件三（对大二）"><a href="#加入条件三（对大二）" class="headerlink" title="加入条件三（对大二）"></a>加入条件三（对大二）</h2><ul><li>参考条件二</li><li>提供你的博客地址、OJ 昵称等</li><li>请自行对比集训队15级队员</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>或许你还不满足上面的条件，但是十分喜欢算法，愿意花更多的时间，我们也会酌情考虑的。</p><h2 id="加入方式"><a href="#加入方式" class="headerlink" title="加入方式"></a>加入方式</h2><p>请联系clw同学（QQ:1141166429)，之后我们安排考核，通过后即可加入集训队！<br>以上，至2017年7月份失效！  </p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>请不要止步于此！！！</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 迎新 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2016ACM-ICPC陕西省省赛题解</title>
      <link href="/2016/05/26/shengsai/"/>
      <url>/2016/05/26/shengsai/</url>
      
        <content type="html"><![CDATA[<p>省赛顺利闭幕，榜单和题目<a href="http://chdacm.github.io/2016/">在这里</a>，简要发一下题解吧。</p><p>前四题出题人只给了简要题解╮(╯_╰)╭</p><hr><p>有同学要的A题的标程：</p><ul><li><a href="/2016/src/A.std.cpp">A</a></li></ul><hr><h1 id="A-Rui-and-her-cylinders"><a href="#A-Rui-and-her-cylinders" class="headerlink" title="A.Rui and her cylinders"></a>A.Rui and her cylinders</h1><p>可以使用各种办法来做这道题，包括模拟退火，三分等。需要注意到两个在圆柱侧面的点的最短路可能经过底面。</p><h1 id="B-Rui-and-her-functions"><a href="#B-Rui-and-her-functions" class="headerlink" title="B.Rui and her functions"></a>B.Rui and her functions</h1><p>主要x的单调性，可以问题进行整体的分治。</p><h1 id="C-Rui-and-her-sequences"><a href="#C-Rui-and-her-sequences" class="headerlink" title="C.Rui and her sequences"></a>C.Rui and her sequences</h1><p>注意到操作1是没有意义的，因为操作1结束后，局部来说需要用最多次数的操作2才能实现目标，这一定是比只考虑操作2要更劣的。</p><blockquote><p>修改题面之后删除条件1</p></blockquote><h1 id="D-Rui-and-her-triangles"><a href="#D-Rui-and-her-triangles" class="headerlink" title="D.Rui and her triangles"></a>D.Rui and her triangles</h1><p>对于任意一对点a,b，假设它们的木棍长度是x,y(x&gt;y)，如果第三边的长度在(x-y,x+y)内就可以组成三角形。于是用cnt[i][j]表示子树i中有多少对木棍满足“与长度为j的木棍可以组成三角形”。那么对所有的点对a,b，设a和b的lca是c，给cnt[c][]的(x-y,x+y)一段加1。然后按各个子树对cnt求和。那么一个子树i中的三角形总数就等于sigma cnt[i][j]，对子树i中所有的木棍长度j。再减去包含重复木棍的三角形，这个也可以用类似的方法算出。</p><h1 id="E-HE"><a href="#E-HE" class="headerlink" title="E.HE"></a>E.HE</h1><p>题目本身没啥好说的了，关于几个坑点其实已经在题目原本的描述中和样例数据中给的非常详细了。</p><p>赛中评测出来的大部分情况是<strong>行末空格</strong>和<strong>多余的空行（包括最末尾的空行）</strong>没有处理。</p><p>这里把数据都贴出来，大家自己回去试试就明白了。</p><ul><li>Input</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1341242</span> <span class="comment">/* --- */</span><span class="number">23424242</span></span><br><span class="line"><span class="comment">/*--------------------------------*- C++ -*----------------------------------*\</span></span><br><span class="line"><span class="comment">| =========                 |                                                 |</span></span><br><span class="line"><span class="comment">| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |</span></span><br><span class="line"><span class="comment">|  \\    /   O peration     | Version:  3.0.1                                 |</span></span><br><span class="line"><span class="comment">|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |</span></span><br><span class="line"><span class="comment">|    \\/     M anipulation  |                                                 |</span></span><br><span class="line"><span class="comment">\*---------------------------------------------------------------------------*/</span></span><br><span class="line">FoamFile</span><br><span class="line">&#123;</span><br><span class="line">    version     <span class="number">2.0</span>;</span><br><span class="line">    format      ascii;</span><br><span class="line">    <span class="keyword">class</span>       <span class="title class_">dictionary</span>;</span><br><span class="line">    note        <span class="string">&quot;mesh decomposition control dictionary&quot;</span>;</span><br><span class="line">    object      decomposeParDict;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span></span><br><span class="line">numberOfSubdomains  <span class="number">2</span>;</span><br><span class="line"><span class="comment">//- Keep owner and neighbour on same processor for faces in zones:</span></span><br><span class="line"><span class="comment">// preserveFaceZones (heater solid1 solid3);</span></span><br><span class="line"><span class="comment">//- Keep owner and neighbour on same processor for faces in patches:</span></span><br><span class="line"><span class="comment">//  (makes sense only for cyclic patches)</span></span><br><span class="line"><span class="comment">//preservePatches (cyclic_half0 cyclic_half1);</span></span><br><span class="line"><span class="comment">//- Keep all of faceSet on a single processor. This puts all cells</span></span><br><span class="line"><span class="comment">//  connected with a point, edge or face on the same processor.</span></span><br><span class="line"><span class="comment">//  (just having face connected cells might not guarantee a balanced</span></span><br><span class="line"><span class="comment">//  decomposition)</span></span><br><span class="line"><span class="comment">// The processor can be -1 (the decompositionMethod chooses the processor</span></span><br><span class="line"><span class="comment">// for a good load balance) or explicitly provided (upsets balance).</span></span><br><span class="line"><span class="comment">//singleProcessorFaceSets ((f0 -1));</span></span><br><span class="line"><span class="comment">//- Keep owner and neighbour of baffles on same processor (i.e. keep it</span></span><br><span class="line"><span class="comment">//  detectable as a baffle). Baffles are two boundary face sharing the</span></span><br><span class="line"><span class="comment">//  same points.</span></span><br><span class="line"><span class="comment">//preserveBaffles true;</span></span><br><span class="line"><span class="comment">//- Use the volScalarField named here as a weight for each cell in the</span></span><br><span class="line"><span class="comment">//  decomposition.  For example, use a particle population field to decompose</span></span><br><span class="line"><span class="comment">//  for a balanced number of particles in a lagrangian simulation.</span></span><br><span class="line"><span class="comment">// weightField dsmcRhoNMean;</span></span><br><span class="line">method          scotch;</span><br><span class="line"><span class="comment">//method          hierarchical;</span></span><br><span class="line"><span class="comment">// method          simple;</span></span><br><span class="line"><span class="comment">// method          metis;</span></span><br><span class="line"><span class="comment">// method          manual;</span></span><br><span class="line"><span class="comment">// method          multiLevel;</span></span><br><span class="line"><span class="comment">// method          structured;  // does 2D decomposition of structured mesh</span></span><br><span class="line">multiLevelCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Decomposition methods to apply in turn. This is like hierarchical but</span></span><br><span class="line">    <span class="comment">// fully general - every method can be used at every level.</span></span><br><span class="line">    level0</span><br><span class="line">    &#123;</span><br><span class="line">        numberOfSubdomains  <span class="number">64</span>;</span><br><span class="line">        <span class="comment">//method simple;</span></span><br><span class="line">        <span class="comment">//simpleCoeffs</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    n           (2 1 1);</span></span><br><span class="line">        <span class="comment">//    delta       0.001;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        method scotch;</span><br><span class="line">    &#125;</span><br><span class="line">    level1</span><br><span class="line">    &#123;</span><br><span class="line">        numberOfSubdomains  <span class="number">4</span>;</span><br><span class="line">        method scotch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Desired output</span></span><br><span class="line">simpleCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">n</span>           (<span class="number">2</span> <span class="number">1</span> <span class="number">1</span>);</span><br><span class="line">    delta       <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">hierarchicalCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">n</span>           (<span class="number">1</span> <span class="number">2</span> <span class="number">1</span>);</span><br><span class="line">    delta       <span class="number">0.001</span>;</span><br><span class="line">    order       xyz;</span><br><span class="line">&#125;</span><br><span class="line">metisCoeffs</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    processorWeights</span></span><br><span class="line"><span class="comment">    (</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line">scotchCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//processorWeights</span></span><br><span class="line">    <span class="comment">//(</span></span><br><span class="line">    <span class="comment">//    1</span></span><br><span class="line">    <span class="comment">//    1</span></span><br><span class="line">    <span class="comment">//    1</span></span><br><span class="line">    <span class="comment">//    1</span></span><br><span class="line">    <span class="comment">//);</span></span><br><span class="line">    <span class="comment">//writeGraph  true;</span></span><br><span class="line">    <span class="comment">//strategy &quot;b&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line">manualCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    dataFile    <span class="string">&quot;decompositionData&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">structuredCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Patches to do 2D decomposition on. Structured mesh only; cells have</span></span><br><span class="line">    <span class="comment">// to be in &#x27;columns&#x27; on top of patches.</span></span><br><span class="line">    <span class="built_in">patches</span>     (movingWall);</span><br><span class="line">    <span class="comment">// Method to use on the 2D subset</span></span><br><span class="line">    method      scotch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//// Is the case distributed? Note: command-line argument -roots takes</span></span><br><span class="line"><span class="comment">//// precedence</span></span><br><span class="line"><span class="comment">//distributed     yes;</span></span><br><span class="line"><span class="comment">//// Per slave (so nProcs-1 entries) the directory above the case.</span></span><br><span class="line"><span class="comment">//roots</span></span><br><span class="line"><span class="comment">//(</span></span><br><span class="line"><span class="comment">//    &quot;/tmp&quot;</span></span><br><span class="line"><span class="comment">//    &quot;/tmp&quot;</span></span><br><span class="line"><span class="comment">//);</span></span><br><span class="line"><span class="comment">// ************************************************************************* //</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">/*/</span></span><br><span class="line"><span class="comment">       jgjhhj</span></span><br><span class="line"><span class="comment">       /*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ***********************************************</span></span><br><span class="line"><span class="comment">MYID    : Chen Fan</span></span><br><span class="line"><span class="comment">LANG    : G++</span></span><br><span class="line"><span class="comment">PROG    : Bitset</span></span><br><span class="line"><span class="comment">************************************************ */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;1000&gt; a;</span><br><span class="line">    a[<span class="number">100</span>]=<span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">count</span>() &lt;&lt; endl;  <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">100</span>) &lt;&lt; endl;    <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">any</span>() &lt;&lt; endl;    <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">none</span>() &lt;&lt; endl;   <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">all</span>() &lt;&lt; endl;    <span class="comment">//</span></span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">2</span>);   <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;   <span class="comment">//</span></span><br><span class="line">    a.<span class="built_in">reset</span>();  <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">none</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">flip</span>();   <span class="comment">//</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">all</span>() &lt;&lt; endl;<span class="comment">/* --- */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* ----</span></span><br><span class="line"><span class="comment">---- */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);     <span class="comment">// test</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* -- */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Output</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1341242</span> <span class="number">23424242</span></span><br><span class="line">FoamFile</span><br><span class="line">&#123;</span><br><span class="line">    version     <span class="number">2.0</span>;</span><br><span class="line">    format      ascii;</span><br><span class="line">    <span class="keyword">class</span>       <span class="title class_">dictionary</span>;</span><br><span class="line">    note        <span class="string">&quot;mesh decomposition control dictionary&quot;</span>;</span><br><span class="line">    object      decomposeParDict;</span><br><span class="line">&#125;</span><br><span class="line">numberOfSubdomains  <span class="number">2</span>;</span><br><span class="line">method          scotch;</span><br><span class="line">multiLevelCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    level0</span><br><span class="line">    &#123;</span><br><span class="line">        numberOfSubdomains  <span class="number">64</span>;</span><br><span class="line">        method scotch;</span><br><span class="line">    &#125;</span><br><span class="line">    level1</span><br><span class="line">    &#123;</span><br><span class="line">        numberOfSubdomains  <span class="number">4</span>;</span><br><span class="line">        method scotch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">simpleCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">n</span>           (<span class="number">2</span> <span class="number">1</span> <span class="number">1</span>);</span><br><span class="line">    delta       <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">hierarchicalCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">n</span>           (<span class="number">1</span> <span class="number">2</span> <span class="number">1</span>);</span><br><span class="line">    delta       <span class="number">0.001</span>;</span><br><span class="line">    order       xyz;</span><br><span class="line">&#125;</span><br><span class="line">metisCoeffs</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">scotchCoeffs</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">manualCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    dataFile    <span class="string">&quot;decompositionData&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">structuredCoeffs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">patches</span>     (movingWall);</span><br><span class="line">    method      scotch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bitset&lt;1000&gt; a;</span><br><span class="line">    a[<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">any</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">none</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">none</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">flip</span>();</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helloworld.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Go"><a href="#F-Go" class="headerlink" title="F.Go"></a>F.Go</h1><p>签到题，前面2页都是废话，只要对比每次19*19方格中0和1的个数即可。</p><h1 id="G-CountingStar"><a href="#G-CountingStar" class="headerlink" title="G.CountingStar"></a>G.CountingStar</h1><p>大意是给出一个(n+1)<em>(n+1)的数字方阵，然后针对多个顶点，询问<strong>该顶点</strong>与<strong>(0,0)点</strong>以及<em>*该顶点在x轴上的投影点</em></em>所围成的三角形内区域的数字和。</p><p>事实上这题的出题思路来自于<a href="http://jcf94.com/2014/09/23/2014-09-23-The-2014-ACMICPC-Asia-Regional-Beijing-Online/">2014年北京regional网赛的一题</a></p><p>正解的思路是：</p><p>二维转一维：将最大1000*1000个点按照斜率排序，对于每次的询问也是按照斜率排序。</p><p>之后想象有一根轴，从x轴的0°角开始逆时针扫整个平面，将扫到的点按照x坐标加入树状数组。如果扫到与一条询问线重合时，则对该次询问求sum(x)。这样就能避免了重复操作。把结果按照原始顺序重新输出即可。</p><p>不太理解的同学可以画图看一下。</p><p>赛中事实上这题的数据较弱，有的同学维护前缀和暴力搞一搞也都过了。</p><h1 id="H-LaserCannon"><a href="#H-LaserCannon" class="headerlink" title="H.LaserCannon"></a>H.LaserCannon</h1><p>这题是个非常简单的DP，赛中没有人出真是让我好伤心……</p><p>题目大意是：平面上有若干个带权点，用倾斜角为$\alpha$的直线将其分为若干部分，每部分可以得到一 个分值，求一个最大得分。</p><p>对于$\alpha$为0或90度的情况进行特判，当斜率为任意值时，可以计算出过每个点的斜角为$\alpha$的直线与y轴的交点，并按照这个交点的y坐标d进行排序。其计算公式为：$d = y – k * x$。</p><p>这样就把二维的面问题简化成一维了有木有！！！！！！！</p><p>然后很容易就能写出DP方程：</p><script type="math/tex; mode=display">f(i)=max\{f(j)+\sum_{k=j+1}^{i}value[k]*\sum_{k=j+1}^{i}mul[k]/(i-j)\}</script><p>本来这里还准备设置一个坑点的，即：<strong>同一条直线上的点是不能被分成2个部分分开打掉的</strong>，而数据完全有可能出成分开更优的情况，若是不考虑这点的话也会WA。只是最后我出数据的时候没有把这个部分加上去。</p><blockquote><p>然而比赛时没有人做╮(╯_╰)╭</p></blockquote><h1 id="I-MarsCity"><a href="#I-MarsCity" class="headerlink" title="I.MarsCity"></a>I.MarsCity</h1><p>本题是一个裸的最小树形图。</p><p>首先构建图，即生成从高建筑到不高于该建筑的其他建筑的有向边。高度最高的建筑就是树形图的中心点，若存在多个相同高度的最高建筑，则需要另外设置一个虚拟的根，从虚拟根向所有最高建筑连有向边，边长设置一个特别大的值即可，最后结束时减掉。</p><p>出于省赛难度考虑，本题数据也非常弱。有同学可能担心朱刘算法复杂度不够，事实上标程就是个裸的朱刘算法╮(╯_╰)╭</p><h1 id="J-MagicNum"><a href="#J-MagicNum" class="headerlink" title="J.MagicNum"></a>J.MagicNum</h1><p>数位DP。</p><p>其实也没啥可说的，这里给出标程中用的状态吧：</p><p>dp[i][j][k][p][l][x]</p><p>i：第i位；</p><p>j：是否比原数字大，0表示小，1表示等，2表示大；</p><p>k：mod7的余数；</p><p>p：上一位是否是8；</p><p>l：这一位是不是0；</p><p>x：是否包含2、3、5</p><h1 id="K-Skill"><a href="#K-Skill" class="headerlink" title="K.Skill"></a>K.Skill</h1><p>艾教的题解：</p><blockquote><p>非常简单的模拟题，涉及一点点数学知识。</p><p>首先考虑最高位是不是1，如果最高位是1，那么满足题目要求的情况有:</p><p>C(K-1,P-1)*(N-1)^(N-K)种。</p><p>如果这个数字&gt;=X,说明答案的首位是1，否则答案的首位不是1，X减去这个数字，再来考虑2即可。</p><p>时间复杂度O(K)，空间复杂度O(1)。</p></blockquote><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>在知乎上发现一个问题：</p><ul><li><a href="https://www.zhihu.com/question/46669424">如何评价 2016 年陕西省第四届程序设计竞赛？</a></li></ul><p>看到大家的评价还都不错我们筹办方也就放心啦~</p><p>前四题的详细题解我们会再找出题人要一下，是在有疑问的可以找艾教讨论，最后2题也是艾教的题。</p><p>然后中间的E到I是本人出的题，若有疑问可以再与我交流。</p><p>—-<a href="http://jcf94.com/">Jcf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016年安排的相关通知</title>
      <link href="/2016/03/05/xiangguantongzhi/"/>
      <url>/2016/03/05/xiangguantongzhi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新学期的算法课程"><a href="#1-新学期的算法课程" class="headerlink" title="1. 新学期的算法课程"></a>1. 新学期的算法课程</h2><p>本学期的算法课程将于下周（第二周）重新起航，欢迎所有喜欢算法的同学前来听课。<br>时间仍然为每周五晚7:00，没有特殊通知的情况下，地点均在修远3304教室  </p><p>具体内容以及相关学习资料和挂题情况，请见：<a href="http://www.cnblogs.com/chdacm/p/5244568.html">算法课安排</a></p><h2 id="2-省赛报名"><a href="#2-省赛报名" class="headerlink" title="2. 省赛报名"></a>2. 省赛报名</h2><blockquote><p>外校学生均由外校教练办理报名手续，故本报名通知针对本校学生</p></blockquote><p>2016年第四届陕西省ACM-ICPC程序设计竞赛将于5月22日在本校举行， 详情请关注 <a href="http://chdacm.github.io/2016/">省赛官网</a></p><p>长安大学的同学们~<br>第四届陕西省ACM/ICPC程序设计竞赛 将于今年5月22日在长安大学渭水校区举行，<br>期间将会有来自陕西省各个大学的ACMER队伍(预计100个队伍)前来参赛<br>比赛将会有金牌、银牌、铜牌，并且会有学分，你想拿学分么，你想体验大学竞赛激情四射的角逐么，你想跟他人比拼智力能力努力程度么？！快来组队(三人一队)报名吧！</p><p>对于本校的学生：（只需填写报名表，不收取报名费）<br>报名信息发送至chdacmdaydayup@163.com (报名单详见群文件”报名单”) </p><h2 id="3-更多帮助"><a href="#3-更多帮助" class="headerlink" title="3. 更多帮助"></a>3. 更多帮助</h2><p>有任何问题，请加入长安大学ACM协会官方群「88837395」进行询问。</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2015暑假集训通知！！！！【重要】</title>
      <link href="/2015/07/01/jixuntongzhi/"/>
      <url>/2015/07/01/jixuntongzhi/</url>
      
        <content type="html"><![CDATA[<h1 id="2015年ACM协会暑假集训火热展开"><a href="#2015年ACM协会暑假集训火热展开" class="headerlink" title="2015年ACM协会暑假集训火热展开"></a>2015年ACM协会暑假集训火热展开</h1><hr><p>上次校赛相信很多同学已经了解到ACM比赛的魅力所在了，但是因为水平不够而遗憾收场。</p><p>那么这次暑假对于感兴趣的同学来说就将是一个<strong>绝佳的机会</strong>！</p><p>当初觉得难而不敢参加？如果永远不敢尝试，那么就再也没有机会了。</p><p>再次重申一下， <strong>ACM不涉及软件开发</strong> ，只是 <strong>最基本的C/C++/JAVA的数据处理和输入输出</strong> ，主要考察的还是 <strong>数学与逻辑思维能力</strong> ，再加上<strong>算法训练</strong>。因此无论你是哪个学院的，任何人都能够轻松上手。</p><p>当然相比起来我们更喜欢数学好的咯。。。</p><blockquote><p>不试怎么知道不行？</p></blockquote><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>A协竞赛部成员会参与<strong>陕西省多校联合集训</strong>，并重点进行自我提升。</p><p>对于其他同学报名的，将<strong>由竞赛部队员布置学习任务</strong>，并会有安排一定的算法讲解。</p><p>今年下半年会有第二届的新生杯比赛，到时候原则上<strong>老竞赛部成员是不参加的</strong>，那就是你们大显身手的时候了， <strong>被15级新生打败</strong> 的感觉可不太好吧？</p><p>鼓励<strong>有志于加入Acmer行列</strong>的同学<strong>踊跃加入竞赛部</strong>！！！！！！</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>从<strong>本学期结束起至下学期开学前（预计7月18日至8月30日？）</strong>，竞赛部每人放假两周，由每位队员自行安排放假时间。</p><p>非竞赛部成员，建议参与集训时间<strong>不低于3周</strong>，放假时间自选。</p><h2 id="地点"><a href="#地点" class="headerlink" title="地点"></a>地点</h2><p>渭水修远二区机房。</p><p>因为学校这边暑假不封校，水电全有，而且机房有空调。</p><h2 id="报名方式"><a href="#报名方式" class="headerlink" title="报名方式"></a>报名方式</h2><p>在本页下方留言，或<del>发邮件至jcf94@foxmail.com</del>加入ACM协会群（<a href="http://jq.qq.com/?_wv=1027&amp;k=Y6hQgX">88837395</a>）找管理员报名，收到回复即报名成功。</p><p>报名内容是：姓名、年级、学院、专业、联系方式</p><p>最终训练名单将公布在本站中（这段时间我应该会每天维护，尽量让它不崩溃，哭。。。—Jcf）</p><h1 id="初步的集训课程安排"><a href="#初步的集训课程安排" class="headerlink" title="初步的集训课程安排"></a>初步的集训课程安排</h1><hr><p>该课程面向暑假ACM培训的非竞赛部成员，由ACM协会竞赛部队员为大家进行授课。</p><p>（培训提供PPT并在本校OJ上给出相应的训练题目）</p><p>具体安排如下：</p><div class="table-container"><table><thead><tr><th>时间</th><th>主讲人</th><th>授课内容</th></tr></thead><tbody><tr><td>2015年7月19日</td><td>梁倍铖</td><td>ACM基本输入输出，OJ和VJ的介绍和使用，对ACM简单算法的概括介绍</td></tr><tr><td>2015年7月21日</td><td>何贤拓</td><td>ACM基础数学题，包括简单素数筛选，线性筛求因子个数，因子和等ACM数论初步</td></tr><tr><td>2015年7月23日</td><td>段云鹏</td><td>ACM搜索基础，主要包括dfs,bfs，双向bfs等，介绍一些剪枝的技巧</td></tr><tr><td>2015年7月25日</td><td>陈利文</td><td>ACM简单模拟题，简单字符串模拟题，简单贪心</td></tr><tr><td>2015年7月27日</td><td>商少奎</td><td>基础数据结构（一），树，二叉树，链表，线性表</td></tr><tr><td>2015年7月29日</td><td>郭俊修</td><td>基础数据结构（二），并查集</td></tr><tr><td>2015年7月31日</td><td>江佳宇</td><td>基础数据结构（三），树状数组</td></tr><tr><td>2015年8月2日</td><td>吴廷炜</td><td>动态规划初步（一），数塔问题，最长有序子序列，免费馅饼问题等</td></tr><tr><td>2015年8月3日</td><td>吴廷炜</td><td>动态规划初步（二），状态转移方程式，稍微难一点的DP问题</td></tr><tr><td>2015年8月5日</td><td>苏康</td><td>简单计算几何</td></tr><tr><td>2015年8月7日</td><td>陈闻恪</td><td>组合博弈入门</td></tr><tr><td>2015年8月8日</td><td>余冠一</td><td>图论初步（一）</td></tr><tr><td>2015年8月9日</td><td>余冠一</td><td>图论初步（二）</td></tr></tbody></table></div><p>以上为初步方案，具体将根据实际情况进行调整</p><p>以上讲课安排之外，请各位参与集训的同学进行相应的作业练习，习题均会挂在我校的VJ上，遇到问题可以询问主讲人</p><h1 id="报名名单"><a href="#报名名单" class="headerlink" title="报名名单"></a>报名名单</h1><hr><p>截止7月18日，报名名单：</p><div class="table-container"><table><thead><tr><th>序号</th><th>姓名</th><th>年级</th><th>学院</th><th>专业</th></tr></thead><tbody><tr><td>1</td><td>鲍咸良</td><td>2014</td><td>信息学院</td><td>计算机科学与技术</td></tr><tr><td>2</td><td>唐伟</td><td>2014</td><td>信息学院</td><td>计算机科学与技术</td></tr><tr><td>3</td><td>林腾飞</td><td>2014</td><td>信息学院</td><td>通信工程</td></tr><tr><td>4</td><td>王康龙</td><td>2013</td><td>公路学院</td><td>道路桥梁与渡河工程国际班</td></tr><tr><td>5</td><td>唐川</td><td>2014</td><td>信息学院</td><td>网络工程</td></tr><tr><td>6</td><td>皮攀峰</td><td>2014</td><td>信息学院</td><td>物联网</td></tr><tr><td>7</td><td>彭伟</td><td>2014</td><td>信息学院</td><td>计算机科学与技术</td></tr><tr><td>8</td><td>袁颖</td><td>2014</td><td>信息学院</td><td>通信工程</td></tr><tr><td>9</td><td>张帅</td><td>2014</td><td>信息学院</td><td>通信工程</td></tr><tr><td>10</td><td>杜军舜</td><td>2013</td><td>信息学院</td><td>测控技术与仪器</td></tr><tr><td>11</td><td>郝义</td><td>2014</td><td>电控学院</td><td>电气工程及其自动化</td></tr><tr><td>12</td><td>薛慧敏</td><td>2014</td><td>信息学院</td><td>计算机科学与技术</td></tr><tr><td>13</td><td>王崇晓</td><td>2013</td><td>信息学院</td><td>计算机科学与技术</td></tr><tr><td>14</td><td>强亚静</td><td>2013</td><td>信息学院</td><td>测控技术与仪器</td></tr><tr><td>15</td><td>张莎婷</td><td>2013</td><td>信息学院</td><td>计算机科学与技术</td></tr><tr><td>16</td><td>龚志龙</td><td>2013</td><td>信息学院</td><td>通信工程</td></tr><tr><td>17</td><td>景莹</td><td>2013</td><td>信息学院</td><td>电子信息工程</td></tr><tr><td>18</td><td>李帅</td><td>2014</td><td>信息学院</td><td>测控技术与仪器</td></tr><tr><td>19</td><td>杨鑫</td><td>2014</td><td>信息学院</td><td>网络工程</td></tr><tr><td>20</td><td>代静</td><td>2013</td><td>信息学院</td><td>测控技术与仪器</td></tr><tr><td>21</td><td>姚梦婷</td><td>2014</td><td>信息学院</td><td>物联网</td></tr><tr><td>22</td><td>刘玉骄</td><td>2104</td><td>信息学院</td><td>软件工程</td></tr><tr><td>23</td><td>田苗苗</td><td>2014</td><td>信息学院</td><td>物联网</td></tr><tr><td>24</td><td>邓晓栋</td><td>2014</td><td>信息学院</td><td>计算机科学与技术</td></tr></tbody></table></div><h1 id="最新通知"><a href="#最新通知" class="headerlink" title="最新通知"></a>最新通知</h1><p>从7月19日开始正式上课。第一天上课开始时间8点30。</p><p>地点WM2202。</p><p>机房开门时间</p><ol><li>8:00-8:30</li><li>11:30-12:00</li><li>13:30-14:30</li><li>17:30-20:00</li></ol><p>其他时间机房大门关闭。请大家注意时间</p><p>后续通知请大家注意关注ACM协会群，有问题请直接在A协群中提问</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
          <category> 暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OJ三次启用说明</title>
      <link href="/2015/06/30/sancishuoming/"/>
      <url>/2015/06/30/sancishuoming/</url>
      
        <content type="html"><![CDATA[<p>暑假集训马上就要开始，刚好我这段时间也没课了，于是把服务器重新弄了弄。</p><p>目前还是寄放在2510科协办公室，暑假应该是有电有网的，那就可以用来应付一般的新人级训练了。</p><p>原来的首页太繁琐，用hexo重新改了下，重新发布。</p><p>然后整理了一下算法课的内容，详细的只有以后再补了，可能这会也没什么空</p><p>OJ本体部分用的还是老的hustoj，坐等Lw毕业设计给长大写个我们自己的OJ核心吧~！</p><p>然后外网部分仍然是花生壳映射。</p><p>现在的结构是这样的，主机是Ubuntu14.04server，搭载网站；里面开了个Virtualbox虚拟机，虚拟机里面是Winserver 2008，然后虚拟机里面开花生壳内网映射。。。想想也是够了，不过幸好目前访问速度还是挺快的。</p><p>唯一的问题是经常不明原因崩溃。。。不知道问题出在哪，只有慢慢检修了。</p><hr><p>-Jcf</p>]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Manacher&#39;s algorithm</title>
      <link href="/2014/06/30/manacher-algorithm/"/>
      <url>/2014/06/30/manacher-algorithm/</url>
      
        <content type="html"><![CDATA[<p>Manacher’s algorithm 以$O(n)$的线性时间求一个字符串的最大回文子串。  </p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a>1. 预处理</h3><p>一个最棘手的问题是需要考虑最长回文子串的长度为奇数和偶数的情况。<br>我们通过在任意两个字符之间填充 <code>#</code> 的方法， 将原字符串 $S$ 转化为辅助字符串 $T$，具体例子如下：</p><blockquote><p>S = a b a a b a<br>T = # a # b # a # a # b # a #  </p></blockquote><p>转化后便可不必再考虑奇偶问题，同时辅助字符串的长度也变为奇数。<br><strong>转化后字符串$T$的长度为奇数</strong>：<br>在长度为奇数的字符串之间(包括外侧)，有偶数个位置；在长度为偶数的字符串之间(包括外侧)，<br>有奇数个位置，所有这样处理之后，字符串的长度都会变为奇数。事实上，公式$2 \times len + 1$ 已经说明预处理之后的字符串长度必为奇数。<br><strong>奇回文串和偶回文串一起处理</strong>：<br>以字符 <code>#</code> 为中点位置，处理的就是偶回文串的情况，<br>以其他字符为中点位置，处理的就是奇回文串的情况。  </p><p>为了避免出现数组访问越界的边界问题，我们将字符串$T$的首部再添加一个原字符串$S$中没有出现的字符，最后处理完的字符串如下：  </p><blockquote><p>S = a b a a b a<br>T = &nbsp;&nbsp;&nbsp;# a # b # a # a # b # a #<br>T = $ # a # b # a # a # b # a #   </p></blockquote><p>这样，预处理工作完成，下面进入manacher算法的核心部分。  </p><h3 id="2-manacher’s-algorithm"><a href="#2-manacher’s-algorithm" class="headerlink" title="2. manacher’s algorithm"></a>2. manacher’s algorithm</h3><p>这里，定义一个数组$p[]$ 和 两个变量 $r$ 和 $c$。<br>$p[i]$表示以位置$i$为中点的最大回文子串的长度。<br>$r$ 表示当前所有检测过的位置所能到达的最右端。<br>$c$ 为与 $r$ 对应的 $i$ 的位置，与 $r$ 同时更新，实际上 $c+p[i]=r$ 。  </p><p>回忆下一个$O(n^2)$的做法：<br>从左到右对字符串进行扫描，以每个位置为中点，向两边扩张，并记录最大长度和相应的位置（对于偶数，类似的再处理一遍即可）。<br>这种算法的空间复杂度为$O(1)$，是很优秀的，但是，对于每一个位置，都从长度为0开始向两边扩展，这是导致时间复杂度高的一个最主要的原因。  </p><p>而manacher算法则是额外使用一个$p[]$数组记录最大回文子串的长度，<br>因存在对称关系，数组$p[]$的值能够被充分利用，部分$p[i]$的值可以在$O(1)$的时间确定。<br>从而使得算法的复杂度降为$O(n)$。<br>这种思路类似于KMP算法，充分利用前面已经匹配过的有用信息。  </p><p>如何计算数组$p[]$的值呢？ 我们分<strong>两种情况：</strong>  </p><p>${i}’$ 代表 $i$ 关于中心 $c$ 的对称点，计算公式为 ${i}’=2 \times c - i$  </p><script type="math/tex; mode=display">\begin{cases} & \text{ if } (i < r ) \;     \begin{cases}      \text{ if } (r-i>p[{i}']) \; \text{then}\; p[i]=p[{i}'] \\       \text{ otherwise } p[i]= r-i \\     \end{cases} \\ \\ & \text{ otherwise } p[i]= 0\end{cases}</script><p>至于为什么是两种情况，请看下面的参考文献，这里图我就不摆了。  </p><p>这样我们可以轻松得到P数组的值  </p><blockquote><p>T = $ # a # b # a # a # b # a #<br>P = 0 0 1 0 3 0 1 6 1 0 3 0 1 0  </p></blockquote><p>容易看出，$p[7] = 6$是数组$p[]$中的的最大值，这正是原字符串$S$的最长回文子串的长度。这样，在线性时间处理完$P[]$数组之后，最大回文子串就找到，若还需要输出字符串，那只需要再做一些细节处理即可。  </p><h3 id="3-核心代码"><a href="#3-核心代码" class="headerlink" title="3. 核心代码"></a>3. 核心代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">(<span class="type">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt; len ; ++i ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( r &gt; i ) p[i] = <span class="built_in">min</span>( p[ <span class="number">2</span> * c - i ], r - i );</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; len &amp;&amp; s[i + <span class="number">1</span> + p[i]] == s[i - <span class="number">1</span> - p[i]] ) p[i]++;</span><br><span class="line">        <span class="keyword">if</span>( i + p[i] &gt; r ) &#123;</span><br><span class="line">            r = i + p[i];</span><br><span class="line">            c = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-算法复杂度"><a href="#4-算法复杂度" class="headerlink" title="4. 算法复杂度"></a>4. 算法复杂度</h3><p>从代码可以看出。<br>$\text{manacher}$算法只需要线性扫描一遍预处理后的字符串。<br>对$p[]$数组的处理  </p><ol><li>$\text{ if } (i &lt; r ) \;\;O(1)$ 时间可以确定  </li><li>$\text{ otherwise } O(n)$匹配，但是在情况2下，每次扫描都是从$r+1$开始的，且$r$自身的变化情况是单调递增的，这样可以保证，字符串T中的每个字符最多被访问2次，所以，该算法的时间复杂度是线性$O(n)$，事实上，$\text{while}$循环执行的总次数是线性次的。  </li></ol><h3 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h3><blockquote><p><a href="http://www.cnblogs.com/egust/p/4580299.html">Manacher’s algorithm: 最长回文子串算法</a><br><a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html">Longest Palindromic Substring Part II</a><br><a href="http://www.felix021.com/blog/read.php?2040">Manacher’s ALGORITHM: </a><br>练习见 <a href="http://www.cnblogs.com/BigBallon/p/3816890.html">原博客</a>  </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法讲堂 </tag>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What’s ACM-ICPC ?</title>
      <link href="/2014/04/02/cauu/"/>
      <url>/2014/04/02/cauu/</url>
      
        <content type="html"><![CDATA[<div class="note green icon flat"><i class="note-icon fas fa-rocket"></i><p>文档目录<br><a href="/2014/04/02/cauu/">What’s ACM</a><br><a href="/2018/07/28/社团活动介绍/">协会活动介绍</a><br><a href="/2018/07/28/入门指南/">入门指南</a><br><a href="/faq">常见问题解答FAQ</a></p></div><h1 id="What’s-ACM-ICPC"><a href="#What’s-ACM-ICPC" class="headerlink" title="What’s ACM-ICPC ?"></a>What’s ACM-ICPC ?</h1><hr><h2 id="ICPC-简介"><a href="#ICPC-简介" class="headerlink" title="ICPC 简介"></a>ICPC 简介</h2><p>国际大学生程序设计竞赛（英文全称：International Collegiate Programming Contest（简称<a href="https://baike.baidu.com/item/ICPC/10243">ICPC</a>））是由国际计算机协会（<a href="https://baike.baidu.com/item/ACM/64774">ACM</a>）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近40年的发展，ACM国际大学生程序设计竞赛已经发展成为全球最具影响力的大学生程序设计竞赛。赛事目前由<a href="https://baike.baidu.com/item/AWS/16529930">AWS</a>、<a href="https://baike.baidu.com/item/华为/298705">华为</a>和<a href="https://baike.baidu.com/item/Jetbrains/7502758">Jetbrains</a> [5] 赞助。</p><blockquote><p>由于以前 ACM 赞助ICPC竞赛，尽管现在不赞助了，但人们仍然习惯叫它 ACM 竞赛。</p></blockquote><p>ICPC 主要分为区域赛（Regionals）和总决赛（World Finals）两部分。</p><p>官网地址：<a href="https://icpc.global/">https://icpc.global</a></p><p>竞赛的历史可以上溯到1970年，当时在美国德克萨斯A&amp;M大学举办了首届比赛。当时的主办方是the Alpha Chapter of the UPE Computer Science HonorSociety。作为一种全新的发现和培养计算机科学顶尖学生的方式，竞赛很快得到美国和加拿大各大学的积极响应。 </p><p>1977年，在ACM计算机科学会议期间举办了首次总决赛，并演变成为目前的一年一届的多国参与的国际性比赛。迄今已经举办了43届。</p><p>许多知名公司也会举办类似赛制的比赛，比如微软的编程之美，Google的google code jam、百度的百度之星等等。</p><p><img src="https://cos.chdacm.cn//imgs/ICPC北京.jpg" alt="2018ICPC-WorldFinal 北京比赛现场"></p><p><img src="https://cos.chdacm.cn//imgs/4552D3B0-B4D4-409E-A533-7FF7273C3300.png?imageMogr2/thumbnail/!50p" alt="比赛实况转播"></p><h2 id="比赛规则"><a href="#比赛规则" class="headerlink" title="比赛规则"></a>比赛规则</h2><p>ICPC 以团队的形式代表以团队的形式代表各学校参赛，每队由至多3名队员组成。每位队员必须是在校学生，有一定的年龄限制，并且每年最多可以参加2站区域选拔赛。</p><p>比赛期间，每队使用<strong>1台电脑</strong>需要在<strong>5个小时</strong>内使用C/C++、Java和Python中的一种编写程序解决7到13个问题。程序完成之后提交评测机运行，运行的结果会判定为正确或错误两种并及时通知参赛队。而且有趣的是每队在正确完成一题后，组织者将在其位置上升起一只代表该题颜色的气球，每道题目第一支解决掉它的队还会额外获得一个“FIRST PROBLEM SOLVED”的气球。</p><p>最后的获胜者为<strong>正确解答题目最多且总用时最少的队伍</strong>。每道试题用时将从竞赛开始到试题解答被判定为正确为止，其间每一次提交运行结果被判错误的话将被加罚20分钟时间，未正确解答的试题不记时。</p><p>几个显著特点：</p><ul><li>参赛队伍最多由三名参赛队员组成。</li><li>竞赛中命题10题左右，试题描述为英文，比赛时间为5个小时，前四个小时可以实时看到排名，<strong>最后一小时封榜，无法看到排名</strong>。</li><li>竞赛可以使用的语言：Java, C, C++。（目前国内部分区域赛支持Python）</li><li>重点考察选手的算法和程序设计能力，不考察实际工程中常用的系统编程，多线程编程等等；</li><li><strong>选手可携带任何非电子类资料，包括书籍和打印出来的程序</strong>等，部分赛区会对选手携带的纸质资料做限制。</li><li>评委负责将结果（正确或出错的类型）通过网络尽快返回给选手，除此之外不提供任何额外帮助；</li><li>每个题目对应一种颜色的气球，通过该题目的队伍会得到对应颜色气球。每道题目第一支解决掉它的队还会额外获得一个“FIRST PROBLEM SOLVED”（一血）的气球。</li></ul><h2 id="CCPC-简介"><a href="#CCPC-简介" class="headerlink" title="CCPC 简介"></a>CCPC 简介</h2><p>中国大学生程序设计竞赛（China Collegiate Programming Contest，简称CCPC）是由教育部高等学校计算机类专业教学指导委员会主办的面向全国高校大学生的年度学科竞赛，旨在激发学生学习计算机领域专业知识与技能的兴趣，鼓励学生主动灵活地运用计算机知识和技能解决实际问题，有效提升算法设计、逻辑推理、数学建模、编程实现和计算机系统能力，培养团队合作意识、挑战精神和创新能力。</p><p>CCPC以规范和完善中国大学生程序设计竞赛赛事体系为已任，开展具有中国特色的大学生程序设计竞赛，把竞赛融入中国高校人才培养体系，规范办赛，高水平办赛，维护赛事的公平公正，促进高校教学改革，丰富高校人才培养内涵。自从2015年首届CCPC竞赛以来，赛事规模发展迅猛，已经有国内600余所高校的20000余名大学生和1500余名一线教练参与赛事，竞赛影响力持续提升，为我国IT业的发展培养和选拔了大批人才。</p><p>2019年，CCPC在上半年组织了近20场省赛和地区赛、一场女生专场赛，下半年将组织一场网络选拔赛、三场全国分站赛和一场总决赛，通过网络选拔赛确定分站赛晋级名额，由三场分站赛确定总决赛晋级名额。</p><p>2019年CCPC分站赛共设置三站：秦皇岛站（承办校：东北大学秦皇岛分校，9月21日-22日）、哈尔滨站（承办校：东北林业大学，10月12日-13日）和厦门站（承办校：厦门理工学院，10月19日-20日），最后总决赛在北京（承办校：中国传媒大学，11月15日-17日）。</p><p>CCPC得到了诸多企业的支持，2015年欢乐互娱赞助，2016年金山赞助，2017年旷视科技和吉比特赞助，2018年旷视科技为总赞助，腾讯、快手、字节跳动为金牌赞助。CCPC将进一步深化与相关企业的合作。</p><p>中国品牌的算法竞赛，由于近几年赛区队伍数量控制得当，含金量稍比ICPC部分赛区高一些。附上官网地址：<a href="https://ccpc.io/">中国大学生程序设计竞赛(CCPC)-官网</a></p><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>ACM协会的艰难成长记</span></div>    <div class="hide-content"><ul><li><p>2014年4月2日<br>在老师与队员的共同努力之下，CHD_OJ/ACMers_BBS正式上线运行，这是我们的一个里程碑。希望能够吸引更多同学加入我们的行列，锻炼逻辑思维、团队协作的能力。我们也希望借由BBS这个平台，提升学校原本缺少的学术氛围（希望吧），将其打造成我们学校的技术论坛。<br>暑假后一段时间未使用，ip被学校收回……0.0</p></li><li><p>2014年9月<br>长安大学ACM协会由LW发起成立！新的里程碑！</p></li><li><p>2014年11月29日</p><p>举办长大首届ACM/ICPC迎新杯（个人赛）！</p></li><li><p>2014年12月</p><p>试图过把服务器搬回宿舍，用花生壳代理做内网映射，重启过一段时间，后因内网映射层数太多以及宿舍网速太慢，导致效果不太好，宣告放弃。<br>此时A协已经开始逐渐发展壮大。</p></li><li><p>2015年4月18日</p><p>长大首届大型校赛成功举办！来了好多学校的（道友）。。。</p></li><li><p>2015年5月</p><p>内网IP终于拿下来了，OJ复活，BBS、各种都升级了一下、还加上了VJudge。外网部分继续依靠花生壳，速度还可以。</p></li><li><p>2015年7月<br>重新整理服务器，优化性能。希望不要再出太多bug了，哭。。。</p></li><li><p>2016年5月21、22日<br>承办陕西省第四届ACM/ICPC大学生程序设计竞赛。</p></li><li><p>2019年6月<br>^-^ 重新整理了2018年的课件 —by hyd</p></li><li><p>2021年5月<br>(๑•̀ㅂ•́)و✧  CHDOJ Vx.x 版本上线啦！这次魔改了一整个五一假期<br><a class="btn-beautify button--animated center green outline" href="https://oj.chdacm.cn" title="去瞅瞅"><i class="far fa-hand-point-right"></i><span>去瞅瞅</span></a></p></li><li><p>2021年7月26日<br>&lt;(￣︶￣)&gt; CHD-ACM官网搬家啦<br><a href="https://jekyllrb.com/">jekyll</a> =&gt; <a href="https://hexo.io/zh-cn/">Hexo</a> </p></li></ul></div></div><h1 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h1><p>QQ:</p><ul><li>长大A协萌新群: <strong><a href="https://jq.qq.com/?_wv=1027&amp;k=roJV0oxK">1149886530点击加入</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> FAQ </category>
          
          <category> 入门指南 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
