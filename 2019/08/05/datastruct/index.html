<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>2019暑期集训第八讲：数据结构进阶（一） | 长安大学ACM协会</title><meta name="keywords" content="算法讲堂,线段树,笛卡尔树"><meta name="author" content="CHD-ACM"><meta name="copyright" content="CHD-ACM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构进阶(一)主讲人：孙翔 线段树为什么要线段树？题目一： 10000个正整数，编号1到10000，用A[1],A[2],A[10000]表示。 修改：无 统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;&#x3D; L &lt;&#x3D; R &lt;&#x3D; 10000.  方法一：对于统计L,R ，需要求下标从L到R的所有数的和，从L到R的所有下标记做[L..R],问题就是对A[L..R]进行求和。这">
<meta property="og:type" content="article">
<meta property="og:title" content="2019暑期集训第八讲：数据结构进阶（一）">
<meta property="og:url" content="http://example.com/2019/08/05/datastruct/index.html">
<meta property="og:site_name" content="长安大学ACM协会">
<meta property="og:description" content="数据结构进阶(一)主讲人：孙翔 线段树为什么要线段树？题目一： 10000个正整数，编号1到10000，用A[1],A[2],A[10000]表示。 修改：无 统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;&#x3D; L &lt;&#x3D; R &lt;&#x3D; 10000.  方法一：对于统计L,R ，需要求下标从L到R的所有数的和，从L到R的所有下标记做[L..R],问题就是对A[L..R]进行求和。这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/home-bg.jpg">
<meta property="article:published_time" content="2019-08-04T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-02T14:27:46.514Z">
<meta property="article:author" content="CHD-ACM">
<meta property="article:tag" content="算法讲堂">
<meta property="article:tag" content="线段树">
<meta property="article:tag" content="笛卡尔树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/home-bg.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2019/08/05/datastruct/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2019暑期集训第八讲：数据结构进阶（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-02 22:27:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/icon.css" medai="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/kean-logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 关于我们</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/2014/04/02/cauu/"><i class="fa-fw fas fa-question"></i><span> What’s ACM-ICPC ?</span></a></li><li><a class="site-page child" href="/2018/07/28/%E7%A4%BE%E5%9B%A2%E6%B4%BB%E5%8A%A8%E4%BB%8B%E7%BB%8D/"><i class="fa-fw fas fa-bars"></i><span> 协会活动</span></a></li><li><a class="site-page child" href="/2018/07/28/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"><i class="fa-fw fas fa-location-arrow"></i><span> 入门指南</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/2016/"><span> 2016陕西省赛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 集训队</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/team/"><i class="fa-fw fas fa-users"></i><span> 成员</span></a></li><li><a class="site-page child" href="/award/"><i class="fa-fw fas fa-award"></i><span> 荣誉</span></a></li><li><a class="site-page child" href="/image/"><i class="fa-fw iconfont icon-camera"></i><span> 获奖瞬间</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/puzzle/"><i class="fa-fw fas fa-gamepad"></i><span> 趣味拼图</span></a></div><div class="menus_item"><a class="site-page" href="/faq/"><i class="fa-fw fas fa-question"></i><span> FAQ</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/home-bg.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">长安大学ACM协会</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/index/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 关于我们</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/2014/04/02/cauu/"><i class="fa-fw fas fa-question"></i><span> What’s ACM-ICPC ?</span></a></li><li><a class="site-page child" href="/2018/07/28/%E7%A4%BE%E5%9B%A2%E6%B4%BB%E5%8A%A8%E4%BB%8B%E7%BB%8D/"><i class="fa-fw fas fa-bars"></i><span> 协会活动</span></a></li><li><a class="site-page child" href="/2018/07/28/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"><i class="fa-fw fas fa-location-arrow"></i><span> 入门指南</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/2016/"><span> 2016陕西省赛</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 集训队</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/team/"><i class="fa-fw fas fa-users"></i><span> 成员</span></a></li><li><a class="site-page child" href="/award/"><i class="fa-fw fas fa-award"></i><span> 荣誉</span></a></li><li><a class="site-page child" href="/image/"><i class="fa-fw iconfont icon-camera"></i><span> 获奖瞬间</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/puzzle/"><i class="fa-fw fas fa-gamepad"></i><span> 趣味拼图</span></a></div><div class="menus_item"><a class="site-page" href="/faq/"><i class="fa-fw fas fa-question"></i><span> FAQ</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2019暑期集训第八讲：数据结构进阶（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-04T16:00:00.000Z" title="发表于 2019-08-05 00:00:00">2019-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-02T14:27:46.514Z" title="更新于 2024-08-02 22:27:46">2024-08-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2019暑期集训第八讲：数据结构进阶（一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构进阶-一"><a href="#数据结构进阶-一" class="headerlink" title="数据结构进阶(一)"></a>数据结构进阶(一)</h1><p><strong>主讲人：孙翔</strong></p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="为什么要线段树？"><a href="#为什么要线段树？" class="headerlink" title="为什么要线段树？"></a>为什么要线段树？</h3><p>题目一： 10000个正整数，编号1到10000，用A[1],A[2],A[10000]表示。 修改：无 统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000. </p>
<p><strong>方法一：对于统计L,R ，需要求下标从L到R的所有数的和，从L到R的所有下标记做[L..R],问题就是对A[L..R]进行求和。这样求和，对于每个询问，需要将(R-L+1)个数相加。</strong></p>
<p> <strong>方法二：更快的方法是求前缀和,令 S[0]=0, S[k]=A[1..k] ，那么，A[L..R]的和就等于S[R]-S[L-1]，这样，对于每个询问，就只需要做一次减法，大大提高效率。</strong> </p>
<p>题目二： 10000个正整数，编号从1到10000，用A[1],A[2],A[10000]表示。 修改：1.将第L个数增加C （1 &lt;= L &lt;= 10000） 统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000. </p>
<p>再使用方法二的话，假如A[L]+=C之后，S[L],S[L+1],,S[R]都需要增加C,全部都要修改，见下表。 </p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071358584.png" alt="1565071358584"></p>
<p>从上表可以看出，方法一修改快，求和慢。 方法二求和快，修改慢。那有没有一种结构，修改和求和都比较快呢？答案当然是线段树。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计。与按照二进制位（2的次幂）进行区间划分的树状数组相比，线段树是一种更加通用的结构。</p>
<p>1.线段树的每个节点都代表一个区间。</p>
<p>2.线段树具有唯一的根节点，代表的区间是整个统计范围。</p>
<p>3.线段树的每个叶节点都代表一个长度为1的元区间[x,x]。</p>
<p>4.对于每个内部节点[l,r],它的左子节点是[l,mid],右子节点是[mid+1,r],其中mid=(l+r)/2。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071333038.png" alt="1565071333038"></p>
<p>如上图所示为一棵线段树。可以发现，除去树的最后一层，整棵线段树一定是一棵完全二叉树，数的深度是O(logN)。因此，我们可以按照与二叉堆类似的方法建树：</p>
<p>1.根节点的编号为1。</p>
<p>2.编号为x的节点的左子节点编号为x <em> 2，右子节点编号为x </em> 2 + 1。</p>
<p>​    这样我们就能简单地使用一个结构体数组来保存线段树。当然，树的最后一层节点在数组中保存的位置不是连续的，直接空出数组中多余的位置即可。那么，N个叶子节点的满二叉树有N+N/2+N/4…..+2+1=2N-1个节点。由于在最后一层可能还有剩余，因此保存线段树的数组长度不小于4N才能保证不越界。**</p>
<h3 id="线段树建树"><a href="#线段树建树" class="headerlink" title="线段树建树"></a>线段树建树</h3><p>线段树的基本用途是对序列进行维护，支持查询与修改指令。给定一个长度为N的序列A，我们可以在区间[1,N]上建立一棵线段树，每个叶子结点[i,i]保存A[i]的值。线段树的二叉树结构可以很方便地从下往上传递信息。以区间最大值问题为例，记dat(l,r)等于max{A[i]},l&lt;=i&lt;=r。显然dat(l,r)=max(dat(l,mid),dat(mid+1,r))。</p>
<p>下面这段代码建立了一棵线段树并在每个节点上保存了对应区间的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="type">int</span> dat;</span><br><span class="line">&#125;t[SIZE*<span class="number">4</span>];		<span class="comment">//结构体数组存储线段树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].l=l,t[p].r=r;		<span class="comment">//节点p代表区间[l,r] </span></span><br><span class="line">	<span class="keyword">if</span>(l==r)	<span class="comment">//叶子节点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		t[p].dat=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span><span class="number">+1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span><span class="number">+1</span>].dat);	<span class="comment">//从下往上传递信息 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);	<span class="comment">//调用入口 </span></span><br></pre></td></tr></table></figure>
<h3 id="线段树的单点修改"><a href="#线段树的单点修改" class="headerlink" title="线段树的单点修改"></a>线段树的单点修改</h3><p>单点修改是一条形如”C x y”的指令，表示把A[x]的值修改为v。</p>
<p>在线段树中，根节点(即编号为1的点)是执行各种指令的入口。我们需要从根节点出发，递归找到代表区间[x,x]的叶子节点，然后从下往上更新[x,x]以及它的所有祖先上保存的信息。容易知道，其时间复杂度也是O(logN)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[p].l==t[p].r)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].dat=v;</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">change</span>(p*<span class="number">2</span>,x,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">change</span>(p*<span class="number">2</span><span class="number">+1</span>,x,v);</span><br><span class="line">	&#125;</span><br><span class="line">	t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span><span class="number">+1</span>].dat);	<span class="comment">//从下往上更新信息 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,x,v);</span><br></pre></td></tr></table></figure>
<h3 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h3><p>区间查询是一条形如”Q l r”的指令，例如查询序列A在区间[l,r]上的最大值，即max{A[i]},l&lt;=i&lt;=r。我们只需要从根节点开始，递归执行如下过程。</p>
<p>​    1.若[l,r]完全覆盖了当前节点代表的区间，则立即回溯，并且该节点的dat值为候选答案。</p>
<p>​    2.若左子节点与[l,r]有重叠部分，则递归访问左子节点。</p>
<p>​    3.若右子节点与[l,r]有重叠部分，则递归访问右子节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;r&gt;=t[p].r)	<span class="comment">//完全包含 </span></span><br><span class="line">		<span class="keyword">return</span> t[p].dat;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> val=-(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);	<span class="comment">//负无穷 </span></span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">	&#123;</span><br><span class="line">		val=<span class="built_in">max</span>(val,<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">	&#123;</span><br><span class="line">		val=<span class="built_in">max</span>(val,<span class="built_in">ask</span>(p*<span class="number">2</span><span class="number">+1</span>,l,r));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,r)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定长度为N的数列A，以及M条指令 (N≤500000, M≤100000)，每条指令可能是以下两种之一：</p>
<p>“1 x y”，查询区间 [x,y] 中的最大连续子段和，即 max(x≤l≤r≤y)⁡ { ∑(i=l~r) A[i] }。</p>
<p>“2 x y”，把 A[x] 改成 y。</p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>针对操作1，在线段树上的每个节点上，除了区间端点外，再维护4个信息：区间和sum，区间最大连续字段和dat,紧靠左端的最大连续字段和lmax,紧靠右端的最大连续子弹和rmax。则得到如下式子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t[p].sum=t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span><span class="number">+1</span>].sum;</span><br><span class="line">t[p].lmax=<span class="built_in">max</span>(t[p*<span class="number">2</span>].lmax,t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span><span class="number">+1</span>].lmax);</span><br><span class="line">t[p].rmax=<span class="built_in">max</span>(t[p*<span class="number">2</span>].rmax,t[p*<span class="number">2</span><span class="number">+1</span>].sum+t[p*<span class="number">2</span>].rmax);</span><br><span class="line">t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span><span class="number">+1</span>].dat,t[p*<span class="number">2</span>].rmax+t[p*<span class="number">2</span><span class="number">+1</span>].lmax); </span><br></pre></td></tr></table></figure>
<p>针对操作2，单点修改即可。</p>
<h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>在线段树的“区间修改”指令中，如果某个节点被修改区间[l,r]完全覆盖，那么以该节点为根的整棵子树中的所有节点存储的信息都要修改，若一个一个更新(单点修改)，时间复杂度是O(N)的，我们难以接受。</p>
<p>试想一下如果在一次修改指令中发现节点p代表的区间[pl,pr]被修改区间[l,r]完全覆盖，并且一个一个更新了子树p的所有节点，但是在之后的查询指令中却没有用到[l,r]的子区间作为候选答案，那么更新p的整棵子树就是徒劳的。</p>
<p>那么我们考虑在执行修改指令的时候，可以在l&lt;=pl&lt;=pr&lt;=r的情况下立即返回，但是在回溯之前给p节点加一个标记，表示该节点曾经被修改，但是其子节点还没有被修改。</p>
<p>如果在后续的指令中，需要从节点p向下递归，我们再检查p是否有标记。如果有标记，就根据标记信息更新p的两个子节点，同时为p的两个子节点增加标记，然后清除p的标记。</p>
<p>也就是说，除了在修改指令中直接划分的O(logN)个节点外，对任意节点的修改都延迟到在后续操作中递归进入它的父亲节点时再执行。这样，查询和修改指令的时间复杂度都降到了O(logN)。延迟标记提供了线段树中从上向下传递信息的方式。也是设计算法和解决问题的一个重要思路。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> sum,add;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> l(x) tree[x].l;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> r(x) tree[x].r;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> add(x) tree[x].add</span></span><br><span class="line">&#125;tree[<span class="number">100010</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l;</span><br><span class="line">	<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sum</span>(p)=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span><span class="number">+1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p*<span class="number">2</span>)+<span class="built_in">sum</span>(p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">add</span>(p))	<span class="comment">//如果p节点有标记 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sum</span>(p*<span class="number">2</span>)+=<span class="built_in">add</span>(p)*(<span class="built_in">r</span>(p*<span class="number">2</span>)-<span class="built_in">l</span>(p*<span class="number">2</span>)<span class="number">+1</span>);		<span class="comment">//更新左子节点信息</span></span><br><span class="line">		<span class="built_in">sum</span>(p*<span class="number">2</span><span class="number">+1</span>)+=<span class="built_in">add</span>(p)*(<span class="built_in">r</span>(p*<span class="number">2</span><span class="number">+1</span>)-<span class="built_in">l</span>(p*<span class="number">2</span><span class="number">+1</span>)<span class="number">+1</span>);	<span class="comment">//更新右子节点</span></span><br><span class="line">		<span class="built_in">add</span>(p*<span class="number">2</span>)+=<span class="built_in">add</span>(p);		<span class="comment">//给左子节点打延迟标记 </span></span><br><span class="line">		<span class="built_in">add</span>(p*<span class="number">2</span><span class="number">+1</span>)+=<span class="built_in">add</span>(p);		<span class="comment">//给右子节点打延迟标记 </span></span><br><span class="line">		<span class="built_in">add</span>(p)=<span class="number">0</span>; 				<span class="comment">//清除p的标记 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;r&gt;=<span class="built_in">r</span>(p))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sum</span>(p)+=(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)d*(<span class="built_in">r</span>(p)-<span class="built_in">l</span>(p)<span class="number">+1</span>);</span><br><span class="line">		<span class="built_in">add</span>(p)+=d;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">mid</span><span class="params">(l(p)+r(p))</span>/2</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">		<span class="built_in">change</span>(p*<span class="number">2</span>,l,r,d);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">		<span class="built_in">change</span>(p*<span class="number">2</span><span class="number">+1</span>,l,r,d);</span><br><span class="line">	<span class="built_in">sum</span>(p)=<span class="built_in">sum</span>(p*<span class="number">2</span>)+<span class="built_in">sum</span>(p*<span class="number">2</span><span class="number">+1</span>)； </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="built_in">ask</span>(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;r&gt;=<span class="built_in">r</span>(p))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sum</span>(p);</span><br><span class="line">	<span class="built_in">spread</span>(p);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)</span><br><span class="line">		val+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)</span><br><span class="line">		val+=<span class="built_in">ask</span>(p*<span class="number">2</span><span class="number">+1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题：POJ3468"><a href="#例题：POJ3468" class="headerlink" title="例题：POJ3468"></a>例题：POJ3468</h4><p>题意：给定长度为N(N&lt;=1e5)的数列A，然后输入Q(Q&lt;=1e5)行操作指令。</p>
<p>第一类指令形如”C l r d”，表示把数列中的第l~r个数都加d。</p>
<p>第二类指令形如”Q l r”，表示询问数列中第l~r个数的和。</p>
<p>分析：区间修改裸题，区间修改时加一个lazy下标即可。</p>
<h4 id="Billboard"><a href="#Billboard" class="headerlink" title="Billboard"></a><a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-2795">Billboard</a></h4><p>题意：有一块h <em> w的矩形广告板，要往上面贴广告;然后给n个1 </em> wi的广告，要求把广告贴上去;而且要求广告要尽量往上贴并且尽量靠左;求第n个广告的所在的位置，不能贴则为-1;</p>
<p>分析：利用线段树可以求区间的最大值;将位置即h用来建树(h&lt;=n,大了没有意义);树中存储的为该位置还拥有的空间;若左子树的最大值大于他,就查询左子树，否则查询右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200010  <span class="comment">//元素总个数</span></span></span><br><span class="line"><span class="type">int</span> A[maxn&lt;&lt;<span class="number">2</span>];<span class="comment">//存原数组数据下标[1,n] </span></span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Build函数建树 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//l,r表示当前节点区间，rt表示当前节点编号</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	A[rt]=w;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="comment">//若到达叶节点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//左右递归建树 </span></span><br><span class="line">	<span class="built_in">Build</span>(l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Build</span>(m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span><span class="comment">//x表示要查询的值，l,r表示当前节点区间，rt表示当前节点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		A[rt]-=x;</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line">	<span class="keyword">if</span>(A[rt&lt;&lt;<span class="number">1</span>]&gt;=x)</span><br><span class="line">	&#123;</span><br><span class="line">		res=<span class="built_in">Query</span>(x,l,m,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		res=<span class="built_in">Query</span>(x,m<span class="number">+1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	A[rt]=<span class="built_in">max</span>(A[rt&lt;&lt;<span class="number">1</span>],A[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;h,&amp;w,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(h&gt;n)</span><br><span class="line">            h=n;</span><br><span class="line">		<span class="built_in">Build</span>(<span class="number">1</span>,h,<span class="number">1</span>);<span class="comment">//从1-h建树，根节点是1 </span></span><br><span class="line">		<span class="keyword">while</span>(n--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			<span class="keyword">if</span>(A[<span class="number">1</span>]&lt;x)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> ans=<span class="built_in">Query</span>(x,<span class="number">1</span>,h,<span class="number">1</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>题意：给定一个字符串(长度&lt;=100000)，有两个操作。   1：改变某个字符。 2：判断某个子串是否构成回文串。  </p>
<p>分析：直接判断是不是字符串必定超时，所以考虑用线段树维护字符串哈希。对于一个字符串a[0],a[1],…,a[n-1] 它对应的哈希函数为a[0]+a[1]<em>K + a[2]</em>K^2 +…+a[n-1]<em>K^(n-1)。<br>再维护一个从右往左的哈希值：a[0]</em>K^(n-1) + a[1]*K^(n-2) +…+a[n-1]<br>若是回文串，则左右的哈希值会相等。而左右哈希值相等，则很大可能这是回文串。</p>
<p>若出现误判，可以再用一个K2，进行二次哈希判断，可以减小误判概率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l , m , rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson m + 1 , r , rt &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull __int64</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">123</span>;</span><br><span class="line">ull sum[<span class="number">2</span>][maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ull h[maxn],p[maxn];</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span> <span class="params">( <span class="type">int</span> rt , <span class="type">int</span> flag )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[flag][rt] = sum[flag][rt&lt;&lt;<span class="number">1</span>] + sum[flag][rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span> <span class="params">( <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> rt , <span class="type">int</span> flag )</span> <span class="comment">//1,n,1,0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[flag][rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( l == r ) </span><br><span class="line">	&#123;</span><br><span class="line">        sum[flag][rt] = h[l] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = ( l + r ) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">build</span> ( lson , flag ) ;</span><br><span class="line">    <span class="built_in">build</span> ( rson , flag ) ;</span><br><span class="line">    <span class="built_in">push_up</span> ( rt , flag ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span> <span class="params">( <span class="type">int</span> a , ull b , <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> rt , <span class="type">int</span> flag )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( l == r ) </span><br><span class="line">	&#123;</span><br><span class="line">        sum[flag][rt] = b ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = ( l + r ) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> ( a &lt;= m ) </span><br><span class="line">		<span class="built_in">update</span> ( a , b , lson , flag ) ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">update</span> ( a , b , rson , flag ) ;</span><br><span class="line">    <span class="built_in">push_up</span> ( rt , flag ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">query</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b , <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> rt , <span class="type">int</span> flag )</span> <span class="comment">//要查询的范围a,b  从1-n查  根是1  flag判断正反哈希建树 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a &lt;= l &amp;&amp; r &lt;= b ) </span><br><span class="line">		<span class="keyword">return</span> sum[flag][rt] ;</span><br><span class="line">    <span class="type">int</span> m = ( l + r ) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    ull ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> ( a &lt;= m ) </span><br><span class="line">		ret += <span class="built_in">query</span> ( a , b , lson , flag ) ;</span><br><span class="line">    <span class="keyword">if</span> ( m &lt; b ) </span><br><span class="line">		ret += <span class="built_in">query</span> ( a , b , rson , flag ) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i , j , k , m , a , b , c , d ;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">111</span>] ;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span> ( <span class="string">&quot;%s&quot;</span> , s ) != EOF ) <span class="comment">//输入原字符串 </span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">scanf</span> ( <span class="string">&quot;%d&quot;</span> , &amp;m ) ;<span class="comment">//m个操作 </span></span><br><span class="line">        <span class="comment">//哈希 </span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span> ( s ) ;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= len ; i ++ ) </span><br><span class="line">			p[i] = p[i<span class="number">-1</span>] * x ;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">            h[i<span class="number">+1</span>] = p[i] * (ull) s[i] ;</span><br><span class="line">        <span class="type">int</span> n = len ;</span><br><span class="line">        <span class="built_in">build</span> ( <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">0</span> ) ;<span class="comment">//flag用于正反哈希的判别 </span></span><br><span class="line">        <span class="built_in">reverse</span> ( s , s + len ) ;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">            h[i<span class="number">+1</span>] = p[i] * (ull) s[i] ;</span><br><span class="line">        <span class="built_in">build</span> ( <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">1</span> ) ;<span class="comment">//反着再哈希一次建树 </span></span><br><span class="line">        <span class="keyword">while</span> ( m -- ) </span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">scanf</span> ( <span class="string">&quot;%s&quot;</span> , op ) ;</span><br><span class="line">            <span class="keyword">if</span> ( op[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> ) </span><br><span class="line">			&#123;</span><br><span class="line">                <span class="built_in">scanf</span> ( <span class="string">&quot;%d%d&quot;</span> , &amp;a , &amp;b ) ;</span><br><span class="line">                ull k1 = <span class="built_in">query</span> ( a , b , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">0</span> ) ;</span><br><span class="line">                <span class="type">int</span> l = len - b + <span class="number">1</span> , r = len - a + <span class="number">1</span> ;<span class="comment">//反向哈希之后的a,b  </span></span><br><span class="line">                ull k2 = <span class="built_in">query</span> ( l , r , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">1</span> ) ;</span><br><span class="line">                <span class="type">int</span> t1 = a - <span class="number">1</span> , t2 = len - b ;</span><br><span class="line">                <span class="keyword">if</span> ( t2 &gt; t1 ) </span><br><span class="line">					k1 *= p[t2-t1] ;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">					k2 *= p[t1-t2] ;</span><br><span class="line">                <span class="keyword">if</span> ( k1 == k2 ) </span><br><span class="line">					<span class="built_in">puts</span> ( <span class="string">&quot;Yes&quot;</span> ) ;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">					<span class="built_in">puts</span> ( <span class="string">&quot;No&quot;</span> ) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">                <span class="built_in">scanf</span> ( <span class="string">&quot;%d%s&quot;</span> , &amp;a , op ) ;</span><br><span class="line">                <span class="built_in">update</span> ( a , (ull) p[a<span class="number">-1</span>] * op[<span class="number">0</span>] , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">0</span> ) ;</span><br><span class="line">                <span class="built_in">update</span> ( len - a + <span class="number">1</span> , (ull) p[len-a] * op[<span class="number">0</span>] , <span class="number">1</span> , n , <span class="number">1</span> , <span class="number">1</span> ) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一：将问题转换成点信息和目标信息。即，将问题转换成对一些点的信息的统计问题。</p>
<p>二：将目标信息根据需要扩充成区间信息<br>    1.增加信息符合区间加法。<br>    2.增加标记支持区间操作。</p>
<p>三：代码中的主要模块：<br>    1.区间加法<br>    2.标记下推<br>    3.点信息-&gt;区间信息<br>    4.操作（各种操作，包括修改和查询）</p>
<p>完成第一步之后，题目有了可以用线段树解决的可能。<br>完成第二步之后，题目可以由线段树解决。</p>
<p>第三步就是慢慢写代码了。</p>
<p>解题模型如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071398804.png" alt="1565071398804"></p>
<h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>线段树的一大应用是扫描线。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071440070.png" alt="1565071440070"> </p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071453653.png" alt="1565071453653"></p>
<p>观察第三个图：<br>扫描线的思路：使用一条垂直于X轴的直线，从左到右来扫描这个图形，明显，只有在碰到矩形的左边界或者右边界的时候，这个线段所扫描到的情况才会改变，所以把所有矩形的入边，出边按X值排序。然后根据X值从小到大去处理，就可以用线段树来维护扫描到的情况。如上图，X1到X8是所有矩形的入边，出边的X坐标。而红色部分的线段，是这样，如果碰到矩形的入边，就把这条边加入，如果碰到出边，就拿走。红色部分就是有线段覆盖的部分。要求面积，只需要知道图中的L1到L8。而线段树就是用来维护这个L1到L8的。</p>
<p><strong>算法流程：</strong></p>
<p>X1:首先遇到X1,将第一条线段加入线段树，由线段树统计得到线段长度为L1.</p>
<p>X2:然后继续扫描到X2,此时要进行两个动作：<br>    1.计算面积，目前扫过的面积=L1*(X2-X1)<br>    2.更新线段。由于X2处仍然是入边，所以往线段树中又加了一条线段，加的这条线段可以参考3幅图中的第一幅。然后线段树自动得出此时覆盖的线段长度为L2 （注意两条线段有重叠部分，重叠部分的长度只能算一次）。</p>
<p>X3:继续扫描到X3，步骤同X2，先计算 扫过的面积+=L2*(X3-X2)，再加入线段，得到L3。</p>
<p>X4:扫描到X4有些不一样了。首先还是计算  扫过的面积+=L3*(X4-X3)，然后这时遇到了第一个矩形的出边，这时要从线段树中删除一条线段。删除之后的结果是线段树中出现了2条线段，线段树自动维护这两条线段的长度之和L4。</p>
<p>思考：线段树进行线段操作时，每个点的含义应该是什么？ </p>
<p>线段树如果没有离散化，那么线段树下标为1，就代表线段[1,2)<br>线段树下标为K的时候，代表的线段为[K,K+1) （长度为1）<br>所以，将上面的所有线段都化为[y1,y2)就可以理解了，线段[y1,y2)只包括线段树下标中的y1,y1+1,…,y2-1</p>
<p>当y值的范围是10^9时，就不能再按照上面的办法按值建树了，这时需要离散化。</p>
<p>其实就是把每条边提前找到存到一个数组里面，让叶子节点维护的不是长度1，而是对应的一个高度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 201</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;<span class="comment">//线段树的左右整点</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//c用来记录重叠情况</span></span><br><span class="line">    <span class="type">double</span> cnt,lf,rf;</span><br><span class="line">    <span class="comment">//cnt用来计算实在的长度，rf,lf分别是对应的左右(上下)真实的浮点数端点 </span></span><br><span class="line">&#125;segTree[MAXN*<span class="number">3</span>];     </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> f;<span class="comment">//入边还是出边，1入，-1出 </span></span><br><span class="line">&#125;line[MAXN];</span><br><span class="line"><span class="comment">//把一段段平行于y轴的线段表示成数组 ，</span></span><br><span class="line"><span class="comment">//x是线段的x坐标，y1,y2线段对应的下端点和上端点的坐标 </span></span><br><span class="line"><span class="comment">//一个矩形 ，左边的那条边f为1，右边的为-1，</span></span><br><span class="line"><span class="comment">//用来记录重叠情况，可以根据这个来计算，nod节点中的c </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Line a,Line b)</span><span class="comment">//sort排序的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> y[MAXN];<span class="comment">//记录y坐标的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//构造线段树，t是当前节点   1,1,t-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    segTree[t].l=l;segTree[t].r=r;</span><br><span class="line">    segTree[t].cnt=segTree[t].c=<span class="number">0</span>;</span><br><span class="line">    segTree[t].lf=y[l];</span><br><span class="line">    segTree[t].rf=y[r];</span><br><span class="line">    <span class="keyword">if</span>(l<span class="number">+1</span>==r)  </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Build</span>(t&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">Build</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid,r);<span class="comment">//递归构造 </span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calen</span><span class="params">(<span class="type">int</span> t)</span><span class="comment">//计算长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(segTree[t].c&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//cout&lt;&lt;&quot;123&quot;&lt;&lt;endl;</span></span><br><span class="line">        segTree[t].cnt=segTree[t].rf-segTree[t].lf;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(segTree[t].l<span class="number">+1</span>==segTree[t].r)  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;456&quot;&lt;&lt;endl;</span></span><br><span class="line">		segTree[t].cnt=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;789&quot;&lt;&lt;endl;</span></span><br><span class="line">		segTree[t].cnt=segTree[t&lt;&lt;<span class="number">1</span>].cnt+segTree[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t,Line e)</span><span class="comment">//加入线段e，后更新线段树  1，line[1] </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.y1==segTree[t].lf&amp;&amp;e.y2==segTree[t].rf)<span class="comment">//找到对应的边 </span></span><br><span class="line">    &#123;</span><br><span class="line">        segTree[t].c+=e.f;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;segTree[t].c:&quot;&lt;&lt;segTree[t].c&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">calen</span>(t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(e.y2&lt;=segTree[t&lt;&lt;<span class="number">1</span>].rf)  <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e.y1&gt;=segTree[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lf)  <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Line tmp=e;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;e.y2:&quot;&lt;&lt;e.y2&lt;&lt;&quot; e.y1:&quot;&lt;&lt;e.y1&lt;&lt;&quot; e.f:&quot;&lt;&lt;e.f&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;tmp.y2:&quot;&lt;&lt;tmp.y2&lt;&lt;&quot; tmp.y1:&quot;&lt;&lt;tmp.y1&lt;&lt;&quot; tmp.f:&quot;&lt;&lt;tmp.f&lt;&lt;endl;</span></span><br><span class="line">        tmp.y2=segTree[t&lt;&lt;<span class="number">1</span>].rf;</span><br><span class="line">        <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,tmp);</span><br><span class="line">        tmp=e;</span><br><span class="line">        tmp.y1=segTree[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lf;</span><br><span class="line">        <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tmp);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;999999999segTree[t].c:&quot;&lt;&lt;segTree[t].c&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">calen</span>(t);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,n,t,Case=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">    &#123;</span><br><span class="line">        Case++;</span><br><span class="line">        t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            line[t].x=x1;</span><br><span class="line">            line[t].y1=y1;</span><br><span class="line">            line[t].y2=y2;</span><br><span class="line">            line[t].f=<span class="number">1</span>;<span class="comment">//一开始入边 </span></span><br><span class="line">            y[t]=y1;<span class="comment">//y点坐标 </span></span><br><span class="line">            t++;</span><br><span class="line">            line[t].x=x2;</span><br><span class="line">            line[t].y1=y1;</span><br><span class="line">            line[t].y2=y2;</span><br><span class="line">            line[t].f=<span class="number">-1</span>;<span class="comment">//出边 </span></span><br><span class="line">            y[t]=y2;</span><br><span class="line">            t++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">sort</span>(line<span class="number">+1</span>,line+t,cmp);<span class="comment">//输入完之后根据x坐标对所有的线段排序 </span></span><br><span class="line">        <span class="built_in">sort</span>(y<span class="number">+1</span>,y+t);   <span class="comment">//对y点从小到大排序 </span></span><br><span class="line">        <span class="built_in">Build</span>(<span class="number">1</span>,<span class="number">1</span>,t<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,line[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;t;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=segTree[<span class="number">1</span>].cnt*(line[i].x-line[i<span class="number">-1</span>].x);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,line[i]);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;</span>,Case,res);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果是求所有矩形围成的图形的周长呢？</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071481570.png" alt="1565071481570"></p>
<p>这个图是在原来的基础上多画了一些东西，这次是要求周长。<br>所有的横向边都画了紫色，所有的纵向边画了绿色。</p>
<p>先考虑绿色的边，由图可以观察到，绿色边的长度其实就是L的变化值。<br>比如考虑X1,本来L是0,从0变到L1,所以绿色边长为L1.<br>再考虑X2,由L1变成了L2,所以绿色边长度为L2-L1,<br>于是，绿色边的长度就是L的变化值（注意上图中令L0=0,L9=0）。<br>因为长度是从0开始变化，最终归0.</p>
<p>再考虑紫色的边，要计算紫色边，其实就是计算L的线段是有几个线段组成的，每个线段会贡献两个端点（紫色圆圈）<br>而每个端点都会向右延伸出一条紫色边一直到下一个X值。</p>
<p>所以周长就是以上两部分的和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">int</span> left;</span><br><span class="line">  	<span class="type">int</span> right;</span><br><span class="line">  	<span class="type">int</span> count;<span class="comment">//被覆盖次数</span></span><br><span class="line">  	<span class="type">int</span> line;<span class="comment">//所包含的区间数量</span></span><br><span class="line">  	<span class="type">int</span> lbd;<span class="comment">//左端点是否被覆盖</span></span><br><span class="line">  	<span class="type">int</span> rbd;<span class="comment">//右端点是否被覆盖</span></span><br><span class="line">  	<span class="type">int</span> len;<span class="comment">//长度 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScanLine</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">int</span> x;</span><br><span class="line">  	<span class="type">int</span> y1;</span><br><span class="line">  	<span class="type">int</span> y2;</span><br><span class="line">  	<span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> node[LEN*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScanLine</span> scan[LEN];</span><br><span class="line"><span class="type">int</span> y[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i)</span><span class="comment">//0 n-1 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	node[i].left = l;</span><br><span class="line">  	node[i].right = r;</span><br><span class="line">  	node[i].count = <span class="number">0</span>;</span><br><span class="line">  	node[i].len = <span class="number">0</span>;</span><br><span class="line">  	node[i].line = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">if</span> (r - l &gt; <span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	<span class="type">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">    	<span class="built_in">build</span>(l, mid, <span class="number">2</span>*i);</span><br><span class="line">    	<span class="built_in">build</span>(mid, r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新测度m</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_len</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (node[i].count &gt; <span class="number">0</span>)</span><br><span class="line">    	node[i].len = y[node[i].right] - y[node[i].left];</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">    	node[i].len = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	node[i].len = node[<span class="number">2</span>*i].len + node[<span class="number">2</span>*i + <span class="number">1</span>].len;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新line</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_line</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (node[i].count &gt; <span class="number">0</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	node[i].lbd = <span class="number">1</span>;</span><br><span class="line">    	node[i].rbd = <span class="number">1</span>;</span><br><span class="line">    	node[i].line = <span class="number">1</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">    	node[i].lbd = <span class="number">0</span>;</span><br><span class="line">    	node[i].rbd = <span class="number">0</span>;</span><br><span class="line">    	node[i].line = <span class="number">0</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	node[i].lbd = node[<span class="number">2</span>*i].lbd;</span><br><span class="line">    	node[i].rbd = node[<span class="number">2</span>*i + <span class="number">1</span>].rbd;</span><br><span class="line">    	node[i].line = node[<span class="number">2</span>*i].line + node[<span class="number">2</span>*i + <span class="number">1</span>].line - node[<span class="number">2</span>*i].rbd*node[<span class="number">2</span>*i + <span class="number">1</span>].lbd;</span><br><span class="line">    	<span class="comment">//cout&lt;&lt;&quot;node[i].lbd:&quot;&lt;&lt;node[i].lbd&lt;&lt;&quot; node[i].rbd:&quot;&lt;&lt;node[i].rbd&lt;&lt;endl;</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i)</span>  <span class="comment">//y1,y2,1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//在这里要取离散化之前的原值进行比较</span></span><br><span class="line">  	<span class="keyword">if</span> (y[node[i].left] &gt;= l &amp;&amp; y[node[i].right] &lt;= r)</span><br><span class="line">    	(node[i].count)++;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	<span class="type">int</span> mid = (node[i].left + node[i].right)/<span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">if</span> (r &lt;= y[mid])</span><br><span class="line">      		<span class="built_in">insert</span>(l, r, <span class="number">2</span>*i);</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= y[mid])</span><br><span class="line">      		<span class="built_in">insert</span>(l, r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="built_in">insert</span>(l, y[mid], <span class="number">2</span>*i );</span><br><span class="line">      		<span class="built_in">insert</span>(y[mid], r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">update_len</span>(i);</span><br><span class="line">  	<span class="built_in">update_line</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//在这里要取离散化之前的原值进行比较</span></span><br><span class="line">  	<span class="keyword">if</span> (y[node[i].left] &gt;= l &amp;&amp; y[node[i].right] &lt;= r)</span><br><span class="line">    	(node[i].count)--;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (node[i].right - node[i].left == <span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">  	<span class="keyword">else</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	<span class="type">int</span> mid = (node[i].left + node[i].right)/<span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">if</span> (r &lt;= y[mid])</span><br><span class="line">      		<span class="built_in">remove</span>(l, r, <span class="number">2</span>*i );</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= y[mid])</span><br><span class="line">      		<span class="built_in">remove</span>(l, r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="built_in">remove</span>(l, y[mid], <span class="number">2</span>*i );</span><br><span class="line">      		<span class="built_in">remove</span>(y[mid], r, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">update_len</span>(i);</span><br><span class="line">  	<span class="built_in">update_line</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">struct</span> ScanLine line1, <span class="keyword">struct</span> ScanLine line2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (line<span class="number">1.</span>x == line<span class="number">2.</span>x)</span><br><span class="line">    	<span class="keyword">return</span> line<span class="number">1.f</span>lag &gt; line<span class="number">2.f</span>lag;</span><br><span class="line">  	<span class="keyword">return</span> (line<span class="number">1.</span>x &lt; line<span class="number">2.</span>x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="type">int</span> n;</span><br><span class="line">  	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  	<span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">  	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span> (n--)</span><br><span class="line">  	&#123;</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    	scan[i].x = x1;</span><br><span class="line">    	scan[i].y1 = y1;</span><br><span class="line">    	scan[i].y2 = y2;</span><br><span class="line">    	scan[i].flag = <span class="number">1</span>;</span><br><span class="line">    	y[i++] = y1;</span><br><span class="line">    	scan[i].x = x2;</span><br><span class="line">    	scan[i].y1 = y1;</span><br><span class="line">    	scan[i].y2 = y2;</span><br><span class="line">    	scan[i].flag = <span class="number">0</span>;</span><br><span class="line">    	y[i++] = y2;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">sort</span>(y, y + i);</span><br><span class="line">  	<span class="built_in">sort</span>(scan, scan + i, cmp);</span><br><span class="line">  	<span class="comment">//y数组中不重复的个数</span></span><br><span class="line">  	<span class="type">int</span> unique_count = <span class="built_in">unique</span>(y, y + i) - y;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	  	for(int i=1;i&lt;n*2;i++)//Y数组去重</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">	        if(Index[i]!=Index[i-1])</span></span><br><span class="line"><span class="comment">	            Index[cnt++]=Index[i-1];</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">    	Index[cnt++]=Index[2*n-1];//这里很容易错!</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">  	<span class="comment">//离散化，建立线段树</span></span><br><span class="line">  	<span class="built_in">build</span>(<span class="number">0</span>, unique_count - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  	<span class="type">int</span> perimeter = <span class="number">0</span>;</span><br><span class="line">  	<span class="type">int</span> now_len = <span class="number">0</span>;</span><br><span class="line">  	<span class="type">int</span> now_line = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">  	&#123;</span><br><span class="line">    	<span class="keyword">if</span> (scan[j].flag)</span><br><span class="line">      		<span class="built_in">insert</span>(scan[j].y1, scan[j].y2, <span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">      		<span class="built_in">remove</span>(scan[j].y1, scan[j].y2, <span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">if</span> (j &gt;= <span class="number">1</span>)</span><br><span class="line">      		perimeter += <span class="number">2</span>*now_line*(scan[j].x - scan[j<span class="number">-1</span>].x);</span><br><span class="line">    	perimeter += <span class="built_in">abs</span>(node[<span class="number">1</span>].len - now_len);</span><br><span class="line">    	now_len = node[<span class="number">1</span>].len;</span><br><span class="line">    	now_line = node[<span class="number">1</span>].line;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, perimeter);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cos.chdacm.cn//imgs/1565071506572.png" alt="1565071506572"></p>
<p>笛卡尔树是形如上图的一棵树，满足<br>①堆的性质，如本图，小根堆，两子的值大于等于父亲的值<br>②二叉搜索树性质，即左子树的点key(默认为下标)比根小，右子树的点key(默认为下标)比根大<br>显然，按中序遍历这棵树，可得原序列<br>③询问下标i到下标j之间(i&lt;j)的最小值，只需寻找[i,j]的lca</p>
<p>可由数列构造，在范围最值查询、范围top k查询(range top k queries)等问题上有广泛应用。它具有堆的有序性，中序遍历可以输出原数列</p>
<p>笛卡尔树比较难的地方在于构造，这里给出大概的思路。</p>
<p>笛卡尔树模板：<br>从前往后遍历A[i]，<br>1.对于每一个A[i]，从栈中找出（从栈顶往栈底遍历，或者从数组后往前遍历）第一个小于等于A[i]的元素<br>2.如果找到，i.parent为sta[k],同时sta[k].r=i，即i为sta[k]的右子树,<br>3.如果栈中存在比A[i]大的元素 这些元素肯定是出栈了，这个问题最后的代码统一表示。<br>同时，sta[k+1].parent=i; i.l=sta[k+1] 即sta[K+1]为i的左子树<br>4.最后i入栈，比i大的A[i]都自动出栈了**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxnum=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxnum];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;tree[maxnum];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxnum;i++)</span><br><span class="line">        tree[i].parent=tree[i].l=tree[i].r=<span class="number">-1</span>;  <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Build_Tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,top,k;</span><br><span class="line">    <span class="type">int</span> stack[maxnum];</span><br><span class="line">    top=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k=top;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; a[stack[k]]&gt;a[i])  <span class="comment">//栈中比当前元素大的都出栈</span></span><br><span class="line">            k--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">-1</span>)  <span class="comment">//find it，栈中元素没有完全出栈，当前元素为栈顶元素的右孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].parent=stack[k];</span><br><span class="line">            tree[stack[k]].r=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;top)    <span class="comment">//出栈的元素为当前元素的左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[stack[k<span class="number">+1</span>]].parent=i;</span><br><span class="line">            tree[i].l=stack[k<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack[++k]=i;<span class="comment">//当前元素入栈</span></span><br><span class="line">        top=k;<span class="comment">//top指向栈顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    tree[stack[<span class="number">0</span>]].parent=<span class="number">-1</span>;<span class="comment">//遍历完成后的栈顶元素就是根</span></span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node!=<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">inorder</span>(tree[node].l);</span><br><span class="line">       cout&lt;&lt;tree[node].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">       <span class="built_in">inorder</span>(tree[node].r);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelorder</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;tree[k].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[k].l!=<span class="number">-1</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(tree[k].l);</span><br><span class="line">        <span class="keyword">if</span>(tree[k].r!=<span class="number">-1</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(tree[k].r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        tree[i].key=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root=<span class="built_in">Build_Tree</span>();</span><br><span class="line">    cout&lt;&lt;root&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorder</span>(root);	<span class="comment">//中序遍历 </span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">levelorder</span>(root);	<span class="comment">//层序遍历 </span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2 4 5 6 8 1 9 1 0 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="例题：牛客多校第一场"><a href="#例题：牛客多校第一场" class="headerlink" title="例题：牛客多校第一场"></a>例题：牛客多校第一场</h3><p>题意：给两个数组a和b，让你找最大的p坐标使得1到p这个范围中，a和b数组里面的最小值的下标一样。</p>
<p>分析：根据笛卡尔树的性质，那不就是求一个最大的下标p，使得两个序列构建的笛卡尔树同构。问题变得简单清晰，直接二分p坐标即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span><span class="number">+10</span>; </span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],l[<span class="number">2</span>][maxn],r[<span class="number">2</span>][maxn],rt[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//找最大的p，使得a,b两数组中1-p范围内，最小元素的下标相同 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">di</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[<span class="number">0</span>][i]=r[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((!s.<span class="built_in">empty</span>())&amp;&amp;(a[i]&lt;a[s.<span class="built_in">top</span>()]))<span class="comment">//i对应的元素值最大,a[i]为父节点,小根堆 </span></span><br><span class="line">            l[<span class="number">0</span>][i]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();<span class="comment">//如果a[i]小于根节点，则将a[i]作为根节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())<span class="comment">//如果a[i]大于根节点，则从根节点的右节点去找位置 </span></span><br><span class="line">            r[<span class="number">0</span>][s.<span class="built_in">top</span>()]=i;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        rt[<span class="number">0</span>]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        l[<span class="number">1</span>][i]=r[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((!s.<span class="built_in">empty</span>())&amp;&amp;(b[i]&lt;b[s.<span class="built_in">top</span>()]))</span><br><span class="line">            l[<span class="number">1</span>][i]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">            r[<span class="number">1</span>][s.<span class="built_in">top</span>()]=i;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        rt[<span class="number">1</span>]=s.<span class="built_in">top</span>(), s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//ab两个数组构成的笛卡尔树一样则可以 </span></span><br><span class="line">        <span class="keyword">if</span>(l[<span class="number">0</span>][i]!=l[<span class="number">1</span>][i]||r[<span class="number">0</span>][i]!=r[<span class="number">1</span>][i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        	cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        	cin&gt;&gt;b[i];</span><br><span class="line">        <span class="type">int</span> L=<span class="number">1</span>,R=n;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)<span class="comment">//二分找最大的符合条件的下标 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">di</span>(mid))</span><br><span class="line">            	L=mid<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">				R=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">di</span>(L))</span><br><span class="line">			L--;</span><br><span class="line">        cout&lt;&lt;L&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2018年杭电多校"><a href="#2018年杭电多校" class="headerlink" title="2018年杭电多校"></a>2018年杭电多校</h3><p>题意：定义RMQ(A,l,r)为：序列A中，满足A[i] = max(A[l],A[l+1],…,A[r])的最小的i。如果对于任意(l,r)都满足RMQ(A,l,r)=RMQ(B,l,r)则为A和B是RMQ Similar。现在出A序列，B序列的每个数都是0~1之间的实数，问满足与A是RMQ Similar的所有B序列中所有数之和的期望。</p>
<p>分析：不难发现，如果A和B是RMQ相似，那么A和B就是笛卡尔树同构。因为B中的每一个数都是 0~1之间的实数，因此出现相同数字的概率可以认为是0，可以假设B是每个数都不相同的排列。设A的笛卡尔树每个子树大小为sz[i]，那么任一B排列和A同构的概率就是sz[i],i从1到n的累乘。又根据题意，B满足均匀分布，因此B的和的期望值是n/2。因此总期望<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/.com//posts/1565071537875.png" alt="1565071537875"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;st;</span><br><span class="line">ll inv[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val,sz;<span class="comment">//sz表示size,子树大小 </span></span><br><span class="line">    <span class="type">int</span> l,r,par;</span><br><span class="line">&#125;t[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        t[i].l=<span class="number">0</span>,t[i].r=<span class="number">0</span>,t[i].par=<span class="number">0</span>,t[i].sz=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">    t[<span class="number">0</span>].val=inf;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;t[st.<span class="built_in">top</span>()].val&lt;t[i].val)<span class="comment">//从栈顶往栈底遍历，</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> par=st.<span class="built_in">top</span>();</span><br><span class="line">        t[i].par=par;<span class="comment">//i.par为st.pop()</span></span><br><span class="line">        t[i].l=t[par].r;<span class="comment">//i的左子树是原来父节点的右节点，因为此点比i先到，且&gt;=i。 </span></span><br><span class="line">        t[t[par].r].par=i;</span><br><span class="line">        t[par].r=i;<span class="comment">//i作为右子树</span></span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//求子树大小 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">    t[u].sz=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(t[u].l);</span><br><span class="line">    <span class="built_in">dfs</span>(t[u].r);</span><br><span class="line">    t[u].sz+=t[t[u].l].sz+t[t[u].r].sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inv</span><span class="params">()</span><span class="comment">//扩展gcd求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=inv[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Inv</span>();</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        	cin&gt;&gt;t[i].val;</span><br><span class="line">        <span class="built_in">build</span>();<span class="comment">//建树 </span></span><br><span class="line">        <span class="built_in">dfs</span>(t[<span class="number">0</span>].r);<span class="comment">//从0节点的右子树开始，计算每个节点的大小 </span></span><br><span class="line"></span><br><span class="line">        ll ans=n*inv[<span class="number">2</span>]%mod;<span class="comment">//以下就是公式的代码表达。 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            ans=ans*inv[t[i].sz]%mod;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>给定一棵二叉树，树上的每个节点带有一个数值，称为节点的关键码。所谓“BST性质”是指，对于树中的任意一个节点：</p>
<p>​    1.该节点的关键码不小于它的左子树中任意节点的关键码。</p>
<p>​    2.该节点的关键码不大于它的右子树中任意节点的关键码。</p>
<p>满足上述性质的二叉树就是一棵“二叉搜索树”。显然，二叉搜索树的中序遍历是一个关键码单调递增的节点序列。</p>
<h3 id="BST的建立"><a href="#BST的建立" class="headerlink" title="BST的建立"></a>BST的建立</h3><p>为了避免越界，减少边界情况的特殊判断，我们一般在BST中额外插入一个关键码为正无穷和一个关键码为负无穷的节点。仅由这两个节点构成的BST就是一棵初始的空的BST。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BST</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l, r; 	<span class="comment">//左右孩子节点在数组中的下标 </span></span><br><span class="line">	<span class="type">int</span> val;  	<span class="comment">//节点关键码 </span></span><br><span class="line">&#125; a[SIZE]; 		</span><br><span class="line"><span class="type">int</span> tot, root, INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">New</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a[++tot].val = val;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">New</span>(-INF), <span class="built_in">New</span>(INF);</span><br><span class="line">	root = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BST的检索"><a href="#BST的检索" class="headerlink" title="BST的检索"></a>BST的检索</h3><p>在BST中检索是否存在关键码为val的节点。设变量p等于根节点root，则执行如下过程：</p>
<p>1.若p的关键码等于val，则已经找到。</p>
<p>2.若p的关键码大于val</p>
<p>​    (1)若p的左子节点为空，则说明不存在val。</p>
<p>​    (2)若p的左子节点不为空，则p的左子树中递归进行检索。</p>
<p>3.若p的关键码小于val</p>
<p>​    (1)若p的右子节点为空，则说明不存在val。</p>
<p>​    (2)若p的右子节点不为空，在p的右子树中递归检索。**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) <span class="comment">//检索失败 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) <span class="comment">// 检索成功 </span></span><br><span class="line">		<span class="keyword">return</span> p; </span><br><span class="line">	<span class="keyword">return</span> val &lt; a[p].val ? <span class="built_in">Get</span>(a[p].l, val) : <span class="built_in">Get</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BST的插入"><a href="#BST的插入" class="headerlink" title="BST的插入"></a>BST的插入</h3><p>在BST中插入一个新的值val(假设目前BST中不存在关键码为val的节点)。那么与BST检索过程类似。</p>
<p>在发现要走向的p的子节点为空，说明val不存在，直接建立关键码为val的新节点作为p的子节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		p = <span class="built_in">New</span>(val); <span class="comment">// 注意p是引用，其父亲节点的l和r值会被同时更新 </span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (val &lt; a[p].val) </span><br><span class="line">		<span class="built_in">Insert</span>(a[p].l, val);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">Insert</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BST求前驱和后继"><a href="#BST求前驱和后继" class="headerlink" title="BST求前驱和后继"></a>BST求前驱和后继</h3><p>以后继为例。val的后继指的是在BST中关键码大于val的前提下，关键码最小的节点。</p>
<p>初始化ans为具有正无穷关键码的那个节点的编号。然后，在BST中检索val。在检索过程中，没经过一个节点，都检查该节点的关键码，判断能否更新所求的后继ans。</p>
<p>检索完成后，有三种可能的结果：</p>
<p>​    1.没有找到val。此时val的后继就在已经经过的节点中，ans即为所求。</p>
<p>​    2.找到了关键码为val的节点p，但是p没有右子树。与上种情况相同，ans即为所求。</p>
<p>​    3.找到了关键码为val的节点p，且p有右子树。那就从p的右子树出发，一直向左走就找到了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNext</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">2</span>; <span class="comment">// a[2].val==INF</span></span><br><span class="line">	<span class="type">int</span> p = root;</span><br><span class="line">	<span class="keyword">while</span> (p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val == a[p].val) <span class="comment">// 检索成功 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (a[p].r &gt; <span class="number">0</span>) <span class="comment">// 有右子树 </span></span><br><span class="line">			&#123; </span><br><span class="line">				p = a[p].r;</span><br><span class="line">				<span class="keyword">while</span> (a[p].l &gt; <span class="number">0</span>) <span class="comment">// 右子树一直向左走 </span></span><br><span class="line">					p = a[p].l;</span><br><span class="line">				ans = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 每经过一个节点，都尝试更新后继</span></span><br><span class="line">		<span class="keyword">if</span> (a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) </span><br><span class="line">			ans = p;</span><br><span class="line">		p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BST的节点删除"><a href="#BST的节点删除" class="headerlink" title="BST的节点删除"></a>BST的节点删除</h3><p>从BST中删除关键码为val的节点。</p>
<p>首先，在BST中检索val，得到节点p。</p>
<p>若p的子节点个数小于2，则直接删除p,并令p的子节点 代替p的位置，与p的父节点相连即可。</p>
<p>若p既有左子树又有右子树，则在BST中求出val的后继节点next。因为next没有左子树，所以可以直接删除next，令next的右子树代替next即可。最后让next代替p节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> val)</span>  <span class="comment">//从子树p中删除值为val的节点 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (val == a[p].val) <span class="comment">// 检索到值为val的节点 </span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (a[p].l == <span class="number">0</span>)  <span class="comment">// 没有左子树 </span></span><br><span class="line">		&#123;</span><br><span class="line">			p = a[p].r; <span class="comment">// 右子树代替p的位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[p].r == <span class="number">0</span>) <span class="comment">//没有右子树 </span></span><br><span class="line">		&#123; </span><br><span class="line">			p = a[p].l; <span class="comment">// 左子树代替p的位置 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 既有左子树又有右子树 </span></span><br><span class="line">		&#123; </span><br><span class="line">			<span class="comment">// 求后继节点 </span></span><br><span class="line">			<span class="type">int</span> next = a[p].r;</span><br><span class="line">			<span class="keyword">while</span> (a[next].l &gt; <span class="number">0</span>) </span><br><span class="line">				next = a[next].l;</span><br><span class="line">			<span class="comment">// next一定没有左子树，直接删除 </span></span><br><span class="line">			<span class="built_in">Remove</span>(a[p].r, a[next].val);</span><br><span class="line">			<span class="comment">// 令next节点代替p节点 </span></span><br><span class="line">			a[next].l = a[p].l, a[next].r = a[p].r;</span><br><span class="line">			p = next; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val &lt; a[p].val) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Remove</span>(a[p].l, val);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Remove</span>(a[p].r, val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在随机数据情况下，BST一次操作的期望复杂度是O(logN)。但是，BST很容易退化，试想如果插入一个有序序列，就会得到一条链，那么平均每次操作的复杂度就是O(N)的，这是我们无法忍受的。这种左右子树大小相差很大的BST是不平衡的。有很多方法可以维持BST的平衡，从而产生了各种平衡树。</p>
<p>那么欲知后事如何，请听下回分解。treap,splay。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%82/">算法讲堂</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a><a class="post-meta__tags" href="/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/">笛卡尔树</a></div><div class="post_share"><div class="social-share" data-image="/img/home-bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/06/GraphTheory/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2019暑期集训第九讲：图论（一）</div></div></a></div><div class="next-post pull-right"><a href="/2019/07/31/DP2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2019暑期集训第七讲：动态规划(II)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/04/暑假集训线段树树状数组/" title="树状数组&线段树入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-04</div><div class="title">树状数组&线段树入门</div></div></a></div><div><a href="/2014/06/30/manacher-algorithm/" title="Manacher's algorithm"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2014-06-30</div><div class="title">Manacher's algorithm</div></div></a></div><div><a href="/2016/12/10/bcj/" title="长安大学ACM协会讲课记录之『基础数据结构—并查集』"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2016-12-10</div><div class="title">长安大学ACM协会讲课记录之『基础数据结构—并查集』</div></div></a></div><div><a href="/2018/09/21/C_first/" title="算法讲堂第一讲 - C语言入门1"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-21</div><div class="title">算法讲堂第一讲 - C语言入门1</div></div></a></div><div><a href="/2018/09/29/C_second/" title="算法讲堂第二讲 - C语言入门2"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-29</div><div class="title">算法讲堂第二讲 - C语言入门2</div></div></a></div><div><a href="/2018/10/11/C_third/" title="算法讲堂第三讲 - C语言入门3"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/home-bg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-11</div><div class="title">算法讲堂第三讲 - C语言入门3</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/kean-logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CHD-ACM</div><div class="author-info__description">coding changes the world!</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">95</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://oj.chdacm.cn"><i class="fas fa-code"></i><span>Go To OnlineJudge</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://jq.qq.com/?_wv=1027&amp;k=8N1yZIvP" target="_blank" title="QQ"><i class="fab iconfont icon-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/1674174622/" target="_blank" title="bilibili"><i class="fab iconfont icon-bilibili-line"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">this is chd acmer !</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6-%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">数据结构进阶(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么要线段树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BB%BA%E6%A0%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">线段树建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">线段树的单点修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">线段树的区间查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9"><span class="toc-number">1.1.6.</span> <span class="toc-text">区间修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9APOJ3468"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">例题：POJ3468</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Billboard"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">Billboard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF"><span class="toc-number">1.2.</span> <span class="toc-text">扫描线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">笛卡尔树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">例题：牛客多校第一场</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2018%E5%B9%B4%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2018年杭电多校</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST"><span class="toc-number">1.4.</span> <span class="toc-text">二叉搜索树(BST)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">BST的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E6%A3%80%E7%B4%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">BST的检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.4.4.</span> <span class="toc-text">BST的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E6%B1%82%E5%89%8D%E9%A9%B1%E5%92%8C%E5%90%8E%E7%BB%A7"><span class="toc-number">1.4.5.</span> <span class="toc-text">BST求前驱和后继</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%A0%E9%99%A4"><span class="toc-number">1.4.6.</span> <span class="toc-text">BST的节点删除</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/16/test/" title="test">test</a><time datetime="2024-08-16T05:30:44.000Z" title="发表于 2024-08-16 13:30:44">2024-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/04/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/" title="图的连通性">图的连通性</a><time datetime="2024-08-04T11:57:49.000Z" title="发表于 2024-08-04 19:57:49">2024-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%826/" title="2022春季算法讲堂（6）">2022春季算法讲堂（6）</a><time datetime="2022-05-05T07:48:40.000Z" title="发表于 2022-05-05 15:48:40">2022-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%825/" title="2022春季算法讲堂（5）">2022春季算法讲堂（5）</a><time datetime="2022-05-05T07:48:10.000Z" title="发表于 2022-05-05 15:48:10">2022-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/05/2022%E6%98%A5%E5%AD%A3%E7%AE%97%E6%B3%95%E8%AE%B2%E5%A0%824/" title="2022春季算法讲堂（4）">2022春季算法讲堂（4）</a><time datetime="2022-05-05T07:48:06.000Z" title="发表于 2022-05-05 15:48:06">2022-05-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/home-bg.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2024 By CHD-ACM</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-three.vercel.app/',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-three.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2712924_e8rmb8q5fcw.css"></script><!-- hexo injector body_end end --></body></html>